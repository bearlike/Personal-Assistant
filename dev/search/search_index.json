{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Personal Assistant Documentation","text":"<p>Welcome to the documentation for Meeseeks: The Personal Assistant. This site is built with MkDocs + Material and versioned with Mike so you can browse docs for both development and released versions.</p>"},{"location":"#what-is-meeseeks","title":"What is Meeseeks?","text":"<p>Meeseeks is a multi-agent assistant that breaks complex user requests into smaller actions, runs them through tools, and provides a consolidated response. This documentation covers how to run the project locally and how to explore the core APIs.</p>"},{"location":"#docs-sections","title":"Docs Sections","text":"<ul> <li>Getting Started for local setup and development tips.</li> <li>Reference for API documentation generated from the source code.</li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10+</li> <li>A virtual environment tool of your choice</li> </ul>"},{"location":"getting-started/#install-documentation-dependencies","title":"Install documentation dependencies","text":"<pre><code>pip install -r requirements-docs.txt\n</code></pre>"},{"location":"getting-started/#run-the-docs-locally","title":"Run the docs locally","text":"<pre><code>export PYTHONPATH=\"$PWD\"\nmkdocs serve\n</code></pre> <p>The documentation will be available at http://127.0.0.1:8000/.</p>"},{"location":"getting-started/#build-the-docs","title":"Build the docs","text":"<pre><code>export PYTHONPATH=\"$PWD\"\nmkdocs build --strict\n</code></pre>"},{"location":"reference/","title":"API Reference","text":""},{"location":"reference/#core-utilities","title":"Core utilities","text":""},{"location":"reference/#core.common.get_logger","title":"<code>get_logger(name=None)</code>","text":"<p>Get the logger for the module.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the logger. Defaults to name.</p> <code>None</code> <p>Returns:</p> Type Description <code>Logger</code> <p>logging.Logger: The logger object.</p> Source code in <code>core/common.py</code> <pre><code>def get_logger(name=None) -&gt; logging_real.Logger:\n    \"\"\" Get the logger for the module.\n\n    Args:\n        name (str, optional): Name of the logger. Defaults to __name__.\n\n    Returns:\n        logging.Logger: The logger object.\n    \"\"\"\n    logging_real.basicConfig(level=logging_real.DEBUG,\n                             format='%(asctime)s - %(levelname)s - %(message)s')\n    loggers_to_suppress = [\n        'request', 'httpcore', 'urllib3.connectionpool', 'openai._base_client',\n        'aiohttp_client_cache.signatures', 'LangChainDeprecationWarning',\n        'watchdog.observers.inotify_buffer', 'PIL.PngImagePlugin'\n    ]\n    for logger_name in loggers_to_suppress:\n        logging_real.getLogger(logger_name).setLevel(logging_real.ERROR)\n\n    if not name:\n        name = __name__\n    logger = logging_real.getLogger(name)\n\n    coloredlogs.install(logger=logger, level=os.getenv(\"LOG_LEVEL\", \"ERROR\"))\n    return logger\n</code></pre>"},{"location":"reference/#core.common.get_mock_speaker","title":"<code>get_mock_speaker()</code>","text":"<p>Return a mock speaker for testing.</p> Source code in <code>core/common.py</code> <pre><code>def get_mock_speaker() -&gt; namedtuple:\n    \"\"\" Return a mock speaker for testing. \"\"\"\n    return namedtuple('MockSpeaker', 'content')\n</code></pre>"},{"location":"reference/#core.common.get_system_prompt","title":"<code>get_system_prompt(name='action-planner')</code>","text":"<p>Get the system prompt for the task queue.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The system prompt for the task queue.</p> Source code in <code>core/common.py</code> <pre><code>def get_system_prompt(name: str = \"action-planner\") -&gt; str:\n    \"\"\" Get the system prompt for the task queue.\n\n    Returns:\n        str: The system prompt for the task queue.\n    \"\"\"\n    logging = get_logger(name=\"core.common.get_system_prompt\")\n    system_prompt_path = os.path.join(\n        os.path.dirname(__file__), \"..\", \"prompts\", f\"{name}.txt\")\n    with open(system_prompt_path, \"r\", encoding=\"utf-8\") as system_prompt_file:\n        system_prompt = system_prompt_file.read()\n    logging.debug(\"Getting system prompt from `%s`\", system_prompt_path)\n    del logging\n    return system_prompt.strip()\n</code></pre>"},{"location":"reference/#core.common.get_unique_timestamp","title":"<code>get_unique_timestamp()</code>","text":"<p>Get a unique timestamp for the task queue.</p> Source code in <code>core/common.py</code> <pre><code>def get_unique_timestamp() -&gt; int:\n    \"\"\" Get a unique timestamp for the task queue. \"\"\"\n    # Get the number of seconds since epoch (Jan 1, 1970) as a float\n    current_timestamp = int(time.time())\n    # Convert it to string for uniqueness and consistency\n    unique_timestamp = str(current_timestamp)\n    # Return the integer version of this string timestamp\n    return int(''.join(str(x) for x in map(int, unique_timestamp)))\n</code></pre>"},{"location":"reference/#core.common.ha_render_system_prompt","title":"<code>ha_render_system_prompt(all_entities=None, env='prompts', name='homeassistant-set-state')</code>","text":"<p>Render the system j2 prompt. Need to make it more generic.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The system prompt for the task queue.</p> Source code in <code>core/common.py</code> <pre><code>def ha_render_system_prompt(\n        all_entities=None, env=\"prompts\", name=\"homeassistant-set-state\") -&gt; str:\n    \"\"\" Render the system j2 prompt. Need to make it more generic.\n\n    Returns:\n        str: The system prompt for the task queue.\n    \"\"\"\n    if all_entities is not None:\n        all_entities = str(all_entities).strip()\n    logging = get_logger(name=\"core.common.render_system_prompt\")\n\n    template_root = os.path.join(__name__, \"..\", \"..\", \"prompts\")\n    template_root = os.path.abspath(template_root)\n    logging.debug(\"Compiling %s from %s.\", name, template_root)\n    # TODO: Catch and log TemplateNotFound when necessary.\n    env = Environment(loader=FileSystemLoader(template_root))\n    template = env.get_template(f\"{name}.txt\")\n    logging.debug(\"Render system prompt for `%s`\", name)\n    del logging\n\n    return template.render(ALL_ENTITIES=all_entities)\n</code></pre>"},{"location":"reference/#core.common.num_tokens_from_string","title":"<code>num_tokens_from_string(string, encoding_name='cl100k_base')</code>","text":"<p>Get the number of tokens in a string using a specific model.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>The string for which the token length is required.</p> required <code>encoding_name</code> <code>str</code> <p>The name of the model.</p> <code>'cl100k_base'</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of tokens for the string.</p> Source code in <code>core/common.py</code> <pre><code>def num_tokens_from_string(\n        string: str, encoding_name: str = \"cl100k_base\") -&gt; int:\n    \"\"\" Get the number of tokens in a string using a specific model.\n\n    Args:\n        string (str): The string for which the token length is required.\n        encoding_name (str): The name of the model.\n\n    Returns:\n        int: Number of tokens for the string.\n    \"\"\"\n    # TODO: Add support for dynamic model selection\n    encoding = tiktoken.get_encoding(encoding_name)\n    num_tokens = len(encoding.encode(string))\n    return num_tokens\n</code></pre>"}]}