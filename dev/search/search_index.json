{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Meeseeks is an AI task agent assistant that breaks a request into small actions, runs the right tools, and replies with a clean summary. This landing page mirrors the README feature highlights so the overview stays consistent. Update both when core positioning changes. Documentation map Overview - README - high-level product overview and feature highlights Setup and configuration - Getting started - environment setup, MCP config, and run commands Repository map - Components - monorepo layout and core packages Reference - API reference - mkdocstrings reference for core modules - Session runtime - shared runtime used by CLI + API Feature highlights (quick view) Plan \u2192 tool selection \u2192 step execution loop to keep work grounded in tool results. Multiple interfaces (chat UI, REST API, Home Assistant, terminal CLI) backed by one core engine. Tool registry for local tools plus optional MCP tools. Built-in local file and shell tools (Aider adapters) for edit blocks, read, list, and shell execution. Session transcripts with compaction for long runs and context budget awareness. Context snapshots built from recent turns plus summaries of prior activity. Session listings filter empty sessions and support archiving via the API. Step-level reflection after tool execution to validate outcomes and adjust tool inputs. Permission gate with approval callbacks plus lightweight hooks around tool execution. Shared session runtime; API exposes polling endpoints while the CLI runs the runtime in-process for sync execution, cancellation, and summaries. Event payloads: action_plan steps are {title, description} , tool events use tool_id , operation , and tool_input . Optional components (Langfuse, Home Assistant) auto-disable when not configured. Langfuse tracing is session-scoped when enabled, grouping multi-turn runs. Repo map (short) packages/meeseeks_core/ : orchestration loop, schemas, session storage, compaction, tool registry. packages/meeseeks_tools/ : tool implementations and integrations. apps/meeseeks_api/ : Flask API that exposes the assistant over HTTP. apps/meeseeks_chat/ : Streamlit UI for interactive chat. apps/meeseeks_cli/ : terminal CLI for interactive sessions. meeseeks_ha_conversation/ : Home Assistant integration that routes voice requests to the API. Prompts are packaged under packages/meeseeks_core/src/meeseeks_core/prompts/ . Architecture in a glance The UI or API sends a user request into the core orchestrator. The orchestrator builds a short action plan, runs tools, and replans if needed. Tool results and summaries are stored in a session transcript for continuity. flowchart LR User --> CLI User --> Chat User --> API HA --> API CLI --> Runtime Chat --> Runtime API --> Runtime Runtime --> Core Runtime --> SessionStore Runtime --> Planner Planner --> ToolSelector ToolSelector --> StepExecutor StepExecutor --> Tools Tools --> LocalTools Tools --> MCP Tools --> HomeAssistant Runtime --> Events[\"Session events (JSONL)\"] Events --> Polling[\"Event polling (API only)\"] Core --> Langfuse Getting started See getting-started.md for full setup (env, MCP, configs, and how to run each interface). CLI quick commands /help show commands /models pick a model from your API /mcp list MCP servers/tools (use /mcp select to filter) /mcp init scaffold an MCP config file /summarize compact the session /status show session status /terminate cancel the active run /new start a fresh session /automatic auto-approve tool actions for the session /quit exit the CLI Deployment (Docker) See getting-started.md for Docker setup and environment requirements.","title":"Home"},{"location":"#documentation-map","text":"Overview - README - high-level product overview and feature highlights Setup and configuration - Getting started - environment setup, MCP config, and run commands Repository map - Components - monorepo layout and core packages Reference - API reference - mkdocstrings reference for core modules - Session runtime - shared runtime used by CLI + API","title":"Documentation map"},{"location":"#feature-highlights-quick-view","text":"Plan \u2192 tool selection \u2192 step execution loop to keep work grounded in tool results. Multiple interfaces (chat UI, REST API, Home Assistant, terminal CLI) backed by one core engine. Tool registry for local tools plus optional MCP tools. Built-in local file and shell tools (Aider adapters) for edit blocks, read, list, and shell execution. Session transcripts with compaction for long runs and context budget awareness. Context snapshots built from recent turns plus summaries of prior activity. Session listings filter empty sessions and support archiving via the API. Step-level reflection after tool execution to validate outcomes and adjust tool inputs. Permission gate with approval callbacks plus lightweight hooks around tool execution. Shared session runtime; API exposes polling endpoints while the CLI runs the runtime in-process for sync execution, cancellation, and summaries. Event payloads: action_plan steps are {title, description} , tool events use tool_id , operation , and tool_input . Optional components (Langfuse, Home Assistant) auto-disable when not configured. Langfuse tracing is session-scoped when enabled, grouping multi-turn runs.","title":"Feature highlights (quick view)"},{"location":"#repo-map-short","text":"packages/meeseeks_core/ : orchestration loop, schemas, session storage, compaction, tool registry. packages/meeseeks_tools/ : tool implementations and integrations. apps/meeseeks_api/ : Flask API that exposes the assistant over HTTP. apps/meeseeks_chat/ : Streamlit UI for interactive chat. apps/meeseeks_cli/ : terminal CLI for interactive sessions. meeseeks_ha_conversation/ : Home Assistant integration that routes voice requests to the API. Prompts are packaged under packages/meeseeks_core/src/meeseeks_core/prompts/ .","title":"Repo map (short)"},{"location":"#architecture-in-a-glance","text":"The UI or API sends a user request into the core orchestrator. The orchestrator builds a short action plan, runs tools, and replans if needed. Tool results and summaries are stored in a session transcript for continuity. flowchart LR User --> CLI User --> Chat User --> API HA --> API CLI --> Runtime Chat --> Runtime API --> Runtime Runtime --> Core Runtime --> SessionStore Runtime --> Planner Planner --> ToolSelector ToolSelector --> StepExecutor StepExecutor --> Tools Tools --> LocalTools Tools --> MCP Tools --> HomeAssistant Runtime --> Events[\"Session events (JSONL)\"] Events --> Polling[\"Event polling (API only)\"] Core --> Langfuse","title":"Architecture in a glance"},{"location":"#getting-started","text":"See getting-started.md for full setup (env, MCP, configs, and how to run each interface).","title":"Getting started"},{"location":"#cli-quick-commands","text":"/help show commands /models pick a model from your API /mcp list MCP servers/tools (use /mcp select to filter) /mcp init scaffold an MCP config file /summarize compact the session /status show session status /terminate cancel the active run /new start a fresh session /automatic auto-approve tool actions for the session /quit exit the CLI","title":"CLI quick commands"},{"location":"#deployment-docker","text":"See getting-started.md for Docker setup and environment requirements.","title":"Deployment (Docker)"},{"location":"components/","text":"This repository is a monorepo. Each component lives in its own folder: packages/meeseeks_core/ : orchestration loop, session runtime, schemas, session storage, compaction, tool registry. packages/meeseeks_tools/ : tool implementations and integration glue. packages/meeseeks_tools/src/meeseeks_tools/vendor/aider : vendored Aider utilities used by local file + shell tools. apps/meeseeks_api/ : Flask API that exposes the assistant over HTTP. apps/meeseeks_chat/ : Streamlit UI for interactive chat. apps/meeseeks_cli/ : terminal CLI for interactive sessions. meeseeks_ha_conversation/ : Home Assistant integration that routes voice requests to the API. Prompts now live under packages/meeseeks_core/src/meeseeks_core/prompts/ and are packaged with the core module.","title":"Components"},{"location":"getting-started/","text":"This guide walks through local setup, environment configuration, MCP setup, and how to run each interface. Prerequisites Python 3.10+ uv Docker (optional, for container runs) Install dependencies User installation (core only) uv sync Optional components (from project root) CLI: uv sync --extra cli API: uv sync --extra api Chat UI: uv sync --extra chat Home Assistant integration: uv sync --extra ha Tools bundle: uv sync --extra tools Everything optional: uv sync --all-extras Developer installation (all components + dev/test/docs) uv sync --all-extras --all-groups Git hooks (recommended) Use the repo hook set to enforce commit message format and block pushes that fail linting/tests. Install the repo-managed hooks: git config core.hooksPath scripts/githooks Optional: enable pre-commit hooks if you use pre-commit locally: make precommit-install Commit message format: <emoji> <verb>(<scope>): <message> Pre-push runs: - scripts/ci/check.sh (ruff format/check, mypy, pytest) Configuration setup If configs are missing, run /config init , /mcp init , or /init from the CLI to scaffold examples. Use only JSON configs under configs/ : configs/app.json (runtime + LLM + integrations) configs/mcp.json (MCP servers) configs/*.example.json are templates for new installs Update configs/app.json with your runtime settings: llm.api_key and llm.api_base (required) llm.default_model and/or llm.action_plan_model Optional: llm.tool_model for tool execution (falls back to action_plan_model , then default_model ) runtime.session_dir (optional, for transcript storage) If you use an OpenAI-compatible base URL and your model name has no provider prefix, Meeseeks will call openai/<model> automatically. MCP setup (auto-discovery) MCP tools are auto-discovered from configs/mcp.json . 1. Set each MCP server url and any headers needed for auth. 2. Start any interface once; a tool manifest is auto-generated and cached under ~/.meeseeks/ . Optional components Langfuse: set langfuse.enabled + keys in configs/app.json . Home Assistant: set home_assistant.enabled + credentials in configs/app.json . CLI approval UI Default approval prompts render as a Rich panel with padded, dotted borders. Use /automatic or --auto-approve to bypass prompts when appropriate. Run interfaces (local) CLI: uv run meeseeks API: uv run meeseeks-api (or uv run python -m meeseeks_api.backend ) Chat UI: uv run meeseeks-chat Home Assistant integration: install meeseeks_ha_conversation/ as a custom component and point it at the API. API notes (polling is API-only; CLI uses the runtime in-process): - Session runtime endpoints support async runs with polling: - POST /api/sessions create session - POST /api/sessions/{session_id}/query enqueue or core commands - GET /api/sessions/{session_id}/events?after=... poll events - GET /api/sessions list sessions (defaults to non-archived, non-empty) - GET /api/sessions?include_archived=1 include archived sessions - POST /api/sessions/{session_id}/archive archive a session - DELETE /api/sessions/{session_id}/archive unarchive a session - POST /api/query synchronous endpoint (simple/CLI-compatible) - GET /api/tools list tool registry entries - GET /api/notifications list notifications - POST /api/notifications/dismiss dismiss notifications - POST /api/notifications/clear clear notifications - POST /api/sessions/{session_id}/attachments upload attachments - POST /api/sessions/{session_id}/share create share link - POST /api/sessions/{session_id}/export export session payload - GET /api/share/{token} fetch shared session data Aider edit blocks (local tool) The edit-block tool expects strict SEARCH/REPLACE blocks and returns format guidance on mismatches. <path> ```text <<<<<<< SEARCH <exact text to match> ======= <replacement text> >>>>>>> REPLACE ``` Rules: - Filename line immediately before the opening fence. - SEARCH must match exactly (including whitespace/newlines). - Use a line with ... in both SEARCH and REPLACE to skip unchanged sections. Docker (optional) Build images using docker/Dockerfile.api and docker/Dockerfile.chat . Mount configs/app.json (and configs/mcp.json if you use MCP). Persist data/sessions if you want transcripts across restarts. Docs (optional) If you want to build the docs locally: uv sync --all-extras --group docs uv run mkdocs serve","title":"Getting Started"},{"location":"getting-started/#prerequisites","text":"Python 3.10+ uv Docker (optional, for container runs)","title":"Prerequisites"},{"location":"getting-started/#install-dependencies","text":"","title":"Install dependencies"},{"location":"getting-started/#user-installation-core-only","text":"uv sync","title":"User installation (core only)"},{"location":"getting-started/#optional-components-from-project-root","text":"CLI: uv sync --extra cli API: uv sync --extra api Chat UI: uv sync --extra chat Home Assistant integration: uv sync --extra ha Tools bundle: uv sync --extra tools Everything optional: uv sync --all-extras","title":"Optional components (from project root)"},{"location":"getting-started/#developer-installation-all-components-devtestdocs","text":"uv sync --all-extras --all-groups","title":"Developer installation (all components + dev/test/docs)"},{"location":"getting-started/#git-hooks-recommended","text":"Use the repo hook set to enforce commit message format and block pushes that fail linting/tests. Install the repo-managed hooks: git config core.hooksPath scripts/githooks Optional: enable pre-commit hooks if you use pre-commit locally: make precommit-install Commit message format: <emoji> <verb>(<scope>): <message> Pre-push runs: - scripts/ci/check.sh (ruff format/check, mypy, pytest)","title":"Git hooks (recommended)"},{"location":"getting-started/#configuration-setup","text":"If configs are missing, run /config init , /mcp init , or /init from the CLI to scaffold examples. Use only JSON configs under configs/ : configs/app.json (runtime + LLM + integrations) configs/mcp.json (MCP servers) configs/*.example.json are templates for new installs Update configs/app.json with your runtime settings: llm.api_key and llm.api_base (required) llm.default_model and/or llm.action_plan_model Optional: llm.tool_model for tool execution (falls back to action_plan_model , then default_model ) runtime.session_dir (optional, for transcript storage) If you use an OpenAI-compatible base URL and your model name has no provider prefix, Meeseeks will call openai/<model> automatically.","title":"Configuration setup"},{"location":"getting-started/#mcp-setup-auto-discovery","text":"MCP tools are auto-discovered from configs/mcp.json . 1. Set each MCP server url and any headers needed for auth. 2. Start any interface once; a tool manifest is auto-generated and cached under ~/.meeseeks/ .","title":"MCP setup (auto-discovery)"},{"location":"getting-started/#optional-components","text":"Langfuse: set langfuse.enabled + keys in configs/app.json . Home Assistant: set home_assistant.enabled + credentials in configs/app.json .","title":"Optional components"},{"location":"getting-started/#cli-approval-ui","text":"Default approval prompts render as a Rich panel with padded, dotted borders. Use /automatic or --auto-approve to bypass prompts when appropriate.","title":"CLI approval UI"},{"location":"getting-started/#run-interfaces-local","text":"CLI: uv run meeseeks API: uv run meeseeks-api (or uv run python -m meeseeks_api.backend ) Chat UI: uv run meeseeks-chat Home Assistant integration: install meeseeks_ha_conversation/ as a custom component and point it at the API. API notes (polling is API-only; CLI uses the runtime in-process): - Session runtime endpoints support async runs with polling: - POST /api/sessions create session - POST /api/sessions/{session_id}/query enqueue or core commands - GET /api/sessions/{session_id}/events?after=... poll events - GET /api/sessions list sessions (defaults to non-archived, non-empty) - GET /api/sessions?include_archived=1 include archived sessions - POST /api/sessions/{session_id}/archive archive a session - DELETE /api/sessions/{session_id}/archive unarchive a session - POST /api/query synchronous endpoint (simple/CLI-compatible) - GET /api/tools list tool registry entries - GET /api/notifications list notifications - POST /api/notifications/dismiss dismiss notifications - POST /api/notifications/clear clear notifications - POST /api/sessions/{session_id}/attachments upload attachments - POST /api/sessions/{session_id}/share create share link - POST /api/sessions/{session_id}/export export session payload - GET /api/share/{token} fetch shared session data","title":"Run interfaces (local)"},{"location":"getting-started/#aider-edit-blocks-local-tool","text":"The edit-block tool expects strict SEARCH/REPLACE blocks and returns format guidance on mismatches. <path> ```text <<<<<<< SEARCH <exact text to match> ======= <replacement text> >>>>>>> REPLACE ``` Rules: - Filename line immediately before the opening fence. - SEARCH must match exactly (including whitespace/newlines). - Use a line with ... in both SEARCH and REPLACE to skip unchanged sections.","title":"Aider edit blocks (local tool)"},{"location":"getting-started/#docker-optional","text":"Build images using docker/Dockerfile.api and docker/Dockerfile.chat . Mount configs/app.json (and configs/mcp.json if you use MCP). Persist data/sessions if you want transcripts across restarts.","title":"Docker (optional)"},{"location":"getting-started/#docs-optional","text":"If you want to build the docs locally: uv sync --all-extras --group docs uv run mkdocs serve","title":"Docs (optional)"},{"location":"reference/","text":"This page is generated from inline docstrings via mkdocstrings. Core SessionStore now includes archive helpers; see meeseeks_core.session_store for details. meeseeks_core.classes Core data models and tool abstractions for Meeseeks orchestration. AbstractTool Bases: ABC Base tool with shared initialization helpers. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 class AbstractTool ( abc . ABC ): \"\"\"Base tool with shared initialization helpers.\"\"\" def __init__ ( self , name : str , description : str , model_name : str | None = None , use_llm : bool = True , ) -> None : \"\"\"Initialize tool configuration.\"\"\" tool_model = get_config_value ( \"llm\" , \"tool_model\" ) default_model = get_config_value ( \"llm\" , \"default_model\" , default = \"gpt-5.2\" ) self . model_name = cast ( str , model_name or tool_model or default_model , ) self . name = name self . description = description self . use_llm = use_llm self . _id = f \" { name . lower () . replace ( ' ' , '_' ) } _tool\" session_id = f \" { self . _id } -tool-id- { get_unique_timestamp () } \" logging . info ( f \"Tool created <name= { name } ; session_id= { session_id } ;>\" ) self . langfuse_handler = build_langfuse_handler ( user_id = f \"meeseeks- { name } \" , session_id = session_id , trace_name = f \"meeseeks- { self . _id } \" , version = get_config_value ( \"runtime\" , \"version\" , default = \"Not Specified\" ), release = get_config_value ( \"runtime\" , \"envmode\" , default = \"Not Specified\" ), ) self . model = None if self . use_llm : self . model = build_chat_model ( model_name = self . model_name , openai_api_base = get_config_value ( \"llm\" , \"api_base\" ), api_key = get_config_value ( \"llm\" , \"api_key\" ), ) root_cache_dir = get_config_value ( \"runtime\" , \"cache_dir\" , default = \".cache\" ) if not root_cache_dir : raise ValueError ( \"runtime.cache_dir is not set.\" ) self . cache_dir = os . path . abspath ( os . path . join ( str ( root_cache_dir ), self . _id )) logging . debug ( \" {} cache directory is {} .\" , self . _id , self . cache_dir ) def _save_json ( self , data : object , filename : str ) -> None : \"\"\"Persist JSON data under the cache directory.\"\"\" if not os . path . exists ( self . cache_dir ): os . makedirs ( self . cache_dir ) filename = os . path . join ( self . cache_dir , filename ) with open ( filename , \"w\" , encoding = \"utf-8\" ) as f : json . dump ( data , f , indent = 4 ) logging . info ( f \"Data saved to { filename } .\" ) def _load_rag_json ( self , filename : str ) -> list [ Document ]: \"\"\"Load JSON content as documents.\"\"\" logging . debug ( \"RAG directory is {} .\" , self . cache_dir ) logging . info ( f \"Loading ` { filename } ` as JSON.\" ) filename = os . path . join ( self . cache_dir , filename ) filename = os . path . abspath ( filename ) loader = JSONLoader ( file_path = filename , jq_schema = \".\" , text_content = False ) data = loader . load () return data def _load_rag_documents ( self , filenames : list [ str ]) -> list [ Document ]: \"\"\"Load and concatenate multiple JSON files.\"\"\" rag_documents : list [ Document ] = [] for rag_file in filenames : data = self . _load_rag_json ( rag_file ) rag_documents . extend ( data ) return rag_documents def set_state ( self , action_step : ActionStep | None = None ) -> MockSpeaker : \"\"\"Perform a state-changing action.\"\"\" MockSpeaker = get_mock_speaker () return MockSpeaker ( content = \"Not implemented yet.\" ) def get_state ( self , action_step : ActionStep | None = None ) -> MockSpeaker : \"\"\"Perform a read-only action.\"\"\" MockSpeaker = get_mock_speaker () return MockSpeaker ( content = \"Not implemented yet.\" ) def run ( self , action_step : ActionStep ) -> MockSpeaker : \"\"\"Execute the action based on the operation.\"\"\" if action_step . operation == \"set\" : return self . set_state ( action_step ) if action_step . operation == \"get\" : return self . get_state ( action_step ) raise ValueError ( f \"Invalid operation: { action_step . operation } \" ) __init__ ( name : str , description : str , model_name : str | None = None , use_llm : bool = True ) -> None Initialize tool configuration. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 def __init__ ( self , name : str , description : str , model_name : str | None = None , use_llm : bool = True , ) -> None : \"\"\"Initialize tool configuration.\"\"\" tool_model = get_config_value ( \"llm\" , \"tool_model\" ) default_model = get_config_value ( \"llm\" , \"default_model\" , default = \"gpt-5.2\" ) self . model_name = cast ( str , model_name or tool_model or default_model , ) self . name = name self . description = description self . use_llm = use_llm self . _id = f \" { name . lower () . replace ( ' ' , '_' ) } _tool\" session_id = f \" { self . _id } -tool-id- { get_unique_timestamp () } \" logging . info ( f \"Tool created <name= { name } ; session_id= { session_id } ;>\" ) self . langfuse_handler = build_langfuse_handler ( user_id = f \"meeseeks- { name } \" , session_id = session_id , trace_name = f \"meeseeks- { self . _id } \" , version = get_config_value ( \"runtime\" , \"version\" , default = \"Not Specified\" ), release = get_config_value ( \"runtime\" , \"envmode\" , default = \"Not Specified\" ), ) self . model = None if self . use_llm : self . model = build_chat_model ( model_name = self . model_name , openai_api_base = get_config_value ( \"llm\" , \"api_base\" ), api_key = get_config_value ( \"llm\" , \"api_key\" ), ) root_cache_dir = get_config_value ( \"runtime\" , \"cache_dir\" , default = \".cache\" ) if not root_cache_dir : raise ValueError ( \"runtime.cache_dir is not set.\" ) self . cache_dir = os . path . abspath ( os . path . join ( str ( root_cache_dir ), self . _id )) logging . debug ( \" {} cache directory is {} .\" , self . _id , self . cache_dir ) get_state ( action_step : ActionStep | None = None ) -> MockSpeaker Perform a read-only action. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 231 232 233 234 def get_state ( self , action_step : ActionStep | None = None ) -> MockSpeaker : \"\"\"Perform a read-only action.\"\"\" MockSpeaker = get_mock_speaker () return MockSpeaker ( content = \"Not implemented yet.\" ) run ( action_step : ActionStep ) -> MockSpeaker Execute the action based on the operation. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 236 237 238 239 240 241 242 def run ( self , action_step : ActionStep ) -> MockSpeaker : \"\"\"Execute the action based on the operation.\"\"\" if action_step . operation == \"set\" : return self . set_state ( action_step ) if action_step . operation == \"get\" : return self . get_state ( action_step ) raise ValueError ( f \"Invalid operation: { action_step . operation } \" ) set_state ( action_step : ActionStep | None = None ) -> MockSpeaker Perform a state-changing action. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 226 227 228 229 def set_state ( self , action_step : ActionStep | None = None ) -> MockSpeaker : \"\"\"Perform a state-changing action.\"\"\" MockSpeaker = get_mock_speaker () return MockSpeaker ( content = \"Not implemented yet.\" ) ActionStep Bases: BaseModel Action step with validation metadata. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 class ActionStep ( BaseModel ): \"\"\"Action step with validation metadata.\"\"\" title : str | None = Field ( default = None , description = \"Short header summarizing the task for this step.\" , ) objective : str | None = Field ( default = None , description = \"Brief objective explaining why this step is needed.\" , ) execution_checklist : list [ str ] = Field ( default_factory = list , description = \"Short checklist of execution details for this step.\" , ) expected_output : str | None = Field ( default = None , description = \"Optional description of what success looks like.\" , ) tool_id : str = Field ( description = ( \"Specify the tool_id that should execute the action. \" \"Use only tool IDs listed under Available tools.\" ) ) operation : str = Field ( description = \"Specify the execution type (get/set or execute).\" ) tool_input : ToolInput = Field ( description = ( \"Provide details for the action. If 'task', specify the task to perform. \" \"If 'talk', include the message to speak to the user.\" ) ) result : object | None = Field ( alias = \"_result\" , default = None , description = \"Private field to persist the action status and other data.\" , ) class Config : \"\"\"Allow both alias and field-name population.\"\"\" allow_population_by_field_name = True extra = \"forbid\" Config Allow both alias and field-name population. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 70 71 72 73 74 class Config : \"\"\"Allow both alias and field-name population.\"\"\" allow_population_by_field_name = True extra = \"forbid\" OrchestrationState Bases: BaseModel State for the orchestration loop. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 143 144 145 146 147 148 149 150 151 152 153 class OrchestrationState ( BaseModel ): \"\"\"State for the orchestration loop.\"\"\" goal : str session_id : str | None = None plan : list [ PlanStep ] = Field ( default_factory = list ) tool_results : list [ str ] = Field ( default_factory = list ) open_questions : list [ str ] = Field ( default_factory = list ) done : bool = False done_reason : str | None = None summary : str | None = None Plan Bases: BaseModel Plan with human-readable steps. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 84 85 86 87 88 89 90 91 92 class Plan ( BaseModel ): \"\"\"Plan with human-readable steps.\"\"\" human_message : str | None = Field ( alias = \"_human_message\" , default = None , description = \"Human message associated with the plan.\" , ) steps : list [ PlanStep ] = Field ( default_factory = list ) PlanStep Bases: BaseModel High-level plan step produced by the planner. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 77 78 79 80 81 class PlanStep ( BaseModel ): \"\"\"High-level plan step produced by the planner.\"\"\" title : str = Field ( description = \"Short title for the step.\" ) description : str = Field ( description = \"One-paragraph description of the step.\" ) TaskQueue Bases: BaseModel Queue of executed tool steps and results. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 class TaskQueue ( BaseModel ): \"\"\"Queue of executed tool steps and results.\"\"\" human_message : str | None = Field ( alias = \"_human_message\" , default = None , description = \"Human message associated with the task queue.\" , ) plan_steps : list [ PlanStep ] = Field ( default_factory = list ) action_steps : list [ ActionStep ] = Field ( default_factory = list ) task_result : str | None = Field ( alias = \"_task_result\" , default = None , description = \"Store the result for the entire task queue\" ) last_error : str | None = Field ( alias = \"_last_error\" , default = None , description = \"Short description of the most recent tool failure.\" , ) @validator ( \"action_steps\" , allow_reuse = True ) # pylint: disable=E0213,W0613 def validate_actions ( cls , field : list [ ActionStep ]) -> list [ ActionStep ]: \"\"\"Normalize and validate action steps.\"\"\" for action in field : action . tool_id = action . tool_id . lower () action . operation = action . operation . lower () error_msg_list = [] if action . tool_id not in AVAILABLE_TOOLS : error_msg_list . append ( f \"` { action . tool_id } ` is not a valid Assistant tool.\" ) if action . operation not in [ \"get\" , \"set\" , \"execute\" ]: error_msg = f \"` { action . operation } ` is not a valid operation.\" error_msg_list . append ( error_msg ) if action . tool_input is None : error_msg_list . append ( \"Tool input cannot be None.\" ) if error_msg_list : for msg in error_msg_list : logging . error ( msg ) return field validate_actions ( field : list [ ActionStep ]) -> list [ ActionStep ] Normalize and validate action steps. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 @validator ( \"action_steps\" , allow_reuse = True ) # pylint: disable=E0213,W0613 def validate_actions ( cls , field : list [ ActionStep ]) -> list [ ActionStep ]: \"\"\"Normalize and validate action steps.\"\"\" for action in field : action . tool_id = action . tool_id . lower () action . operation = action . operation . lower () error_msg_list = [] if action . tool_id not in AVAILABLE_TOOLS : error_msg_list . append ( f \"` { action . tool_id } ` is not a valid Assistant tool.\" ) if action . operation not in [ \"get\" , \"set\" , \"execute\" ]: error_msg = f \"` { action . operation } ` is not a valid operation.\" error_msg_list . append ( error_msg ) if action . tool_input is None : error_msg_list . append ( \"Tool input cannot be None.\" ) if error_msg_list : for msg in error_msg_list : logging . error ( msg ) return field create_plan ( step_data : list [ dict [ str , str ]] | None = None , is_example : bool = True ) -> Plan Create a Plan from serialized step data. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 260 261 262 263 264 265 266 267 268 269 270 271 def create_plan ( step_data : list [ dict [ str , str ]] | None = None , is_example : bool = True , ) -> Plan : \"\"\"Create a Plan from serialized step data.\"\"\" if step_data is None : raise ValueError ( \"Step data cannot be None.\" ) steps = [ PlanStep ( ** step ) for step in step_data ] plan = Plan ( steps = steps ) if is_example : del plan . human_message return plan create_task_queue ( action_data : list [ ActionStepPayload ] | None = None , is_example : bool = True ) -> TaskQueue Create a TaskQueue from serialized action data. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 245 246 247 248 249 250 251 252 253 254 255 256 257 def create_task_queue ( action_data : list [ ActionStepPayload ] | None = None , is_example : bool = True , ) -> TaskQueue : \"\"\"Create a TaskQueue from serialized action data.\"\"\" if action_data is None : raise ValueError ( \"Action data cannot be None.\" ) action_steps = [ ActionStep ( ** action ) for action in action_data ] task_queue = TaskQueue ( action_steps = action_steps ) if is_example : del task_queue . human_message return task_queue get_task_master_examples ( example_id : int = 0 , available_tools : Sequence [ str ] | None = None ) -> str Return serialized example plan data. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 def get_task_master_examples ( example_id : int = 0 , available_tools : Sequence [ str ] | None = None , ) -> str : \"\"\"Return serialized example plan data.\"\"\" if available_tools is None : available_tools = AVAILABLE_TOOLS include_home_assistant = \"home_assistant_tool\" in available_tools if include_home_assistant : examples : list [ list [ dict [ str , str ]]] = [ [ { \"title\" : \"Turn on strip lights\" , \"description\" : \"Use Home Assistant to switch on the strip lights.\" , }, { \"title\" : \"Turn on heater\" , \"description\" : \"Use Home Assistant to switch on the heater.\" , }, ], [ { \"title\" : \"Check weather\" , \"description\" : \"Use Home Assistant to retrieve today's weather details.\" , }, ], ] else : examples = [[], []] if example_id not in range ( 0 , len ( examples )): raise ValueError ( f \"Invalid example ID: { example_id } \" ) return create_plan ( step_data = examples [ example_id ], is_example = True ) . json () set_available_tools ( tool_ids : list [ str ]) -> None Update available tool IDs for validation. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 26 27 28 29 def set_available_tools ( tool_ids : list [ str ]) -> None : \"\"\"Update available tool IDs for validation.\"\"\" global AVAILABLE_TOOLS AVAILABLE_TOOLS = tool_ids meeseeks_core.common Common helpers shared across the assistant runtime. MockSpeaker Bases: NamedTuple Simple mock response container used across tools and tests. Source code in packages/meeseeks_core/src/meeseeks_core/common.py 22 23 24 25 class MockSpeaker ( NamedTuple ): \"\"\"Simple mock response container used across tools and tests.\"\"\" content : str format_tool_input ( tool_input : object ) -> str Format a tool input for logs and prompts. Source code in packages/meeseeks_core/src/meeseeks_core/common.py 169 170 171 172 173 def format_tool_input ( tool_input : object ) -> str : \"\"\"Format a tool input for logs and prompts.\"\"\" if isinstance ( tool_input , dict ): return json . dumps ( tool_input , ensure_ascii = True ) return str ( tool_input ) get_logger ( name : str | None = None ) Get the logger for the module. Source code in packages/meeseeks_core/src/meeseeks_core/common.py 131 132 133 134 135 136 def get_logger ( name : str | None = None ): \"\"\"Get the logger for the module.\"\"\" _configure_logging () if not name : name = __name__ return loguru_logger . bind ( name = name ) get_mock_speaker () -> type [ MockSpeaker ] Return a mock speaker for testing. Source code in packages/meeseeks_core/src/meeseeks_core/common.py 28 29 30 def get_mock_speaker () -> type [ MockSpeaker ]: \"\"\"Return a mock speaker for testing.\"\"\" return MockSpeaker get_system_prompt ( name : str = 'action-planner' ) -> str Get the system prompt for the task queue. Source code in packages/meeseeks_core/src/meeseeks_core/common.py 157 158 159 160 161 162 163 164 165 166 def get_system_prompt ( name : str = \"action-planner\" ) -> str : \"\"\"Get the system prompt for the task queue.\"\"\" logging = get_logger ( name = \"core.common.get_system_prompt\" ) prompt_resource = resources . files ( \"meeseeks_core\" ) . joinpath ( \"prompts\" ) . joinpath ( f \" { name } .txt\" ) with resources . as_file ( prompt_resource ) as system_prompt_path : with open ( system_prompt_path , encoding = \"utf-8\" ) as system_prompt_file : system_prompt = system_prompt_file . read () logging . debug ( \"Getting system prompt from ` {} `\" , system_prompt_path ) del logging return system_prompt . strip () get_unique_timestamp () -> int Get a unique timestamp for the task queue. Source code in packages/meeseeks_core/src/meeseeks_core/common.py 147 148 149 150 151 152 153 154 def get_unique_timestamp () -> int : \"\"\"Get a unique timestamp for the task queue.\"\"\" # Get the number of seconds since epoch (Jan 1, 1970) as a float current_timestamp = int ( time . time ()) # Convert it to string for uniqueness and consistency unique_timestamp = str ( current_timestamp ) # Return the integer version of this string timestamp return int ( \"\" . join ( str ( x ) for x in map ( int , unique_timestamp ))) ha_render_system_prompt ( all_entities : object | None = None , name : str = 'homeassistant-set-state' ) -> str Render the Home Assistant Jinja2 system prompt. Source code in packages/meeseeks_core/src/meeseeks_core/common.py 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 def ha_render_system_prompt ( all_entities : object | None = None , name : str = \"homeassistant-set-state\" , ) -> str : \"\"\"Render the Home Assistant Jinja2 system prompt.\"\"\" if all_entities is not None : all_entities = str ( all_entities ) . strip () logging = get_logger ( name = \"core.common.render_system_prompt\" ) # TODO: Catch and log TemplateNotFound when necessary. template_env = Environment ( loader = PackageLoader ( \"meeseeks_core\" , \"prompts\" )) template = template_env . get_template ( f \" { name } .txt\" ) logging . debug ( \"Render system prompt for ` {} `\" , name ) del logging return template . render ( ALL_ENTITIES = all_entities ) num_tokens_from_string ( string : str , encoding_name : str = 'cl100k_base' ) -> int Get the number of tokens in a string using a specific model. Source code in packages/meeseeks_core/src/meeseeks_core/common.py 139 140 141 142 143 144 def num_tokens_from_string ( string : str , encoding_name : str = \"cl100k_base\" ) -> int : \"\"\"Get the number of tokens in a string using a specific model.\"\"\" # TODO: Add support for dynamic model selection encoding = tiktoken . get_encoding ( encoding_name ) num_tokens = len ( encoding . encode ( string )) return num_tokens session_log_context ( session_id : str , log_dir : str | None = None ) Context manager that logs all session output to a session log file. Source code in packages/meeseeks_core/src/meeseeks_core/common.py 120 121 122 123 124 125 126 127 128 @contextmanager def session_log_context ( session_id : str , log_dir : str | None = None ): \"\"\"Context manager that logs all session output to a session log file.\"\"\" _ensure_session_log_sink ( session_id , log_dir = log_dir ) try : with loguru_logger . contextualize ( session_id = session_id ): yield finally : _release_session_log_sink ( session_id ) meeseeks_core.compaction Transcript compaction utilities. should_compact ( events : Iterable [ EventRecord ], threshold : int = 50 ) -> bool Return True when the event list meets the compaction threshold. Parameters: Name Type Description Default events Iterable [ EventRecord ] Iterable of event records to count. required threshold int Minimum number of events that triggers compaction. 50 Returns: Type Description bool True when compaction should run. Source code in packages/meeseeks_core/src/meeseeks_core/compaction.py 40 41 42 43 44 45 46 47 48 49 50 def should_compact ( events : Iterable [ EventRecord ], threshold : int = 50 ) -> bool : \"\"\"Return True when the event list meets the compaction threshold. Args: events: Iterable of event records to count. threshold: Minimum number of events that triggers compaction. Returns: True when compaction should run. \"\"\" return len ( list ( events )) >= threshold summarize_events ( events : Iterable [ EventRecord ], max_items : int = 20 ) -> str Generate a lightweight summary of recent events. Parameters: Name Type Description Default events Iterable [ EventRecord ] Iterable of event records to summarize. required max_items int Maximum number of recent events to include. 20 Returns: Type Description str Concise summary string of recent events. Source code in packages/meeseeks_core/src/meeseeks_core/compaction.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def summarize_events ( events : Iterable [ EventRecord ], max_items : int = 20 ) -> str : \"\"\"Generate a lightweight summary of recent events. Args: events: Iterable of event records to summarize. max_items: Maximum number of recent events to include. Returns: Concise summary string of recent events. \"\"\" snippets : list [ str ] = [] for event in list ( events )[ - max_items :]: event_type = event . get ( \"type\" , \"event\" ) payload_value : object = event . get ( \"payload\" , \"\" ) if isinstance ( payload_value , dict ): payload_data = dict ( payload_value ) payload_value = ( payload_data . get ( \"text\" ) or payload_data . get ( \"message\" ) or str ( payload_data ) ) if payload_value : snippets . append ( f \" { event_type } : { payload_value } \" ) else : snippets . append ( f \" { event_type } .\" ) return \" | \" . join ( snippets ) . strip () meeseeks_core.components Helpers for optional components and observability integration. ComponentStatus dataclass Describe whether a component is enabled and why. Source code in packages/meeseeks_core/src/meeseeks_core/components.py 34 35 36 37 38 39 40 41 @dataclass ( frozen = True ) class ComponentStatus : \"\"\"Describe whether a component is enabled and why.\"\"\" name : str enabled : bool reason : str | None = None metadata : dict [ str , JsonValue ] = field ( default_factory = dict ) build_langfuse_handler ( * , user_id : str , session_id : str , trace_name : str , version : str , release : str , trace_context : TraceContext | None = None ) -> LangfuseCallbackHandler | None Create a Langfuse callback handler when configured. Source code in packages/meeseeks_core/src/meeseeks_core/components.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def build_langfuse_handler ( * , user_id : str , session_id : str , trace_name : str , version : str , release : str , trace_context : TraceContext | None = None , ) -> LangfuseCallbackHandler | None : \"\"\"Create a Langfuse callback handler when configured.\"\"\" status = resolve_langfuse_status () if not status . enabled : logging . debug ( \"Langfuse disabled: {} \" , status . reason ) return None config = get_config () . langfuse _ensure_langfuse_client ( config ) from langfuse.langchain import CallbackHandler trace_context = trace_context or _LANGFUSE_TRACE_CONTEXT . get () session_id_value = _LANGFUSE_SESSION_ID . get () or session_id user_id_value = _LANGFUSE_USER_ID . get () or user_id try : handler = CallbackHandler ( public_key = config . public_key or None , trace_context = trace_context ) _attach_langfuse_metadata ( handler , user_id = user_id_value , session_id = session_id_value , trace_name = trace_name , version = version , release = release , ) return handler except Exception as exc : # pragma: no cover - defensive logging . warning ( \"Langfuse initialization failed: {} \" , exc ) return None format_component_status ( statuses : Iterable [ ComponentStatus ]) -> str Format component statuses for inclusion in prompts. Source code in packages/meeseeks_core/src/meeseeks_core/components.py 101 102 103 104 105 106 107 108 def format_component_status ( statuses : Iterable [ ComponentStatus ]) -> str : \"\"\"Format component statuses for inclusion in prompts.\"\"\" lines : list [ str ] = [] for status in statuses : state = \"enabled\" if status . enabled else \"disabled\" reason = f \" ( { status . reason } )\" if status . reason else \"\" lines . append ( f \"- { status . name } : { state }{ reason } \" ) return \" \\n \" . join ( lines ) langfuse_session_context ( session_id : str , * , user_id : str | None = None ) -> Iterator [ None ] Bind a stable Langfuse trace context to the current session. Source code in packages/meeseeks_core/src/meeseeks_core/components.py 133 134 135 136 137 138 139 140 141 142 143 144 145 @contextmanager def langfuse_session_context ( session_id : str , * , user_id : str | None = None ) -> Iterator [ None ]: \"\"\"Bind a stable Langfuse trace context to the current session.\"\"\" trace_context = _build_langfuse_trace_context ( session_id ) token_ctx = _LANGFUSE_TRACE_CONTEXT . set ( trace_context ) token_session = _LANGFUSE_SESSION_ID . set ( session_id ) token_user = _LANGFUSE_USER_ID . set ( user_id or session_id ) try : yield finally : _LANGFUSE_TRACE_CONTEXT . reset ( token_ctx ) _LANGFUSE_SESSION_ID . reset ( token_session ) _LANGFUSE_USER_ID . reset ( token_user ) langfuse_trace_span ( name : str ) -> Iterator [ object | None ] Open a Langfuse span bound to the current session trace context. Source code in packages/meeseeks_core/src/meeseeks_core/components.py 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 @contextmanager def langfuse_trace_span ( name : str ) -> Iterator [ object | None ]: \"\"\"Open a Langfuse span bound to the current session trace context.\"\"\" status = resolve_langfuse_status () if not status . enabled : yield None return trace_context = _LANGFUSE_TRACE_CONTEXT . get () if not trace_context : yield None return try : from langfuse import get_client except Exception : # pragma: no cover - defensive yield None return try : langfuse = get_client () with langfuse . start_as_current_observation ( as_type = \"span\" , name = name , trace_context = trace_context , ) as span : yield span except Exception : # pragma: no cover - defensive yield None resolve_home_assistant_status () -> ComponentStatus Determine whether the Home Assistant tool is configured. Source code in packages/meeseeks_core/src/meeseeks_core/components.py 90 91 92 93 94 95 96 97 98 def resolve_home_assistant_status () -> ComponentStatus : \"\"\"Determine whether the Home Assistant tool is configured.\"\"\" enabled , reason , metadata = get_config () . home_assistant . evaluate () return ComponentStatus ( name = \"home_assistant_tool\" , enabled = enabled , reason = reason , metadata = metadata , ) resolve_langfuse_status () -> ComponentStatus Determine whether Langfuse callbacks are available and configured. Source code in packages/meeseeks_core/src/meeseeks_core/components.py 44 45 46 47 def resolve_langfuse_status () -> ComponentStatus : \"\"\"Determine whether Langfuse callbacks are available and configured.\"\"\" enabled , reason , metadata = get_config () . langfuse . evaluate () return ComponentStatus ( name = \"langfuse\" , enabled = enabled , reason = reason , metadata = metadata ) meeseeks_core.hooks Hook manager for orchestration lifecycle events. HookManager dataclass Container for hook callbacks used during orchestration. Source code in packages/meeseeks_core/src/meeseeks_core/hooks.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 @dataclass class HookManager : \"\"\"Container for hook callbacks used during orchestration.\"\"\" pre_tool_use : list [ Callable [[ ActionStep ], ActionStep ]] = field ( default_factory = list ) post_tool_use : list [ Callable [[ ActionStep , MockSpeaker ], MockSpeaker ]] = field ( default_factory = list ) permission_request : list [ Callable [[ ActionStep , PermissionDecision ], PermissionDecision ]] = ( field ( default_factory = list ) ) pre_compact : list [ Callable [[ list [ EventRecord ]], list [ EventRecord ]]] = field ( default_factory = list ) def run_pre_tool_use ( self , action_step : ActionStep ) -> ActionStep : \"\"\"Apply pre-tool hooks to an action step. Args: action_step: Action step to process. Returns: Updated action step after hooks run. \"\"\" for hook in self . pre_tool_use : action_step = hook ( action_step ) return action_step def run_post_tool_use ( self , action_step : ActionStep , result : MockSpeaker ) -> MockSpeaker : \"\"\"Apply post-tool hooks to a tool result. Args: action_step: Action step that was executed. result: Result returned by the tool. Returns: Updated result after hooks run. \"\"\" for hook in self . post_tool_use : result = hook ( action_step , result ) return result def run_permission_request ( self , action_step : ActionStep , decision : PermissionDecision ) -> PermissionDecision : \"\"\"Apply permission hooks to a decision outcome. Args: action_step: Action step under review. decision: Current decision to modify. Returns: Updated permission decision after hooks run. \"\"\" for hook in self . permission_request : decision = hook ( action_step , decision ) return decision def run_pre_compact ( self , events : Iterable [ EventRecord ]) -> list [ EventRecord ]: \"\"\"Apply compaction hooks to events prior to summarization. Args: events: Iterable of event records. Returns: List of event records after hooks run. \"\"\" event_list : list [ EventRecord ] = list ( events ) for hook in self . pre_compact : event_list = hook ( event_list ) return event_list run_permission_request ( action_step : ActionStep , decision : PermissionDecision ) -> PermissionDecision Apply permission hooks to a decision outcome. Parameters: Name Type Description Default action_step ActionStep Action step under review. required decision PermissionDecision Current decision to modify. required Returns: Type Description PermissionDecision Updated permission decision after hooks run. Source code in packages/meeseeks_core/src/meeseeks_core/hooks.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 def run_permission_request ( self , action_step : ActionStep , decision : PermissionDecision ) -> PermissionDecision : \"\"\"Apply permission hooks to a decision outcome. Args: action_step: Action step under review. decision: Current decision to modify. Returns: Updated permission decision after hooks run. \"\"\" for hook in self . permission_request : decision = hook ( action_step , decision ) return decision run_post_tool_use ( action_step : ActionStep , result : MockSpeaker ) -> MockSpeaker Apply post-tool hooks to a tool result. Parameters: Name Type Description Default action_step ActionStep Action step that was executed. required result MockSpeaker Result returned by the tool. required Returns: Type Description MockSpeaker Updated result after hooks run. Source code in packages/meeseeks_core/src/meeseeks_core/hooks.py 43 44 45 46 47 48 49 50 51 52 53 54 55 def run_post_tool_use ( self , action_step : ActionStep , result : MockSpeaker ) -> MockSpeaker : \"\"\"Apply post-tool hooks to a tool result. Args: action_step: Action step that was executed. result: Result returned by the tool. Returns: Updated result after hooks run. \"\"\" for hook in self . post_tool_use : result = hook ( action_step , result ) return result run_pre_compact ( events : Iterable [ EventRecord ]) -> list [ EventRecord ] Apply compaction hooks to events prior to summarization. Parameters: Name Type Description Default events Iterable [ EventRecord ] Iterable of event records. required Returns: Type Description list [ EventRecord ] List of event records after hooks run. Source code in packages/meeseeks_core/src/meeseeks_core/hooks.py 73 74 75 76 77 78 79 80 81 82 83 84 85 def run_pre_compact ( self , events : Iterable [ EventRecord ]) -> list [ EventRecord ]: \"\"\"Apply compaction hooks to events prior to summarization. Args: events: Iterable of event records. Returns: List of event records after hooks run. \"\"\" event_list : list [ EventRecord ] = list ( events ) for hook in self . pre_compact : event_list = hook ( event_list ) return event_list run_pre_tool_use ( action_step : ActionStep ) -> ActionStep Apply pre-tool hooks to an action step. Parameters: Name Type Description Default action_step ActionStep Action step to process. required Returns: Type Description ActionStep Updated action step after hooks run. Source code in packages/meeseeks_core/src/meeseeks_core/hooks.py 30 31 32 33 34 35 36 37 38 39 40 41 def run_pre_tool_use ( self , action_step : ActionStep ) -> ActionStep : \"\"\"Apply pre-tool hooks to an action step. Args: action_step: Action step to process. Returns: Updated action step after hooks run. \"\"\" for hook in self . pre_tool_use : action_step = hook ( action_step ) return action_step default_hook_manager () -> HookManager Create a hook manager with no custom hooks registered. Returns: Type Description HookManager Empty HookManager instance. Source code in packages/meeseeks_core/src/meeseeks_core/hooks.py 88 89 90 91 92 93 94 def default_hook_manager () -> HookManager : \"\"\"Create a hook manager with no custom hooks registered. Returns: Empty HookManager instance. \"\"\" return HookManager () meeseeks_core.llm Model configuration helpers for ChatLiteLLM. ChatModel Bases: Protocol Protocol for LangChain-compatible chat models. Source code in packages/meeseeks_core/src/meeseeks_core/llm.py 12 13 14 15 16 class ChatModel ( Protocol ): \"\"\"Protocol for LangChain-compatible chat models.\"\"\" def invoke ( self , input_data : object , config : object | None = None , ** kwargs : object ) -> object : \"\"\"Invoke the model with structured input.\"\"\" invoke ( input_data : object , config : object | None = None , ** kwargs : object ) -> object Invoke the model with structured input. Source code in packages/meeseeks_core/src/meeseeks_core/llm.py 15 16 def invoke ( self , input_data : object , config : object | None = None , ** kwargs : object ) -> object : \"\"\"Invoke the model with structured input.\"\"\" build_chat_model ( model_name : str , * , openai_api_base : str | None = None , api_key : str | None = None ) -> ChatModel Build a ChatLiteLLM model with reasoning-effort compatibility. Source code in packages/meeseeks_core/src/meeseeks_core/llm.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def build_chat_model ( model_name : str , * , openai_api_base : str | None = None , api_key : str | None = None , ) -> ChatModel : \"\"\"Build a ChatLiteLLM model with reasoning-effort compatibility.\"\"\" try : from langchain_litellm import ChatLiteLLM except ImportError as exc : # pragma: no cover - dependency guard raise ImportError ( \"langchain-litellm is required to build ChatLiteLLM\" ) from exc reasoning_effort = resolve_reasoning_effort ( model_name ) model_kwargs : dict [ str , Any ] = {} if reasoning_effort is not None : model_kwargs [ \"reasoning_effort\" ] = reasoning_effort kwargs : dict [ str , Any ] = { \"model\" : _resolve_litellm_model ( model_name , openai_api_base ), } if openai_api_base : kwargs [ \"api_base\" ] = openai_api_base if api_key : kwargs [ \"api_key\" ] = api_key if model_kwargs : kwargs [ \"model_kwargs\" ] = model_kwargs return cast ( ChatModel , ChatLiteLLM ( ** kwargs )) model_supports_reasoning_effort ( model_name : str | None ) -> bool Return True if the model is known to support reasoning_effort. Source code in packages/meeseeks_core/src/meeseeks_core/llm.py 47 48 49 50 51 52 53 54 55 56 57 58 def model_supports_reasoning_effort ( model_name : str | None ) -> bool : \"\"\"Return True if the model is known to support reasoning_effort.\"\"\" if not model_name : return False raw = model_name . lower () normalized = _strip_provider ( model_name ) allowlist = _normalize_model_list ( get_config_value ( \"llm\" , \"reasoning_effort_models\" , default = []) ) if _matches_model_list ( raw , allowlist ) or _matches_model_list ( normalized , allowlist ): return True return normalized . startswith ( \"gpt-5\" ) resolve_reasoning_effort ( model_name : str | None ) -> str | None Resolve the reasoning effort to use for a model. Source code in packages/meeseeks_core/src/meeseeks_core/llm.py 61 62 63 64 65 66 67 68 69 70 71 def resolve_reasoning_effort ( model_name : str | None ) -> str | None : \"\"\"Resolve the reasoning effort to use for a model.\"\"\" configured = get_config_value ( \"llm\" , \"reasoning_effort\" , default = \"\" ) if isinstance ( configured , str ) and configured . strip (): return configured . strip () . lower () if not model_supports_reasoning_effort ( model_name ): return None normalized = _strip_provider ( model_name ) if \"gpt-5-pro\" in normalized : return \"high\" return \"medium\" meeseeks_core.permissions Permission policies for tool execution. PermissionDecision Bases: str , Enum Outcomes for a permission check. Source code in packages/meeseeks_core/src/meeseeks_core/permissions.py 23 24 25 26 27 28 class PermissionDecision ( str , Enum ): \"\"\"Outcomes for a permission check.\"\"\" ALLOW = \"allow\" DENY = \"deny\" ASK = \"ask\" PermissionPolicy Evaluate permission rules for action steps. Source code in packages/meeseeks_core/src/meeseeks_core/permissions.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 class PermissionPolicy : \"\"\"Evaluate permission rules for action steps.\"\"\" def __init__ ( self , rules : list [ PermissionRule ] | None = None , default_by_operation : dict [ str , PermissionDecision ] | None = None , default_decision : PermissionDecision = PermissionDecision . ASK , ) -> None : \"\"\"Initialize the permission policy.\"\"\" self . _rules = rules or [] self . _default_by_operation = default_by_operation or {} self . _default_decision = default_decision def decide ( self , action_step : ActionStep ) -> PermissionDecision : \"\"\"Return the permission decision for an action step.\"\"\" for rule in self . _rules : if rule . matches ( action_step ): return rule . decision operation_decision = self . _default_by_operation . get ( action_step . operation ) if operation_decision is not None : return operation_decision return self . _default_decision __init__ ( rules : list [ PermissionRule ] | None = None , default_by_operation : dict [ str , PermissionDecision ] | None = None , default_decision : PermissionDecision = PermissionDecision . ASK ) -> None Initialize the permission policy. Source code in packages/meeseeks_core/src/meeseeks_core/permissions.py 49 50 51 52 53 54 55 56 57 58 def __init__ ( self , rules : list [ PermissionRule ] | None = None , default_by_operation : dict [ str , PermissionDecision ] | None = None , default_decision : PermissionDecision = PermissionDecision . ASK , ) -> None : \"\"\"Initialize the permission policy.\"\"\" self . _rules = rules or [] self . _default_by_operation = default_by_operation or {} self . _default_decision = default_decision decide ( action_step : ActionStep ) -> PermissionDecision Return the permission decision for an action step. Source code in packages/meeseeks_core/src/meeseeks_core/permissions.py 60 61 62 63 64 65 66 67 68 def decide ( self , action_step : ActionStep ) -> PermissionDecision : \"\"\"Return the permission decision for an action step.\"\"\" for rule in self . _rules : if rule . matches ( action_step ): return rule . decision operation_decision = self . _default_by_operation . get ( action_step . operation ) if operation_decision is not None : return operation_decision return self . _default_decision PermissionRule dataclass Rule describing a tool/action permission decision. Source code in packages/meeseeks_core/src/meeseeks_core/permissions.py 31 32 33 34 35 36 37 38 39 40 41 42 43 @dataclass ( frozen = True ) class PermissionRule : \"\"\"Rule describing a tool/action permission decision.\"\"\" tool_id : str = \"*\" operation : str = \"*\" decision : PermissionDecision = PermissionDecision . ASK def matches ( self , action_step : ActionStep ) -> bool : \"\"\"Return True when the action step matches the rule pattern.\"\"\" return fnmatch ( action_step . tool_id , self . tool_id ) and fnmatch ( action_step . operation , self . operation ) matches ( action_step : ActionStep ) -> bool Return True when the action step matches the rule pattern. Source code in packages/meeseeks_core/src/meeseeks_core/permissions.py 39 40 41 42 43 def matches ( self , action_step : ActionStep ) -> bool : \"\"\"Return True when the action step matches the rule pattern.\"\"\" return fnmatch ( action_step . tool_id , self . tool_id ) and fnmatch ( action_step . operation , self . operation ) approval_callback_from_config () -> Callable [[ ActionStep ], bool ] | None Return an approval callback based on config settings. Source code in packages/meeseeks_core/src/meeseeks_core/permissions.py 149 150 151 152 153 154 155 156 157 def approval_callback_from_config () -> Callable [[ ActionStep ], bool ] | None : \"\"\"Return an approval callback based on config settings.\"\"\" mode_raw = get_config_value ( \"permissions\" , \"approval_mode\" , default = \"\" ) mode = str ( mode_raw or \"\" ) . strip () . lower () if mode in { \"allow\" , \"auto\" , \"approve\" , \"yes\" }: return lambda _ : True if mode in { \"deny\" , \"never\" , \"no\" }: return lambda _ : False return None auto_approve ( _ : ActionStep ) -> bool Approval callback that always approves. Source code in packages/meeseeks_core/src/meeseeks_core/permissions.py 160 161 162 def auto_approve ( _ : ActionStep ) -> bool : \"\"\"Approval callback that always approves.\"\"\" return True auto_deny ( _ : ActionStep ) -> bool Approval callback that always denies. Source code in packages/meeseeks_core/src/meeseeks_core/permissions.py 165 166 167 def auto_deny ( _ : ActionStep ) -> bool : \"\"\"Approval callback that always denies.\"\"\" return False load_permission_policy ( path : str | None = None ) -> PermissionPolicy Load permission policy configuration from disk or defaults. Source code in packages/meeseeks_core/src/meeseeks_core/permissions.py 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 def load_permission_policy ( path : str | None = None ) -> PermissionPolicy : \"\"\"Load permission policy configuration from disk or defaults.\"\"\" if path is None : path = get_config_value ( \"permissions\" , \"policy_path\" ) if not path : return _default_policy () if not os . path . exists ( path ): logging . warning ( \"Permission policy file not found: {} \" , path ) return _default_policy () try : payload = _load_policy_data ( path ) except ( json . JSONDecodeError , OSError , tomllib . TOMLDecodeError ) as exc : logging . warning ( \"Failed to load permission policy: {} \" , exc ) return _default_policy () rules : list [ PermissionRule ] = [] for rule_data in payload . get ( \"rules\" , []): decision = _parse_decision ( rule_data . get ( \"decision\" )) if decision is None : continue rules . append ( PermissionRule ( tool_id = str ( rule_data . get ( \"tool_id\" , \"*\" )), operation = str ( rule_data . get ( \"operation\" , \"*\" )), decision = decision , ) ) default_by_operation : dict [ str , PermissionDecision ] = {} for key , value in payload . get ( \"default_by_operation\" , {}) . items (): parsed = _parse_decision ( str ( value )) if parsed is not None : default_by_operation [ str ( key )] = parsed default_decision = _parse_decision ( payload . get ( \"default_decision\" )) if default_decision is None : default_decision = PermissionDecision . ASK return PermissionPolicy ( rules = rules , default_by_operation = default_by_operation , default_decision = default_decision , ) meeseeks_core.session_runtime Shared session runtime utilities for CLI and API. RunHandle dataclass Active orchestration thread tracking. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 41 42 43 44 45 46 47 @dataclass ( frozen = True ) class RunHandle : \"\"\"Active orchestration thread tracking.\"\"\" thread : threading . Thread cancel_event : threading . Event started_at : str RunRegistry Track active orchestration threads per session. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 class RunRegistry : \"\"\"Track active orchestration threads per session.\"\"\" def __init__ ( self ) -> None : \"\"\"Initialize the run registry.\"\"\" self . _lock = threading . Lock () self . _runs : dict [ str , RunHandle ] = {} def start ( self , session_id : str , target : Callable [[ threading . Event ], None ], ) -> bool : \"\"\"Start a new run for the session if one is not already active.\"\"\" with self . _lock : existing = self . _runs . get ( session_id ) if existing and existing . thread . is_alive (): return False cancel_event = threading . Event () thread = threading . Thread ( target = self . _wrap_run , args = ( session_id , cancel_event , target ), daemon = True , ) self . _runs [ session_id ] = RunHandle ( thread = thread , cancel_event = cancel_event , started_at = _utc_now (), ) thread . start () return True def _wrap_run ( self , session_id : str , cancel_event : threading . Event , target : Callable [[ threading . Event ], None ], ) -> None : try : target ( cancel_event ) finally : with self . _lock : handle = self . _runs . get ( session_id ) if handle and handle . thread . ident == threading . current_thread () . ident : self . _runs . pop ( session_id , None ) def cancel ( self , session_id : str ) -> bool : \"\"\"Request cancellation for an active session run.\"\"\" with self . _lock : handle = self . _runs . get ( session_id ) if not handle : return False handle . cancel_event . set () return True def is_running ( self , session_id : str ) -> bool : \"\"\"Return True if the session has an active run.\"\"\" with self . _lock : handle = self . _runs . get ( session_id ) return bool ( handle and handle . thread . is_alive ()) def get_cancel_event ( self , session_id : str ) -> threading . Event | None : \"\"\"Return the cancel event for a session, if present.\"\"\" with self . _lock : handle = self . _runs . get ( session_id ) return handle . cancel_event if handle else None __init__ () -> None Initialize the run registry. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 53 54 55 56 def __init__ ( self ) -> None : \"\"\"Initialize the run registry.\"\"\" self . _lock = threading . Lock () self . _runs : dict [ str , RunHandle ] = {} cancel ( session_id : str ) -> bool Request cancellation for an active session run. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 96 97 98 99 100 101 102 103 def cancel ( self , session_id : str ) -> bool : \"\"\"Request cancellation for an active session run.\"\"\" with self . _lock : handle = self . _runs . get ( session_id ) if not handle : return False handle . cancel_event . set () return True get_cancel_event ( session_id : str ) -> threading . Event | None Return the cancel event for a session, if present. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 111 112 113 114 115 def get_cancel_event ( self , session_id : str ) -> threading . Event | None : \"\"\"Return the cancel event for a session, if present.\"\"\" with self . _lock : handle = self . _runs . get ( session_id ) return handle . cancel_event if handle else None is_running ( session_id : str ) -> bool Return True if the session has an active run. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 105 106 107 108 109 def is_running ( self , session_id : str ) -> bool : \"\"\"Return True if the session has an active run.\"\"\" with self . _lock : handle = self . _runs . get ( session_id ) return bool ( handle and handle . thread . is_alive ()) start ( session_id : str , target : Callable [[ threading . Event ], None ]) -> bool Start a new run for the session if one is not already active. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def start ( self , session_id : str , target : Callable [[ threading . Event ], None ], ) -> bool : \"\"\"Start a new run for the session if one is not already active.\"\"\" with self . _lock : existing = self . _runs . get ( session_id ) if existing and existing . thread . is_alive (): return False cancel_event = threading . Event () thread = threading . Thread ( target = self . _wrap_run , args = ( session_id , cancel_event , target ), daemon = True , ) self . _runs [ session_id ] = RunHandle ( thread = thread , cancel_event = cancel_event , started_at = _utc_now (), ) thread . start () return True SessionRuntime Shared orchestration runtime surface for CLI and API. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 class SessionRuntime : \"\"\"Shared orchestration runtime surface for CLI and API.\"\"\" def __init__ ( self , * , session_store : SessionStore | None = None , run_registry : RunRegistry | None = None , ) -> None : \"\"\"Initialize the runtime with session storage and optional run registry.\"\"\" self . _session_store = session_store or SessionStore () self . _run_registry = run_registry or RunRegistry () @property def session_store ( self ) -> SessionStore : \"\"\"Expose the underlying session store.\"\"\" return self . _session_store def resolve_session ( self , * , session_id : str | None = None , session_tag : str | None = None , fork_from : str | None = None , ) -> str : \"\"\"Resolve session identifiers, tags, and forks to a session id.\"\"\" if fork_from : source_session_id = self . _session_store . resolve_tag ( fork_from ) or fork_from session_id = self . _session_store . fork_session ( source_session_id ) if session_tag and not session_id : resolved = self . _session_store . resolve_tag ( session_tag ) session_id = resolved if resolved else None if not session_id : session_id = self . _session_store . create_session () if session_tag : self . _session_store . tag_session ( session_id , session_tag ) assert session_id is not None return session_id def append_context_event ( self , session_id : str , context : dict [ str , object ]) -> None : \"\"\"Append a context event to the session transcript.\"\"\" if not context : return self . _session_store . append_event ( session_id , { \"type\" : \"context\" , \"payload\" : context }) def summarize_session ( self , session_id : str , * , events : list [ EventRecord ] | None = None , ) -> dict [ str , object ]: \"\"\"Return a summarized view of a session.\"\"\" if events is None : events = self . _session_store . load_transcript ( session_id ) created_at = events [ 0 ][ \"ts\" ] if events else None title = None status = \"idle\" done_reason = None context : dict [ str , object ] | None = None has_user_event = False for event in events : if event . get ( \"type\" ) == \"context\" : payload = event . get ( \"payload\" ) if isinstance ( payload , dict ): context = payload if title is None and event . get ( \"type\" ) == \"user\" : has_user_event = True payload = event . get ( \"payload\" , {}) if isinstance ( payload , dict ): title = payload . get ( \"text\" ) if event . get ( \"type\" ) == \"completion\" : payload = event . get ( \"payload\" , {}) if isinstance ( payload , dict ): done_reason = payload . get ( \"done_reason\" ) status = \"completed\" if payload . get ( \"done\" ) else \"incomplete\" running = self . is_running ( session_id ) if running : status = \"running\" if not has_user_event and not running : created_at = None if not title : title = f \"Session { session_id [: 8 ] } \" return { \"session_id\" : session_id , \"title\" : title , \"created_at\" : created_at , \"status\" : status , \"done_reason\" : done_reason , \"running\" : running , \"context\" : context or {}, \"archived\" : self . _session_store . is_archived ( session_id ), } def list_sessions ( self , * , include_archived : bool = False ) -> list [ dict [ str , object ]]: \"\"\"List sessions with summary metadata.\"\"\" summaries : list [ dict [ str , object ]] = [] for session_id in self . _session_store . list_sessions (): events = self . _session_store . load_transcript ( session_id ) summary = self . summarize_session ( session_id , events = events ) has_visible_event = any ( event . get ( \"type\" ) not in { \"session\" , \"context\" } for event in events ) if not has_visible_event and not summary . get ( \"running\" ): continue if summary . get ( \"created_at\" ) is None and not summary . get ( \"running\" ): continue if not include_archived and summary . get ( \"archived\" ): continue summaries . append ( summary ) return summaries def load_events ( self , session_id : str , after : str | None = None ) -> list [ EventRecord ]: \"\"\"Load events for a session with optional timestamp filtering.\"\"\" events = self . _session_store . load_transcript ( session_id ) return _filter_events ( events , after ) def start_async ( self , * , session_id : str , user_query : str , model_name : str | None = None , max_iters : int = 3 , initial_plan : Plan | None = None , tool_registry = None , permission_policy = None , approval_callback = None , hook_manager = None , mode : str | None = None , ) -> bool : \"\"\"Start an asynchronous orchestration run for the session.\"\"\" def _run ( cancel_event : threading . Event ) -> None : self . run_sync ( user_query = user_query , session_id = session_id , model_name = model_name , max_iters = max_iters , initial_plan = initial_plan , tool_registry = tool_registry , permission_policy = permission_policy , approval_callback = approval_callback , hook_manager = hook_manager , mode = mode , should_cancel = cancel_event . is_set , ) return self . _run_registry . start ( session_id , target = _run ) def run_sync ( self , * , user_query : str , session_id : str , model_name : str | None = None , max_iters : int = 3 , initial_plan : Plan | None = None , tool_registry = None , permission_policy = None , approval_callback = None , hook_manager = None , mode : str | None = None , should_cancel : Callable [[], bool ] | None = None , ) -> TaskQueue : \"\"\"Run an orchestration request synchronously.\"\"\" return orchestrate_session ( user_query = user_query , model_name = model_name , max_iters = max_iters , initial_plan = initial_plan , session_id = session_id , session_store = self . _session_store , tool_registry = tool_registry , permission_policy = permission_policy , approval_callback = approval_callback , hook_manager = hook_manager , mode = mode , should_cancel = should_cancel , ) def cancel ( self , session_id : str ) -> bool : \"\"\"Cancel an active run if present.\"\"\" return self . _run_registry . cancel ( session_id ) def is_running ( self , session_id : str ) -> bool : \"\"\"Return True if session has an active run.\"\"\" return self . _run_registry . is_running ( session_id ) session_store : SessionStore property Expose the underlying session store. __init__ ( * , session_store : SessionStore | None = None , run_registry : RunRegistry | None = None ) -> None Initialize the runtime with session storage and optional run registry. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 135 136 137 138 139 140 141 142 143 def __init__ ( self , * , session_store : SessionStore | None = None , run_registry : RunRegistry | None = None , ) -> None : \"\"\"Initialize the runtime with session storage and optional run registry.\"\"\" self . _session_store = session_store or SessionStore () self . _run_registry = run_registry or RunRegistry () append_context_event ( session_id : str , context : dict [ str , object ]) -> None Append a context event to the session transcript. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 171 172 173 174 175 def append_context_event ( self , session_id : str , context : dict [ str , object ]) -> None : \"\"\"Append a context event to the session transcript.\"\"\" if not context : return self . _session_store . append_event ( session_id , { \"type\" : \"context\" , \"payload\" : context }) cancel ( session_id : str ) -> bool Cancel an active run if present. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 312 313 314 def cancel ( self , session_id : str ) -> bool : \"\"\"Cancel an active run if present.\"\"\" return self . _run_registry . cancel ( session_id ) is_running ( session_id : str ) -> bool Return True if session has an active run. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 316 317 318 def is_running ( self , session_id : str ) -> bool : \"\"\"Return True if session has an active run.\"\"\" return self . _run_registry . is_running ( session_id ) list_sessions ( * , include_archived : bool = False ) -> list [ dict [ str , object ]] List sessions with summary metadata. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 def list_sessions ( self , * , include_archived : bool = False ) -> list [ dict [ str , object ]]: \"\"\"List sessions with summary metadata.\"\"\" summaries : list [ dict [ str , object ]] = [] for session_id in self . _session_store . list_sessions (): events = self . _session_store . load_transcript ( session_id ) summary = self . summarize_session ( session_id , events = events ) has_visible_event = any ( event . get ( \"type\" ) not in { \"session\" , \"context\" } for event in events ) if not has_visible_event and not summary . get ( \"running\" ): continue if summary . get ( \"created_at\" ) is None and not summary . get ( \"running\" ): continue if not include_archived and summary . get ( \"archived\" ): continue summaries . append ( summary ) return summaries load_events ( session_id : str , after : str | None = None ) -> list [ EventRecord ] Load events for a session with optional timestamp filtering. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 243 244 245 246 def load_events ( self , session_id : str , after : str | None = None ) -> list [ EventRecord ]: \"\"\"Load events for a session with optional timestamp filtering.\"\"\" events = self . _session_store . load_transcript ( session_id ) return _filter_events ( events , after ) resolve_session ( * , session_id : str | None = None , session_tag : str | None = None , fork_from : str | None = None ) -> str Resolve session identifiers, tags, and forks to a session id. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 def resolve_session ( self , * , session_id : str | None = None , session_tag : str | None = None , fork_from : str | None = None , ) -> str : \"\"\"Resolve session identifiers, tags, and forks to a session id.\"\"\" if fork_from : source_session_id = self . _session_store . resolve_tag ( fork_from ) or fork_from session_id = self . _session_store . fork_session ( source_session_id ) if session_tag and not session_id : resolved = self . _session_store . resolve_tag ( session_tag ) session_id = resolved if resolved else None if not session_id : session_id = self . _session_store . create_session () if session_tag : self . _session_store . tag_session ( session_id , session_tag ) assert session_id is not None return session_id run_sync ( * , user_query : str , session_id : str , model_name : str | None = None , max_iters : int = 3 , initial_plan : Plan | None = None , tool_registry = None , permission_policy = None , approval_callback = None , hook_manager = None , mode : str | None = None , should_cancel : Callable [[], bool ] | None = None ) -> TaskQueue Run an orchestration request synchronously. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 def run_sync ( self , * , user_query : str , session_id : str , model_name : str | None = None , max_iters : int = 3 , initial_plan : Plan | None = None , tool_registry = None , permission_policy = None , approval_callback = None , hook_manager = None , mode : str | None = None , should_cancel : Callable [[], bool ] | None = None , ) -> TaskQueue : \"\"\"Run an orchestration request synchronously.\"\"\" return orchestrate_session ( user_query = user_query , model_name = model_name , max_iters = max_iters , initial_plan = initial_plan , session_id = session_id , session_store = self . _session_store , tool_registry = tool_registry , permission_policy = permission_policy , approval_callback = approval_callback , hook_manager = hook_manager , mode = mode , should_cancel = should_cancel , ) start_async ( * , session_id : str , user_query : str , model_name : str | None = None , max_iters : int = 3 , initial_plan : Plan | None = None , tool_registry = None , permission_policy = None , approval_callback = None , hook_manager = None , mode : str | None = None ) -> bool Start an asynchronous orchestration run for the session. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 def start_async ( self , * , session_id : str , user_query : str , model_name : str | None = None , max_iters : int = 3 , initial_plan : Plan | None = None , tool_registry = None , permission_policy = None , approval_callback = None , hook_manager = None , mode : str | None = None , ) -> bool : \"\"\"Start an asynchronous orchestration run for the session.\"\"\" def _run ( cancel_event : threading . Event ) -> None : self . run_sync ( user_query = user_query , session_id = session_id , model_name = model_name , max_iters = max_iters , initial_plan = initial_plan , tool_registry = tool_registry , permission_policy = permission_policy , approval_callback = approval_callback , hook_manager = hook_manager , mode = mode , should_cancel = cancel_event . is_set , ) return self . _run_registry . start ( session_id , target = _run ) summarize_session ( session_id : str , * , events : list [ EventRecord ] | None = None ) -> dict [ str , object ] Return a summarized view of a session. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 def summarize_session ( self , session_id : str , * , events : list [ EventRecord ] | None = None , ) -> dict [ str , object ]: \"\"\"Return a summarized view of a session.\"\"\" if events is None : events = self . _session_store . load_transcript ( session_id ) created_at = events [ 0 ][ \"ts\" ] if events else None title = None status = \"idle\" done_reason = None context : dict [ str , object ] | None = None has_user_event = False for event in events : if event . get ( \"type\" ) == \"context\" : payload = event . get ( \"payload\" ) if isinstance ( payload , dict ): context = payload if title is None and event . get ( \"type\" ) == \"user\" : has_user_event = True payload = event . get ( \"payload\" , {}) if isinstance ( payload , dict ): title = payload . get ( \"text\" ) if event . get ( \"type\" ) == \"completion\" : payload = event . get ( \"payload\" , {}) if isinstance ( payload , dict ): done_reason = payload . get ( \"done_reason\" ) status = \"completed\" if payload . get ( \"done\" ) else \"incomplete\" running = self . is_running ( session_id ) if running : status = \"running\" if not has_user_event and not running : created_at = None if not title : title = f \"Session { session_id [: 8 ] } \" return { \"session_id\" : session_id , \"title\" : title , \"created_at\" : created_at , \"status\" : status , \"done_reason\" : done_reason , \"running\" : running , \"context\" : context or {}, \"archived\" : self . _session_store . is_archived ( session_id ), } parse_core_command ( text : str ) -> str | None Return the core command token if present. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 33 34 35 36 37 38 def parse_core_command ( text : str ) -> str | None : \"\"\"Return the core command token if present.\"\"\" if not text : return None command = text . strip () . lower () . split ()[ 0 ] return command if command in CORE_COMMANDS else None meeseeks_core.session_store Session transcript storage and management. SessionPaths dataclass Resolved filesystem paths for a session. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 @dataclass ( frozen = True ) class SessionPaths : \"\"\"Resolved filesystem paths for a session.\"\"\" root : str session_id : str @property def session_dir ( self ) -> str : \"\"\"Directory for session artifacts.\"\"\" return os . path . join ( self . root , self . session_id ) @property def transcript_path ( self ) -> str : \"\"\"Path to the JSONL transcript file.\"\"\" return os . path . join ( self . session_dir , \"transcript.jsonl\" ) @property def summary_path ( self ) -> str : \"\"\"Path to the summary JSON file.\"\"\" return os . path . join ( self . session_dir , \"summary.json\" ) session_dir : str property Directory for session artifacts. summary_path : str property Path to the summary JSON file. transcript_path : str property Path to the JSONL transcript file. SessionStore Filesystem-backed storage for session transcripts and summaries. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 class SessionStore : \"\"\"Filesystem-backed storage for session transcripts and summaries.\"\"\" def __init__ ( self , root_dir : str | None = None ) -> None : \"\"\"Initialize the store and ensure the root directory exists.\"\"\" if root_dir is None : root_dir = get_config_value ( \"runtime\" , \"session_dir\" , default = \"./data/sessions\" ) self . root_dir = os . path . abspath ( root_dir ) os . makedirs ( self . root_dir , exist_ok = True ) def _index_path ( self ) -> str : \"\"\"Return the path for the session index file.\"\"\" return os . path . join ( self . root_dir , \"index.json\" ) def _load_index ( self ) -> dict [ str , dict [ str , str ]]: \"\"\"Load the session index from disk or return defaults.\"\"\" index_path = self . _index_path () if not os . path . exists ( index_path ): return { \"tags\" : {}, \"archived\" : {}} with open ( index_path , encoding = \"utf-8\" ) as handle : return json . load ( handle ) def _save_index ( self , data : dict [ str , dict [ str , str ]]) -> None : \"\"\"Persist the session index to disk.\"\"\" with open ( self . _index_path (), \"w\" , encoding = \"utf-8\" ) as handle : json . dump ( data , handle , indent = 2 ) def create_session ( self ) -> str : \"\"\"Create a new session directory and return its identifier.\"\"\" session_id = uuid . uuid4 () . hex paths = self . _paths ( session_id ) os . makedirs ( paths . session_dir , exist_ok = True ) return session_id def _paths ( self , session_id : str ) -> SessionPaths : \"\"\"Build filesystem paths for a session.\"\"\" return SessionPaths ( root = self . root_dir , session_id = session_id ) def append_event ( self , session_id : str , event : Event ) -> None : \"\"\"Append a single event record to the session transcript.\"\"\" paths = self . _paths ( session_id ) os . makedirs ( paths . session_dir , exist_ok = True ) payload : EventRecord = { \"ts\" : _utc_now (), ** event } with open ( paths . transcript_path , \"a\" , encoding = \"utf-8\" ) as handle : handle . write ( json . dumps ( payload ) + \" \\n \" ) def load_transcript ( self , session_id : str ) -> list [ EventRecord ]: \"\"\"Load all transcript events for a session.\"\"\" paths = self . _paths ( session_id ) if not os . path . exists ( paths . transcript_path ): return [] events : list [ EventRecord ] = [] with open ( paths . transcript_path , encoding = \"utf-8\" ) as handle : for line in handle : line = line . strip () if not line : continue try : events . append ( json . loads ( line )) except json . JSONDecodeError : logging . warning ( \"Skipping malformed transcript line.\" ) return events def load_recent_events ( self , session_id : str , limit : int = 8 , include_types : set [ str ] | None = None , ) -> list [ EventRecord ]: \"\"\"Load the most recent events, optionally filtered by type.\"\"\" events = self . load_transcript ( session_id ) if include_types : events = [ event for event in events if event . get ( \"type\" ) in include_types ] if limit <= 0 : return [] return events [ - limit :] def save_summary ( self , session_id : str , summary : str ) -> None : \"\"\"Persist a summary for a session.\"\"\" paths = self . _paths ( session_id ) os . makedirs ( paths . session_dir , exist_ok = True ) with open ( paths . summary_path , \"w\" , encoding = \"utf-8\" ) as handle : json . dump ({ \"summary\" : summary , \"updated_at\" : _utc_now ()}, handle , indent = 2 ) def load_summary ( self , session_id : str ) -> str | None : \"\"\"Load a previously saved summary, if present.\"\"\" paths = self . _paths ( session_id ) if not os . path . exists ( paths . summary_path ): return None with open ( paths . summary_path , encoding = \"utf-8\" ) as handle : data = json . load ( handle ) return data . get ( \"summary\" ) def list_sessions ( self ) -> list [ str ]: \"\"\"List all session IDs present in the root directory.\"\"\" if not os . path . exists ( self . root_dir ): return [] return sorted ( name for name in os . listdir ( self . root_dir ) if os . path . isdir ( os . path . join ( self . root_dir , name )) ) def fork_session ( self , source_session_id : str ) -> str : \"\"\"Create a new session by copying events and summary from another.\"\"\" events = self . load_transcript ( source_session_id ) summary = self . load_summary ( source_session_id ) new_session_id = self . create_session () for event in events : self . append_event ( new_session_id , event ) if summary : self . save_summary ( new_session_id , summary ) return new_session_id def tag_session ( self , session_id : str , tag : str ) -> None : \"\"\"Associate a tag with a session ID for quick lookup.\"\"\" index = self . _load_index () index . setdefault ( \"tags\" , {})[ tag ] = session_id self . _save_index ( index ) def resolve_tag ( self , tag : str ) -> str | None : \"\"\"Resolve a tag to a session ID, if present.\"\"\" index = self . _load_index () return index . get ( \"tags\" , {}) . get ( tag ) def list_tags ( self ) -> dict [ str , str ]: \"\"\"Return a mapping of tags to session IDs.\"\"\" index = self . _load_index () return dict ( index . get ( \"tags\" , {})) def archive_session ( self , session_id : str ) -> None : \"\"\"Mark a session as archived.\"\"\" index = self . _load_index () archived = index . setdefault ( \"archived\" , {}) archived [ session_id ] = _utc_now () self . _save_index ( index ) def unarchive_session ( self , session_id : str ) -> None : \"\"\"Remove archived status from a session.\"\"\" index = self . _load_index () archived = index . get ( \"archived\" , {}) if session_id in archived : archived . pop ( session_id , None ) index [ \"archived\" ] = archived self . _save_index ( index ) def is_archived ( self , session_id : str ) -> bool : \"\"\"Return True if a session is archived.\"\"\" index = self . _load_index () archived = index . get ( \"archived\" , {}) return session_id in archived __init__ ( root_dir : str | None = None ) -> None Initialize the store and ensure the root directory exists. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 50 51 52 53 54 55 def __init__ ( self , root_dir : str | None = None ) -> None : \"\"\"Initialize the store and ensure the root directory exists.\"\"\" if root_dir is None : root_dir = get_config_value ( \"runtime\" , \"session_dir\" , default = \"./data/sessions\" ) self . root_dir = os . path . abspath ( root_dir ) os . makedirs ( self . root_dir , exist_ok = True ) append_event ( session_id : str , event : Event ) -> None Append a single event record to the session transcript. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 85 86 87 88 89 90 91 def append_event ( self , session_id : str , event : Event ) -> None : \"\"\"Append a single event record to the session transcript.\"\"\" paths = self . _paths ( session_id ) os . makedirs ( paths . session_dir , exist_ok = True ) payload : EventRecord = { \"ts\" : _utc_now (), ** event } with open ( paths . transcript_path , \"a\" , encoding = \"utf-8\" ) as handle : handle . write ( json . dumps ( payload ) + \" \\n \" ) archive_session ( session_id : str ) -> None Mark a session as archived. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 177 178 179 180 181 182 def archive_session ( self , session_id : str ) -> None : \"\"\"Mark a session as archived.\"\"\" index = self . _load_index () archived = index . setdefault ( \"archived\" , {}) archived [ session_id ] = _utc_now () self . _save_index ( index ) create_session () -> str Create a new session directory and return its identifier. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 74 75 76 77 78 79 def create_session ( self ) -> str : \"\"\"Create a new session directory and return its identifier.\"\"\" session_id = uuid . uuid4 () . hex paths = self . _paths ( session_id ) os . makedirs ( paths . session_dir , exist_ok = True ) return session_id fork_session ( source_session_id : str ) -> str Create a new session by copying events and summary from another. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 150 151 152 153 154 155 156 157 158 159 def fork_session ( self , source_session_id : str ) -> str : \"\"\"Create a new session by copying events and summary from another.\"\"\" events = self . load_transcript ( source_session_id ) summary = self . load_summary ( source_session_id ) new_session_id = self . create_session () for event in events : self . append_event ( new_session_id , event ) if summary : self . save_summary ( new_session_id , summary ) return new_session_id is_archived ( session_id : str ) -> bool Return True if a session is archived. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 193 194 195 196 197 def is_archived ( self , session_id : str ) -> bool : \"\"\"Return True if a session is archived.\"\"\" index = self . _load_index () archived = index . get ( \"archived\" , {}) return session_id in archived list_sessions () -> list [ str ] List all session IDs present in the root directory. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 140 141 142 143 144 145 146 147 148 def list_sessions ( self ) -> list [ str ]: \"\"\"List all session IDs present in the root directory.\"\"\" if not os . path . exists ( self . root_dir ): return [] return sorted ( name for name in os . listdir ( self . root_dir ) if os . path . isdir ( os . path . join ( self . root_dir , name )) ) list_tags () -> dict [ str , str ] Return a mapping of tags to session IDs. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 172 173 174 175 def list_tags ( self ) -> dict [ str , str ]: \"\"\"Return a mapping of tags to session IDs.\"\"\" index = self . _load_index () return dict ( index . get ( \"tags\" , {})) load_recent_events ( session_id : str , limit : int = 8 , include_types : set [ str ] | None = None ) -> list [ EventRecord ] Load the most recent events, optionally filtered by type. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 110 111 112 113 114 115 116 117 118 119 120 121 122 def load_recent_events ( self , session_id : str , limit : int = 8 , include_types : set [ str ] | None = None , ) -> list [ EventRecord ]: \"\"\"Load the most recent events, optionally filtered by type.\"\"\" events = self . load_transcript ( session_id ) if include_types : events = [ event for event in events if event . get ( \"type\" ) in include_types ] if limit <= 0 : return [] return events [ - limit :] load_summary ( session_id : str ) -> str | None Load a previously saved summary, if present. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 131 132 133 134 135 136 137 138 def load_summary ( self , session_id : str ) -> str | None : \"\"\"Load a previously saved summary, if present.\"\"\" paths = self . _paths ( session_id ) if not os . path . exists ( paths . summary_path ): return None with open ( paths . summary_path , encoding = \"utf-8\" ) as handle : data = json . load ( handle ) return data . get ( \"summary\" ) load_transcript ( session_id : str ) -> list [ EventRecord ] Load all transcript events for a session. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 def load_transcript ( self , session_id : str ) -> list [ EventRecord ]: \"\"\"Load all transcript events for a session.\"\"\" paths = self . _paths ( session_id ) if not os . path . exists ( paths . transcript_path ): return [] events : list [ EventRecord ] = [] with open ( paths . transcript_path , encoding = \"utf-8\" ) as handle : for line in handle : line = line . strip () if not line : continue try : events . append ( json . loads ( line )) except json . JSONDecodeError : logging . warning ( \"Skipping malformed transcript line.\" ) return events resolve_tag ( tag : str ) -> str | None Resolve a tag to a session ID, if present. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 167 168 169 170 def resolve_tag ( self , tag : str ) -> str | None : \"\"\"Resolve a tag to a session ID, if present.\"\"\" index = self . _load_index () return index . get ( \"tags\" , {}) . get ( tag ) save_summary ( session_id : str , summary : str ) -> None Persist a summary for a session. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 124 125 126 127 128 129 def save_summary ( self , session_id : str , summary : str ) -> None : \"\"\"Persist a summary for a session.\"\"\" paths = self . _paths ( session_id ) os . makedirs ( paths . session_dir , exist_ok = True ) with open ( paths . summary_path , \"w\" , encoding = \"utf-8\" ) as handle : json . dump ({ \"summary\" : summary , \"updated_at\" : _utc_now ()}, handle , indent = 2 ) tag_session ( session_id : str , tag : str ) -> None Associate a tag with a session ID for quick lookup. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 161 162 163 164 165 def tag_session ( self , session_id : str , tag : str ) -> None : \"\"\"Associate a tag with a session ID for quick lookup.\"\"\" index = self . _load_index () index . setdefault ( \"tags\" , {})[ tag ] = session_id self . _save_index ( index ) unarchive_session ( session_id : str ) -> None Remove archived status from a session. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 184 185 186 187 188 189 190 191 def unarchive_session ( self , session_id : str ) -> None : \"\"\"Remove archived status from a session.\"\"\" index = self . _load_index () archived = index . get ( \"archived\" , {}) if session_id in archived : archived . pop ( session_id , None ) index [ \"archived\" ] = archived self . _save_index ( index ) meeseeks_core.task_master Task planning and orchestration loop for Meeseeks. generate_action_plan ( user_query : str , model_name : str | None = None , tool_registry : ToolRegistry | None = None , session_summary : str | None = None , recent_events : list [ EventRecord ] | None = None , selected_events : list [ EventRecord ] | None = None , * , mode : str = 'act' ) -> Plan Generate a plan for a user query. Source code in packages/meeseeks_core/src/meeseeks_core/task_master.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 def generate_action_plan ( user_query : str , model_name : str | None = None , tool_registry : ToolRegistry | None = None , session_summary : str | None = None , recent_events : list [ EventRecord ] | None = None , selected_events : list [ EventRecord ] | None = None , * , mode : str = \"act\" , ) -> Plan : \"\"\"Generate a plan for a user query.\"\"\" tool_registry = tool_registry or load_registry () resolved_model = cast ( str , model_name or get_config_value ( \"llm\" , \"action_plan_model\" ) or get_config_value ( \"llm\" , \"default_model\" , default = \"gpt-5.2\" ), ) context = _build_context_snapshot ( session_summary , recent_events , selected_events , resolved_model , ) return Planner ( tool_registry ) . generate ( user_query , resolved_model , context = context , mode = mode ) orchestrate_session ( user_query : str , model_name : str | None = None , max_iters : int = 3 , initial_plan : Plan | None = None , return_state : bool = False , session_id : str | None = None , session_store : SessionStore | None = None , tool_registry : ToolRegistry | None = None , permission_policy : PermissionPolicy | None = None , approval_callback : Callable [[ ActionStep ], bool ] | None = None , hook_manager : HookManager | None = None , mode : str | None = None , should_cancel : Callable [[], bool ] | None = None ) -> TaskQueue | tuple [ TaskQueue , OrchestrationState ] Run the plan-act-observe orchestration loop. Source code in packages/meeseeks_core/src/meeseeks_core/task_master.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 def orchestrate_session ( user_query : str , model_name : str | None = None , max_iters : int = 3 , initial_plan : Plan | None = None , return_state : bool = False , session_id : str | None = None , session_store : SessionStore | None = None , tool_registry : ToolRegistry | None = None , permission_policy : PermissionPolicy | None = None , approval_callback : Callable [[ ActionStep ], bool ] | None = None , hook_manager : HookManager | None = None , mode : str | None = None , should_cancel : Callable [[], bool ] | None = None , ) -> TaskQueue | tuple [ TaskQueue , OrchestrationState ]: \"\"\"Run the plan-act-observe orchestration loop.\"\"\" return Orchestrator ( model_name = model_name , session_store = session_store , tool_registry = tool_registry , permission_policy = permission_policy , approval_callback = approval_callback , hook_manager = hook_manager , ) . run ( user_query , max_iters = max_iters , initial_plan = initial_plan , return_state = return_state , session_id = session_id , mode = mode , should_cancel = should_cancel , ) run_action_plan ( task_queue : TaskQueue , tool_registry : ToolRegistry | None = None , event_logger : Callable [[ Event ], None ] | None = None , permission_policy : PermissionPolicy | None = None , approval_callback : Callable [[ ActionStep ], bool ] | None = None , hook_manager : HookManager | None = None , model_name : str | None = None , * , mode : str = 'act' ) -> TaskQueue Execute a task queue with permissions and hooks. Source code in packages/meeseeks_core/src/meeseeks_core/task_master.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 def run_action_plan ( task_queue : TaskQueue , tool_registry : ToolRegistry | None = None , event_logger : Callable [[ Event ], None ] | None = None , permission_policy : PermissionPolicy | None = None , approval_callback : Callable [[ ActionStep ], bool ] | None = None , hook_manager : HookManager | None = None , model_name : str | None = None , * , mode : str = \"act\" , ) -> TaskQueue : \"\"\"Execute a task queue with permissions and hooks.\"\"\" tool_registry = tool_registry or load_registry () permission_policy = permission_policy or load_permission_policy () approval_callback = approval_callback or approval_callback_from_config () hook_manager = hook_manager or default_hook_manager () runner = ActionPlanRunner ( tool_registry = tool_registry , permission_policy = permission_policy , approval_callback = approval_callback , hook_manager = hook_manager , event_logger = event_logger , reflector = StepReflector ( model_name ), mode = mode , ) return runner . run ( task_queue ) meeseeks_core.token_budget Token budgeting utilities. TokenBudget dataclass Token accounting snapshot used to decide compaction. Source code in packages/meeseeks_core/src/meeseeks_core/token_budget.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @dataclass ( frozen = True ) class TokenBudget : \"\"\"Token accounting snapshot used to decide compaction.\"\"\" total_tokens : int summary_tokens : int event_tokens : int context_window : int remaining_tokens : int utilization : float threshold : float @property def needs_compact ( self ) -> bool : \"\"\"Return True when utilization exceeds the configured threshold.\"\"\" return self . utilization >= self . threshold needs_compact : bool property Return True when utilization exceeds the configured threshold. estimate_event_tokens ( events : Iterable [ EventRecord ]) -> int Estimate total tokens for a sequence of events. Source code in packages/meeseeks_core/src/meeseeks_core/token_budget.py 84 85 86 87 88 89 90 def estimate_event_tokens ( events : Iterable [ EventRecord ]) -> int : \"\"\"Estimate total tokens for a sequence of events.\"\"\" texts = [ _event_to_text ( event ) for event in events ] joined = \" \\n \" . join ( text for text in texts if text ) if not joined : return 0 return num_tokens_from_string ( joined ) estimate_summary_tokens ( summary : str | None ) -> int Estimate token usage for the stored summary. Source code in packages/meeseeks_core/src/meeseeks_core/token_budget.py 93 94 95 96 97 def estimate_summary_tokens ( summary : str | None ) -> int : \"\"\"Estimate token usage for the stored summary.\"\"\" if not summary : return 0 return num_tokens_from_string ( summary ) get_context_window ( model_name : str | None ) -> int Resolve the context window for a model name or default. Source code in packages/meeseeks_core/src/meeseeks_core/token_budget.py 58 59 60 61 62 63 64 65 66 67 68 69 def get_context_window ( model_name : str | None ) -> int : \"\"\"Resolve the context window for a model name or default.\"\"\" default_window = int ( get_config_value ( \"token_budget\" , \"default_context_window\" , default = 128000 )) if not model_name : return default_window overrides = _load_context_overrides () if model_name in overrides : return overrides [ model_name ] parsed = _parse_context_from_model ( model_name ) if parsed : return parsed return default_window get_token_budget ( events : Iterable [ EventRecord ], summary : str | None , model_name : str | None , threshold : float | None = None ) -> TokenBudget Calculate token utilization and remaining context budget. Source code in packages/meeseeks_core/src/meeseeks_core/token_budget.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 def get_token_budget ( events : Iterable [ EventRecord ], summary : str | None , model_name : str | None , threshold : float | None = None , ) -> TokenBudget : \"\"\"Calculate token utilization and remaining context budget.\"\"\" event_tokens = estimate_event_tokens ( events ) summary_tokens = estimate_summary_tokens ( summary ) total_tokens = event_tokens + summary_tokens context_window = get_context_window ( model_name ) remaining_tokens = max ( context_window - total_tokens , 0 ) if threshold is None : threshold = float ( get_config_value ( \"token_budget\" , \"auto_compact_threshold\" , default = 0.8 )) utilization = total_tokens / context_window if context_window else 0.0 return TokenBudget ( total_tokens = total_tokens , summary_tokens = summary_tokens , event_tokens = event_tokens , context_window = context_window , remaining_tokens = remaining_tokens , utilization = utilization , threshold = threshold , ) meeseeks_core.tool_registry Tool registry and manifest loading for Meeseeks. ToolRegistry Registry of configured tools and their instantiated runners. Source code in packages/meeseeks_core/src/meeseeks_core/tool_registry.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 class ToolRegistry : \"\"\"Registry of configured tools and their instantiated runners.\"\"\" def __init__ ( self ) -> None : \"\"\"Initialize an empty registry.\"\"\" self . _tools : dict [ str , ToolSpec ] = {} self . _instances : dict [ str , ToolRunner ] = {} def disable ( self , tool_id : str , reason : str ) -> None : \"\"\"Disable a tool and store a reason for later reporting.\"\"\" spec = self . _tools . get ( tool_id ) if spec is None : return metadata = dict ( spec . metadata ) metadata [ \"disabled_reason\" ] = reason self . _tools [ tool_id ] = ToolSpec ( tool_id = spec . tool_id , name = spec . name , description = spec . description , factory = spec . factory , enabled = False , kind = spec . kind , prompt_path = spec . prompt_path , metadata = metadata , ) if tool_id in self . _instances : self . _instances . pop ( tool_id , None ) set_available_tools ( [ current_id for current_id , current_spec in self . _tools . items () if current_spec . enabled ] ) def register ( self , spec : ToolSpec ) -> None : \"\"\"Register a tool specification and update action validation.\"\"\" self . _tools [ spec . tool_id ] = spec set_available_tools ( [ tool_id for tool_id , tool_spec in self . _tools . items () if tool_spec . enabled ] ) def get ( self , tool_id : str ) -> ToolRunner | None : \"\"\"Return an enabled tool runner, instantiating it if needed.\"\"\" spec = self . _tools . get ( tool_id ) if spec is None or not spec . enabled : return None if tool_id not in self . _instances : try : self . _instances [ tool_id ] = spec . factory () except Exception as exc : # pragma: no cover - defensive reason = f \"Initialization failed: { exc } \" logging . warning ( \"Disabling tool {} : {} \" , tool_id , reason ) self . disable ( tool_id , reason ) return None return self . _instances [ tool_id ] def get_spec ( self , tool_id : str ) -> ToolSpec | None : \"\"\"Return the tool specification, even if disabled.\"\"\" return self . _tools . get ( tool_id ) def list_specs ( self , include_disabled : bool = False ) -> list [ ToolSpec ]: \"\"\"List tool specifications, optionally including disabled tools.\"\"\" specs = list ( self . _tools . values ()) if include_disabled : return specs return [ spec for spec in specs if spec . enabled ] def list_specs_for_mode ( self , mode : str , * , include_disabled : bool = False ) -> list [ ToolSpec ]: \"\"\"List specs filtered by orchestration mode.\"\"\" specs = self . list_specs ( include_disabled = include_disabled ) if mode != \"plan\" : return specs return [ spec for spec in specs if spec . is_plan_safe ()] def tool_catalog ( self ) -> list [ dict [ str , str ]]: \"\"\"Return a serialized catalog of registered tool metadata.\"\"\" return [ { \"tool_id\" : spec . tool_id , \"name\" : spec . name , \"description\" : spec . description , } for spec in self . list_specs () ] __init__ () -> None Initialize an empty registry. Source code in packages/meeseeks_core/src/meeseeks_core/tool_registry.py 65 66 67 68 def __init__ ( self ) -> None : \"\"\"Initialize an empty registry.\"\"\" self . _tools : dict [ str , ToolSpec ] = {} self . _instances : dict [ str , ToolRunner ] = {} disable ( tool_id : str , reason : str ) -> None Disable a tool and store a reason for later reporting. Source code in packages/meeseeks_core/src/meeseeks_core/tool_registry.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 def disable ( self , tool_id : str , reason : str ) -> None : \"\"\"Disable a tool and store a reason for later reporting.\"\"\" spec = self . _tools . get ( tool_id ) if spec is None : return metadata = dict ( spec . metadata ) metadata [ \"disabled_reason\" ] = reason self . _tools [ tool_id ] = ToolSpec ( tool_id = spec . tool_id , name = spec . name , description = spec . description , factory = spec . factory , enabled = False , kind = spec . kind , prompt_path = spec . prompt_path , metadata = metadata , ) if tool_id in self . _instances : self . _instances . pop ( tool_id , None ) set_available_tools ( [ current_id for current_id , current_spec in self . _tools . items () if current_spec . enabled ] ) get ( tool_id : str ) -> ToolRunner | None Return an enabled tool runner, instantiating it if needed. Source code in packages/meeseeks_core/src/meeseeks_core/tool_registry.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 def get ( self , tool_id : str ) -> ToolRunner | None : \"\"\"Return an enabled tool runner, instantiating it if needed.\"\"\" spec = self . _tools . get ( tool_id ) if spec is None or not spec . enabled : return None if tool_id not in self . _instances : try : self . _instances [ tool_id ] = spec . factory () except Exception as exc : # pragma: no cover - defensive reason = f \"Initialization failed: { exc } \" logging . warning ( \"Disabling tool {} : {} \" , tool_id , reason ) self . disable ( tool_id , reason ) return None return self . _instances [ tool_id ] get_spec ( tool_id : str ) -> ToolSpec | None Return the tool specification, even if disabled. Source code in packages/meeseeks_core/src/meeseeks_core/tool_registry.py 115 116 117 def get_spec ( self , tool_id : str ) -> ToolSpec | None : \"\"\"Return the tool specification, even if disabled.\"\"\" return self . _tools . get ( tool_id ) list_specs ( include_disabled : bool = False ) -> list [ ToolSpec ] List tool specifications, optionally including disabled tools. Source code in packages/meeseeks_core/src/meeseeks_core/tool_registry.py 119 120 121 122 123 124 def list_specs ( self , include_disabled : bool = False ) -> list [ ToolSpec ]: \"\"\"List tool specifications, optionally including disabled tools.\"\"\" specs = list ( self . _tools . values ()) if include_disabled : return specs return [ spec for spec in specs if spec . enabled ] list_specs_for_mode ( mode : str , * , include_disabled : bool = False ) -> list [ ToolSpec ] List specs filtered by orchestration mode. Source code in packages/meeseeks_core/src/meeseeks_core/tool_registry.py 126 127 128 129 130 131 def list_specs_for_mode ( self , mode : str , * , include_disabled : bool = False ) -> list [ ToolSpec ]: \"\"\"List specs filtered by orchestration mode.\"\"\" specs = self . list_specs ( include_disabled = include_disabled ) if mode != \"plan\" : return specs return [ spec for spec in specs if spec . is_plan_safe ()] register ( spec : ToolSpec ) -> None Register a tool specification and update action validation. Source code in packages/meeseeks_core/src/meeseeks_core/tool_registry.py 93 94 95 96 97 98 def register ( self , spec : ToolSpec ) -> None : \"\"\"Register a tool specification and update action validation.\"\"\" self . _tools [ spec . tool_id ] = spec set_available_tools ( [ tool_id for tool_id , tool_spec in self . _tools . items () if tool_spec . enabled ] ) tool_catalog () -> list [ dict [ str , str ]] Return a serialized catalog of registered tool metadata. Source code in packages/meeseeks_core/src/meeseeks_core/tool_registry.py 133 134 135 136 137 138 139 140 141 142 def tool_catalog ( self ) -> list [ dict [ str , str ]]: \"\"\"Return a serialized catalog of registered tool metadata.\"\"\" return [ { \"tool_id\" : spec . tool_id , \"name\" : spec . name , \"description\" : spec . description , } for spec in self . list_specs () ] ToolRunner Bases: Protocol Source code in packages/meeseeks_core/src/meeseeks_core/tool_registry.py 32 33 34 35 36 37 38 39 40 41 class ToolRunner ( Protocol ): def run ( self , action_step : ActionStep ) -> MockSpeaker : # pragma: no cover \"\"\"Execute an action step and return a speaker response. Args: action_step: Action step payload to execute. Returns: MockSpeaker response from the tool. \"\"\" run ( action_step : ActionStep ) -> MockSpeaker Execute an action step and return a speaker response. Parameters: Name Type Description Default action_step ActionStep Action step payload to execute. required Returns: Type Description MockSpeaker MockSpeaker response from the tool. Source code in packages/meeseeks_core/src/meeseeks_core/tool_registry.py 33 34 35 36 37 38 39 40 41 def run ( self , action_step : ActionStep ) -> MockSpeaker : # pragma: no cover \"\"\"Execute an action step and return a speaker response. Args: action_step: Action step payload to execute. Returns: MockSpeaker response from the tool. \"\"\" ToolSpec dataclass Metadata describing a tool available to the assistant. Source code in packages/meeseeks_core/src/meeseeks_core/tool_registry.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 @dataclass ( frozen = True ) class ToolSpec : \"\"\"Metadata describing a tool available to the assistant.\"\"\" tool_id : str name : str description : str factory : Callable [[], ToolRunner ] enabled : bool = True kind : str = \"local\" prompt_path : str | None = None metadata : dict [ str , JsonValue ] = field ( default_factory = dict ) def is_plan_safe ( self ) -> bool : \"\"\"Return True if the tool is safe to use in plan mode.\"\"\" return bool ( self . metadata . get ( \"plan_safe\" )) is_plan_safe () -> bool Return True if the tool is safe to use in plan mode. Source code in packages/meeseeks_core/src/meeseeks_core/tool_registry.py 57 58 59 def is_plan_safe ( self ) -> bool : \"\"\"Return True if the tool is safe to use in plan mode.\"\"\" return bool ( self . metadata . get ( \"plan_safe\" )) load_registry ( manifest_path : str | None = None ) -> ToolRegistry Load tool registry, auto-discovering MCP tools when configured. Source code in packages/meeseeks_core/src/meeseeks_core/tool_registry.py 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 def load_registry ( manifest_path : str | None = None ) -> ToolRegistry : \"\"\"Load tool registry, auto-discovering MCP tools when configured.\"\"\" if manifest_path is None : mcp_config_path = get_mcp_config_path () if mcp_config_path and os . path . exists ( mcp_config_path ): manifest_path = _ensure_auto_manifest ( mcp_config_path ) if not manifest_path : return _default_registry () manifest_path = os . path . abspath ( manifest_path ) if not os . path . exists ( manifest_path ): logging . warning ( \"Tool manifest not found: {} \" , manifest_path ) return _default_registry () try : with open ( manifest_path , encoding = \"utf-8\" ) as handle : manifest = json . load ( handle ) except Exception as exc : # pragma: no cover - defensive logging . error ( \"Failed to load tool manifest: {} \" , exc ) return _default_registry () registry = ToolRegistry () for tool in manifest . get ( \"tools\" , []): kind = tool . get ( \"kind\" , \"local\" ) prompt_path = tool . get ( \"prompt\" ) if kind == \"local\" : module_path = tool . get ( \"module\" ) class_name = tool . get ( \"class\" ) if not module_path or not class_name : logging . warning ( \"Skipping tool with missing module/class: {} \" , tool ) continue factory = _import_factory ( module_path , class_name ) else : mcp_module = _load_mcp_support () if mcp_module is None : logging . warning ( \"Skipping MCP tool because MCP support is not installed: {} \" , tool , ) continue MCPToolRunner = mcp_module . MCPToolRunner server_name = tool . get ( \"server\" ) tool_name = tool . get ( \"tool\" ) if not server_name or not tool_name : logging . warning ( \"Skipping MCP tool with missing server/tool: {} \" , tool ) continue def _mcp_factory ( server_name : str = server_name , tool_name : str = tool_name , ) -> ToolRunner : return MCPToolRunner ( server_name = server_name , tool_name = tool_name ) factory = _mcp_factory spec = ToolSpec ( tool_id = tool . get ( \"tool_id\" , \"\" ), name = tool . get ( \"name\" , tool . get ( \"tool_id\" , \"\" )), description = tool . get ( \"description\" , \"\" ), factory = factory , enabled = tool . get ( \"enabled\" , True ), kind = kind , prompt_path = prompt_path , metadata = { key : value for key , value in tool . items () if key not in { \"tool_id\" , \"name\" , \"description\" , \"module\" , \"class\" , \"enabled\" , \"kind\" , \"prompt\" , } }, ) if not spec . tool_id : logging . warning ( \"Skipping tool with empty tool_id: {} \" , tool ) continue registry . register ( spec ) if not registry . list_specs ( include_disabled = True ): return _default_registry () builtin_registry = _default_registry () existing_ids = { spec . tool_id for spec in registry . list_specs ( include_disabled = True )} for spec in builtin_registry . list_specs ( include_disabled = True ): if spec . tool_id in existing_ids : continue registry . register ( spec ) existing_ids . add ( spec . tool_id ) set_available_tools ([ spec . tool_id for spec in registry . list_specs ()]) return registry meeseeks_core.types Shared type definitions for core components. ActionPlanPayload Bases: TypedDict Payload describing an action plan. Source code in packages/meeseeks_core/src/meeseeks_core/types.py 21 22 23 24 class ActionPlanPayload ( TypedDict ): \"\"\"Payload describing an action plan.\"\"\" steps : list [ PlanStepPayload ] ActionStepPayload Bases: TypedDict Serialized tool call data sent to/from execution. Source code in packages/meeseeks_core/src/meeseeks_core/types.py 27 28 29 30 31 32 33 34 35 36 class ActionStepPayload ( TypedDict ): \"\"\"Serialized tool call data sent to/from execution.\"\"\" tool_id : str operation : str tool_input : ToolInput title : NotRequired [ str ] objective : NotRequired [ str ] execution_checklist : NotRequired [ list [ str ]] expected_output : NotRequired [ str ] AssistantPayload Bases: TypedDict Payload describing an assistant response. Source code in packages/meeseeks_core/src/meeseeks_core/types.py 66 67 68 69 class AssistantPayload ( TypedDict ): \"\"\"Payload describing an assistant response.\"\"\" text : str CompletionPayload Bases: TypedDict Payload describing overall completion state. Source code in packages/meeseeks_core/src/meeseeks_core/types.py 72 73 74 75 76 77 78 79 class CompletionPayload ( TypedDict ): \"\"\"Payload describing overall completion state.\"\"\" done : bool done_reason : str | None task_result : str | None error : NotRequired [ str ] last_error : NotRequired [ str ] Event Bases: TypedDict Base event payload stored in transcripts. Source code in packages/meeseeks_core/src/meeseeks_core/types.py 93 94 95 96 97 class Event ( TypedDict ): \"\"\"Base event payload stored in transcripts.\"\"\" type : str payload : EventPayload EventRecord Bases: Event Event payload with a persisted timestamp. Source code in packages/meeseeks_core/src/meeseeks_core/types.py 100 101 102 103 class EventRecord ( Event ): \"\"\"Event payload with a persisted timestamp.\"\"\" ts : str PermissionPayload Bases: TypedDict Payload emitted for permission decisions. Source code in packages/meeseeks_core/src/meeseeks_core/types.py 39 40 41 42 43 44 45 class PermissionPayload ( TypedDict ): \"\"\"Payload emitted for permission decisions.\"\"\" tool_id : str operation : str tool_input : str decision : str PlanStepPayload Bases: TypedDict Payload describing a single plan step. Source code in packages/meeseeks_core/src/meeseeks_core/types.py 14 15 16 17 18 class PlanStepPayload ( TypedDict ): \"\"\"Payload describing a single plan step.\"\"\" title : str description : str ToolResultPayload Bases: TypedDict Payload describing the outcome of a tool invocation. Source code in packages/meeseeks_core/src/meeseeks_core/types.py 48 49 50 51 52 53 54 55 56 57 class ToolResultPayload ( TypedDict ): \"\"\"Payload describing the outcome of a tool invocation.\"\"\" tool_id : str operation : str tool_input : ToolInput result : str | None success : NotRequired [ bool ] summary : NotRequired [ str ] error : NotRequired [ str ] UserPayload Bases: TypedDict Payload describing a user message. Source code in packages/meeseeks_core/src/meeseeks_core/types.py 60 61 62 63 class UserPayload ( TypedDict ): \"\"\"Payload describing a user message.\"\"\" text : str Tools meeseeks_tools.integration.homeassistant Home Assistant integration tools and data models. CacheHolder Bases: Protocol Protocol describing objects with a Home Assistant cache attribute. Attributes: Name Type Description cache HomeAssistantCache Home Assistant cache payload. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 45 46 47 48 49 50 51 52 53 @runtime_checkable class CacheHolder ( Protocol ): \"\"\"Protocol describing objects with a Home Assistant cache attribute. Attributes: cache: Home Assistant cache payload. \"\"\" cache : HomeAssistantCache HomeAssistant Bases: AbstractTool A service to manage and interact with Home Assistant. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 class HomeAssistant ( AbstractTool ): \"\"\"A service to manage and interact with Home Assistant.\"\"\" def __init__ ( self ) -> None : \"\"\"Initialize the Home Assistant tool with environment defaults.\"\"\" super () . __init__ ( name = \"Home Assistant\" , description = \"A service to manage and interact with Home Assistant\" , ) self . base_url = get_config_value ( \"home_assistant\" , \"url\" ) self . _api_token = get_config_value ( \"home_assistant\" , \"token\" ) self . cache : HomeAssistantCache = { \"entity_ids\" : [], \"sensor_ids\" : [], \"entities\" : [], \"services\" : [], \"sensors\" : [], \"allowed_domains\" : [ \"scene\" , \"switch\" , \"weather\" , \"kodi\" , \"automation\" ], } if not self . base_url or not self . _api_token : raise ValueError ( \"home_assistant.url and home_assistant.token must be set.\" ) self . api_headers : dict [ str , str ] = { \"Authorization\" : f \"Bearer { self . _api_token } \" , \"Content-Type\" : \"application/json\" , } @cache_monitor def update_services ( self ) -> bool : \"\"\"Update the list of services from Home Assistant. Returns: True when services are fetched successfully. \"\"\" url = f \" { self . base_url } /services\" try : response = requests . get ( url , headers = self . api_headers , timeout = 30 ) status_code = getattr ( response , \"status_code\" , None ) if status_code in { 401 , 403 }: logging . error ( \"Home Assistant authorization failed with status {} .\" , status_code ) raise PermissionError ( \"Home Assistant authorization failed.\" ) response . raise_for_status () self . cache [ \"services\" ] = response . json () self . _save_json ( self . cache [ \"services\" ], \"services.json\" ) return True except requests . exceptions . RequestException as e : logging . error ( \"Error: {} \" , e ) return False @cache_monitor def update_entities ( self ) -> bool : \"\"\"Update the list of entities from Home Assistant. Returns: True when entities are fetched successfully. \"\"\" url = f \" { self . base_url } /states\" try : response = requests . get ( url , headers = self . api_headers , timeout = 30 ) status_code = getattr ( response , \"status_code\" , None ) if status_code in { 401 , 403 }: logging . error ( \"Home Assistant authorization failed with status {} .\" , status_code ) raise PermissionError ( \"Home Assistant authorization failed.\" ) response . raise_for_status () self . cache [ \"entities\" ] = response . json () return True except requests . exceptions . RequestException as e : logging . error ( \"Error: {} \" , e ) return False @cache_monitor def update_entity_ids ( self ) -> bool : \"\"\"Update the list of entity IDs from Home Assistant. Returns: True when entity IDs are populated. Raises: ValueError: If no entities are available for ID extraction. \"\"\" # TODO: Always assumes blacklist by default due to cache_monitor. self . update_entities () entities = self . cache [ \"entities\" ] if not entities : raise ValueError ( \"No entities found while updating entity IDs.\" ) self . cache [ \"entity_ids\" ] = [ entity [ \"entity_id\" ] for entity in entities ] logging . info ( \"Entity IDs updated.\" ) return True @cache_monitor def update_cache ( self ) -> None : \"\"\"Update the entire cache. Raises: ValueError: If entity IDs cannot be derived. \"\"\" self . update_entity_ids () self . update_services () self . _save_json ( self . cache [ \"entities\" ], \"entities.json\" ) self . _save_json ( self . cache [ \"sensors\" ], \"sensors.json\" ) def call_service ( self , domain : str , service : str , entity_id : str , data : dict | None = None , ) -> tuple [ bool , list [ dict [ str , Any ]]]: \"\"\"Call a service in Home Assistant. Args: domain: Home Assistant domain name (e.g., \"light\"). service: Service name within the domain (e.g., \"turn_on\"). entity_id: Entity ID to target. data: Optional extra payload for the service call. Returns: Tuple of success flag and JSON response payload. Raises: ValueError: If the domain is not allowed. \"\"\" if domain not in self . cache [ \"allowed_domains\" ]: raise ValueError ( f \"Domain does not exist or blacklisted: { domain } \" ) url = f \" { self . base_url } /services/ { domain } / { service } \" payload = { \"entity_id\" : entity_id } if data : payload . update ( data ) try : response = requests . post ( url , headers = self . api_headers , json = payload , timeout = 30 ) status_code = getattr ( response , \"status_code\" , None ) if status_code in { 401 , 403 }: logging . error ( \"Home Assistant authorization failed with status {} .\" , status_code ) raise PermissionError ( \"Home Assistant authorization failed.\" ) response . raise_for_status () logging . info ( \"Service < {} . {} > called on entity < {} > returned ` {} `.\" , domain , service , entity_id , response . text , ) return True , response . json () except requests . exceptions . RequestException as e : logging . error ( \"Unable to call service < {} . {} > on entity < {} >: {} \" , domain , service , entity_id , e ) return False , [] @staticmethod def _create_set_prompt ( system_prompt : str , parser : PydanticOutputParser , ) -> ChatPromptTemplate : \"\"\"Create the prompt template for a set-state operation. Args: system_prompt: System prompt content. parser: Pydantic output parser for HomeAssistantCall. Returns: ChatPromptTemplate configured for set-state tasks. \"\"\" example = HomeAssistantCall ( domain = \"scene\" , service = \"turn_on\" , entity_id = \"scene.lamp_power_on\" ) prompt = ChatPromptTemplate ( messages = [ SystemMessage ( content = system_prompt ), HumanMessage ( content = \"Turn on the lamp lights.\" ), AIMessage ( content = example . json ()), HumanMessagePromptTemplate . from_template ( \"The user asked you to ` {action_step} `. You must use the information \" \"provided to pick the right Home Assistant service call values only \" \"considering the current user query. \\n\\n \" \"## Format Instructions \\n {format_instructions} \\n\\n \" \"## Home Assistant Entities and Domain-Services \\n ``` \\n {context} ``` \\n \" ), ], partial_variables = { \"format_instructions\" : parser . get_format_instructions ()}, input_variables = [ \"action_step\" ], ) return prompt @staticmethod def _create_get_prompt ( system_prompt : str ) -> ChatPromptTemplate : \"\"\"Create the prompt template for a get-state operation. Args: system_prompt: System prompt content. Returns: ChatPromptTemplate configured for get-state tasks. \"\"\" prompt = ChatPromptTemplate ( messages = [ SystemMessage ( content = system_prompt ), HumanMessage ( content = \"How is the air quality today?\" ), AIMessage ( content = ( \"AccuWeather reported today's air quality in your home as good. \" \"This level of air quality ensures that the environment is healthy, \" \"supporting your daily activities and wellbeing without any air \" \"quality-related risks.\" ) ), HumanMessagePromptTemplate . from_template ( \"The user asked you to ` {action_step} `. You must use the sensor \" \"information to answer the user's query. Keep your answer \" \"analytical, brief and useful. \\n\\n \" \"## Home Assistant Sensors \\n ``` \\n {context} ``` \\n \" ), ], input_variables = [ \"action_step\" ], ) return prompt @staticmethod def _clean_answer ( answer : str ) -> str : \"\"\"Clean the answer by removing/replacing characters. Args: answer: Raw answer string to normalize. Returns: Cleaned answer string. \"\"\" replacements = { # Common entities \"RealFeel\" : \"Real Feel\" , # Confident Abbreviations \"km/h\" : \" kilometer per hour\" , \"\u00b0C\" : \" degrees celsius\" , \"%\" : \" percent\" , \"mm/h\" : \" millimeter per hour\" , \"Gb/s\" : \" gigabits per second\" , \"Mb/s\" : \" megabits per second\" , \"Kb/s\" : \" kilobits per second\" , \"GHz\" : \"Gigahertz\" , # Formatting '\"' : \"\" , } # Replace using the dictionary for old , new in replacements . items (): answer = answer . replace ( old , new ) # Remove extra spaces and new lines, condense all multiple spaces # to a single space answer = re . sub ( r \"\\s+\" , \" \" , answer ) . strip () return answer def _invoke_service_and_set_state ( self , chain : SupportsInvoke , rag_documents : list [ Document ], action_step : ActionStep , ) -> MockSpeaker : \"\"\"Invoke the service and set the state. Args: chain: Runnable chain that yields HomeAssistantCall. rag_documents: Context documents for the chain. action_step: Action step describing the request. Returns: MockSpeaker with a status message. \"\"\" MockSpeaker = get_mock_speaker () try : action_step_curr = str ( action_step . tool_input ) . strip () call_service_values = chain . invoke ( { \"action_step\" : action_step_curr , \"context\" : rag_documents , \"cache\" : self . cache }, ) logging . debug ( \"Call Service Values for ` {} `: ` {} `\" , action_step_curr , call_service_values ) status_bool , response_json = self . call_service ( domain = call_service_values . domain , service = call_service_values . service , entity_id = call_service_values . entity_id , ) if status_bool : tmp_return_message = f \"Successfully called service: ` { response_json } `\" else : tmp_return_message = f \"Failed to call service: ` { response_json } `\" except Exception as err_mesaage : logging . error ( \"Error: {} \" , err_mesaage ) tmp_return_message = f \"I received an error - ` { err_mesaage } `\" return MockSpeaker ( content = tmp_return_message ) def set_state ( self , action_step : ActionStep | None = None ) -> MockSpeaker : \"\"\"Predict and call a service for a given action step. Args: action_step: Action step describing the desired change. Returns: MockSpeaker with a status message. Raises: ValueError: If action_step is None. \"\"\" if action_step is None : raise ValueError ( \"Action step cannot be None.\" ) self . update_cache () rag_documents = self . _load_rag_documents ([ \"entities.json\" , \"services.json\" ]) system_prompt = ha_render_system_prompt ( name = \"homeassistant-set-state\" , all_entities = self . cache [ \"entity_ids\" ] ) parser = PydanticOutputParser ( pydantic_object = HomeAssistantCall ) # type: ignore[type-var] prompt = self . _create_set_prompt ( system_prompt , parser ) if self . model is None : raise RuntimeError ( \"LLM client not initialized for Home Assistant.\" ) model = self . model chain : Any = prompt | model | parser logging . info ( \"Invoking `set` action chain using ` {} ` for ` {} `.\" , self . model_name , action_step ) # TODO: Interpret the response from call service. return self . _invoke_service_and_set_state ( chain , rag_documents , action_step ) def get_state ( self , action_step : ActionStep | None = None ) -> MockSpeaker : \"\"\"Generate response for a given action step based on sensors. Args: action_step: Action step describing the desired query. Returns: MockSpeaker with the generated response. Raises: ValueError: If action_step is None. \"\"\" if action_step is None : raise ValueError ( \"Action step cannot be None.\" ) self . update_cache () rag_documents = self . _load_rag_documents ([ \"sensors.json\" ]) system_prompt = ha_render_system_prompt ( name = \"homeassistant-get-state\" ) prompt = self . _create_get_prompt ( system_prompt ) if self . model is None : raise RuntimeError ( \"LLM client not initialized for Home Assistant.\" ) model = self . model chain : Any = prompt | model logging . info ( \"Invoking `get` action chain using ` {} `.\" , self . model_name ) message = chain . invoke ( { \"action_step\" : str ( action_step . tool_input ) . strip (), \"context\" : rag_documents , }, ) cleaned_message = self . _clean_answer ( str ( message . content )) MockSpeaker = get_mock_speaker () return MockSpeaker ( content = cleaned_message ) __init__ () -> None Initialize the Home Assistant tool with environment defaults. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 def __init__ ( self ) -> None : \"\"\"Initialize the Home Assistant tool with environment defaults.\"\"\" super () . __init__ ( name = \"Home Assistant\" , description = \"A service to manage and interact with Home Assistant\" , ) self . base_url = get_config_value ( \"home_assistant\" , \"url\" ) self . _api_token = get_config_value ( \"home_assistant\" , \"token\" ) self . cache : HomeAssistantCache = { \"entity_ids\" : [], \"sensor_ids\" : [], \"entities\" : [], \"services\" : [], \"sensors\" : [], \"allowed_domains\" : [ \"scene\" , \"switch\" , \"weather\" , \"kodi\" , \"automation\" ], } if not self . base_url or not self . _api_token : raise ValueError ( \"home_assistant.url and home_assistant.token must be set.\" ) self . api_headers : dict [ str , str ] = { \"Authorization\" : f \"Bearer { self . _api_token } \" , \"Content-Type\" : \"application/json\" , } call_service ( domain : str , service : str , entity_id : str , data : dict | None = None ) -> tuple [ bool , list [ dict [ str , Any ]]] Call a service in Home Assistant. Parameters: Name Type Description Default domain str Home Assistant domain name (e.g., \"light\"). required service str Service name within the domain (e.g., \"turn_on\"). required entity_id str Entity ID to target. required data dict | None Optional extra payload for the service call. None Returns: Type Description tuple [ bool , list [ dict [ str , Any ]]] Tuple of success flag and JSON response payload. Raises: Type Description ValueError If the domain is not allowed. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 def call_service ( self , domain : str , service : str , entity_id : str , data : dict | None = None , ) -> tuple [ bool , list [ dict [ str , Any ]]]: \"\"\"Call a service in Home Assistant. Args: domain: Home Assistant domain name (e.g., \"light\"). service: Service name within the domain (e.g., \"turn_on\"). entity_id: Entity ID to target. data: Optional extra payload for the service call. Returns: Tuple of success flag and JSON response payload. Raises: ValueError: If the domain is not allowed. \"\"\" if domain not in self . cache [ \"allowed_domains\" ]: raise ValueError ( f \"Domain does not exist or blacklisted: { domain } \" ) url = f \" { self . base_url } /services/ { domain } / { service } \" payload = { \"entity_id\" : entity_id } if data : payload . update ( data ) try : response = requests . post ( url , headers = self . api_headers , json = payload , timeout = 30 ) status_code = getattr ( response , \"status_code\" , None ) if status_code in { 401 , 403 }: logging . error ( \"Home Assistant authorization failed with status {} .\" , status_code ) raise PermissionError ( \"Home Assistant authorization failed.\" ) response . raise_for_status () logging . info ( \"Service < {} . {} > called on entity < {} > returned ` {} `.\" , domain , service , entity_id , response . text , ) return True , response . json () except requests . exceptions . RequestException as e : logging . error ( \"Unable to call service < {} . {} > on entity < {} >: {} \" , domain , service , entity_id , e ) return False , [] get_state ( action_step : ActionStep | None = None ) -> MockSpeaker Generate response for a given action step based on sensors. Parameters: Name Type Description Default action_step ActionStep | None Action step describing the desired query. None Returns: Type Description MockSpeaker MockSpeaker with the generated response. Raises: Type Description ValueError If action_step is None. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 def get_state ( self , action_step : ActionStep | None = None ) -> MockSpeaker : \"\"\"Generate response for a given action step based on sensors. Args: action_step: Action step describing the desired query. Returns: MockSpeaker with the generated response. Raises: ValueError: If action_step is None. \"\"\" if action_step is None : raise ValueError ( \"Action step cannot be None.\" ) self . update_cache () rag_documents = self . _load_rag_documents ([ \"sensors.json\" ]) system_prompt = ha_render_system_prompt ( name = \"homeassistant-get-state\" ) prompt = self . _create_get_prompt ( system_prompt ) if self . model is None : raise RuntimeError ( \"LLM client not initialized for Home Assistant.\" ) model = self . model chain : Any = prompt | model logging . info ( \"Invoking `get` action chain using ` {} `.\" , self . model_name ) message = chain . invoke ( { \"action_step\" : str ( action_step . tool_input ) . strip (), \"context\" : rag_documents , }, ) cleaned_message = self . _clean_answer ( str ( message . content )) MockSpeaker = get_mock_speaker () return MockSpeaker ( content = cleaned_message ) set_state ( action_step : ActionStep | None = None ) -> MockSpeaker Predict and call a service for a given action step. Parameters: Name Type Description Default action_step ActionStep | None Action step describing the desired change. None Returns: Type Description MockSpeaker MockSpeaker with a status message. Raises: Type Description ValueError If action_step is None. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 def set_state ( self , action_step : ActionStep | None = None ) -> MockSpeaker : \"\"\"Predict and call a service for a given action step. Args: action_step: Action step describing the desired change. Returns: MockSpeaker with a status message. Raises: ValueError: If action_step is None. \"\"\" if action_step is None : raise ValueError ( \"Action step cannot be None.\" ) self . update_cache () rag_documents = self . _load_rag_documents ([ \"entities.json\" , \"services.json\" ]) system_prompt = ha_render_system_prompt ( name = \"homeassistant-set-state\" , all_entities = self . cache [ \"entity_ids\" ] ) parser = PydanticOutputParser ( pydantic_object = HomeAssistantCall ) # type: ignore[type-var] prompt = self . _create_set_prompt ( system_prompt , parser ) if self . model is None : raise RuntimeError ( \"LLM client not initialized for Home Assistant.\" ) model = self . model chain : Any = prompt | model | parser logging . info ( \"Invoking `set` action chain using ` {} ` for ` {} `.\" , self . model_name , action_step ) # TODO: Interpret the response from call service. return self . _invoke_service_and_set_state ( chain , rag_documents , action_step ) update_cache () -> None Update the entire cache. Raises: Type Description ValueError If entity IDs cannot be derived. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 380 381 382 383 384 385 386 387 388 389 390 @cache_monitor def update_cache ( self ) -> None : \"\"\"Update the entire cache. Raises: ValueError: If entity IDs cannot be derived. \"\"\" self . update_entity_ids () self . update_services () self . _save_json ( self . cache [ \"entities\" ], \"entities.json\" ) self . _save_json ( self . cache [ \"sensors\" ], \"sensors.json\" ) update_entities () -> bool Update the list of entities from Home Assistant. Returns: Type Description bool True when entities are fetched successfully. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 @cache_monitor def update_entities ( self ) -> bool : \"\"\"Update the list of entities from Home Assistant. Returns: True when entities are fetched successfully. \"\"\" url = f \" { self . base_url } /states\" try : response = requests . get ( url , headers = self . api_headers , timeout = 30 ) status_code = getattr ( response , \"status_code\" , None ) if status_code in { 401 , 403 }: logging . error ( \"Home Assistant authorization failed with status {} .\" , status_code ) raise PermissionError ( \"Home Assistant authorization failed.\" ) response . raise_for_status () self . cache [ \"entities\" ] = response . json () return True except requests . exceptions . RequestException as e : logging . error ( \"Error: {} \" , e ) return False update_entity_ids () -> bool Update the list of entity IDs from Home Assistant. Returns: Type Description bool True when entity IDs are populated. Raises: Type Description ValueError If no entities are available for ID extraction. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 @cache_monitor def update_entity_ids ( self ) -> bool : \"\"\"Update the list of entity IDs from Home Assistant. Returns: True when entity IDs are populated. Raises: ValueError: If no entities are available for ID extraction. \"\"\" # TODO: Always assumes blacklist by default due to cache_monitor. self . update_entities () entities = self . cache [ \"entities\" ] if not entities : raise ValueError ( \"No entities found while updating entity IDs.\" ) self . cache [ \"entity_ids\" ] = [ entity [ \"entity_id\" ] for entity in entities ] logging . info ( \"Entity IDs updated.\" ) return True update_services () -> bool Update the list of services from Home Assistant. Returns: Type Description bool True when services are fetched successfully. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 @cache_monitor def update_services ( self ) -> bool : \"\"\"Update the list of services from Home Assistant. Returns: True when services are fetched successfully. \"\"\" url = f \" { self . base_url } /services\" try : response = requests . get ( url , headers = self . api_headers , timeout = 30 ) status_code = getattr ( response , \"status_code\" , None ) if status_code in { 401 , 403 }: logging . error ( \"Home Assistant authorization failed with status {} .\" , status_code ) raise PermissionError ( \"Home Assistant authorization failed.\" ) response . raise_for_status () self . cache [ \"services\" ] = response . json () self . _save_json ( self . cache [ \"services\" ], \"services.json\" ) return True except requests . exceptions . RequestException as e : logging . error ( \"Error: {} \" , e ) return False HomeAssistantCache Bases: TypedDict Cached Home Assistant entity and service metadata. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 33 34 35 36 37 38 39 40 41 42 class HomeAssistantCache ( TypedDict ): \"\"\"Cached Home Assistant entity and service metadata.\"\"\" entity_ids : list [ str ] sensor_ids : list [ str ] entities : list [ dict [ str , Any ]] services : list [ dict [ str , Any ]] sensors : list [ dict [ str , Any ]] allowed_domains : list [ str ] sensor : NotRequired [ list [ dict [ str , Any ]]] HomeAssistantCall Bases: BaseModel Structured Home Assistant service call extracted from the model output. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 class HomeAssistantCall ( BaseModel ): \"\"\"Structured Home Assistant service call extracted from the model output.\"\"\" cache : CacheHolder | None = Field ( alias = \"_ha_cache\" , default = None ) domain : str = Field ( description = ( \"The category of the service to call, such as 'light', 'switch', or 'scene'.\" ) ) service : str = Field ( description = ( \"The specific action to perform within the domain, such as 'turn_on', \" \"'turn_off', or 'set_temperature'.\" ) ) entity_id : str = Field ( description = ( \"The ID of the specific device or entity within the domain to apply the \" \"service to, such as 'scene.heater'.\" ) ) @validator ( \"entity_id\" , allow_reuse = True ) # pylint: disable=E0213,W0613 def validate_entity_id ( cls , entity_id : str , values : dict [ str , Any ], ** kwargs : Any ) -> str : \"\"\"Validate the entity_id against the cache when available. Args: cls: Pydantic model class. entity_id: Candidate entity identifier. values: Parsed model values. **kwargs: Additional validator arguments. Returns: Validated entity identifier. Raises: ValueError: If the entity ID is not found in the cache. \"\"\" # ! BUG: The entity_id may not be validated correctly as the cache # ! is not passed to the validator. ha_cache = values . get ( \"ha_cache\" ) if ha_cache and entity_id not in ha_cache . cache [ \"entity_ids\" ]: raise ValueError ( f \"Entity ID ' { entity_id } ' is not in the Home Assistant cache.\" ) return entity_id @validator ( \"domain\" , allow_reuse = True ) # pylint: disable=E0213,W0613 def validate_domain ( cls , domain : str , values : dict [ str , Any ], ** kwargs : Any ) -> str : \"\"\"Validate the domain against the cache when available. Args: cls: Pydantic model class. domain: Domain string to validate. values: Parsed model values. **kwargs: Additional validator arguments. Returns: Validated domain string. Raises: ValueError: If the domain is not found in the cache. \"\"\" # ! BUG: The entity_id may not be validated correctly as the cache # ! is not passed to the validator. ha_cache = values . get ( \"ha_cache\" ) if ha_cache and domain not in ha_cache . cache [ \"allowed_domains\" ]: raise ValueError ( f \"Domain ' { domain } ' is not in the Home Assistant cache.\" ) return domain class Config : \"\"\"Pydantic configuration for HomeAssistantCall.\"\"\" arbitrary_types_allowed = True Config Pydantic configuration for HomeAssistantCall. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 284 285 286 287 class Config : \"\"\"Pydantic configuration for HomeAssistantCall.\"\"\" arbitrary_types_allowed = True validate_domain ( domain : str , values : dict [ str , Any ], ** kwargs : Any ) -> str Validate the domain against the cache when available. Parameters: Name Type Description Default cls Pydantic model class. required domain str Domain string to validate. required values dict [ str , Any ] Parsed model values. required **kwargs Any Additional validator arguments. {} Returns: Type Description str Validated domain string. Raises: Type Description ValueError If the domain is not found in the cache. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 @validator ( \"domain\" , allow_reuse = True ) # pylint: disable=E0213,W0613 def validate_domain ( cls , domain : str , values : dict [ str , Any ], ** kwargs : Any ) -> str : \"\"\"Validate the domain against the cache when available. Args: cls: Pydantic model class. domain: Domain string to validate. values: Parsed model values. **kwargs: Additional validator arguments. Returns: Validated domain string. Raises: ValueError: If the domain is not found in the cache. \"\"\" # ! BUG: The entity_id may not be validated correctly as the cache # ! is not passed to the validator. ha_cache = values . get ( \"ha_cache\" ) if ha_cache and domain not in ha_cache . cache [ \"allowed_domains\" ]: raise ValueError ( f \"Domain ' { domain } ' is not in the Home Assistant cache.\" ) return domain validate_entity_id ( entity_id : str , values : dict [ str , Any ], ** kwargs : Any ) -> str Validate the entity_id against the cache when available. Parameters: Name Type Description Default cls Pydantic model class. required entity_id str Candidate entity identifier. required values dict [ str , Any ] Parsed model values. required **kwargs Any Additional validator arguments. {} Returns: Type Description str Validated entity identifier. Raises: Type Description ValueError If the entity ID is not found in the cache. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 @validator ( \"entity_id\" , allow_reuse = True ) # pylint: disable=E0213,W0613 def validate_entity_id ( cls , entity_id : str , values : dict [ str , Any ], ** kwargs : Any ) -> str : \"\"\"Validate the entity_id against the cache when available. Args: cls: Pydantic model class. entity_id: Candidate entity identifier. values: Parsed model values. **kwargs: Additional validator arguments. Returns: Validated entity identifier. Raises: ValueError: If the entity ID is not found in the cache. \"\"\" # ! BUG: The entity_id may not be validated correctly as the cache # ! is not passed to the validator. ha_cache = values . get ( \"ha_cache\" ) if ha_cache and entity_id not in ha_cache . cache [ \"entity_ids\" ]: raise ValueError ( f \"Entity ID ' { entity_id } ' is not in the Home Assistant cache.\" ) return entity_id SupportsInvoke Bases: Protocol Protocol for runnable chains that return HomeAssistantCall. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 56 57 58 59 60 61 62 63 64 65 66 67 68 class SupportsInvoke ( Protocol ): \"\"\"Protocol for runnable chains that return HomeAssistantCall.\"\"\" def invoke ( self , input_data : dict [ str , Any ]) -> HomeAssistantCall : \"\"\"Invoke the chain with structured input. Args: input_data: Input payload for the chain. Returns: Parsed HomeAssistantCall. \"\"\" ... invoke ( input_data : dict [ str , Any ]) -> HomeAssistantCall Invoke the chain with structured input. Parameters: Name Type Description Default input_data dict [ str , Any ] Input payload for the chain. required Returns: Type Description HomeAssistantCall Parsed HomeAssistantCall. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 59 60 61 62 63 64 65 66 67 68 def invoke ( self , input_data : dict [ str , Any ]) -> HomeAssistantCall : \"\"\"Invoke the chain with structured input. Args: input_data: Input payload for the chain. Returns: Parsed HomeAssistantCall. \"\"\" ... cache_monitor ( func : Callable [ Concatenate [ SelfT , P ], R ]) -> Callable [ Concatenate [ SelfT , P ], R ] Decorator to monitor and update the cache. Parameters: Name Type Description Default func Callable [ Concatenate [ SelfT , P ], R ] Method that updates a portion of the cache. required Returns: Type Description Callable [ Concatenate [ SelfT , P ], R ] Wrapped function that normalizes cache contents after execution. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 def cache_monitor ( func : Callable [ Concatenate [ SelfT , P ], R ]) -> Callable [ Concatenate [ SelfT , P ], R ]: \"\"\"Decorator to monitor and update the cache. Args: func: Method that updates a portion of the cache. Returns: Wrapped function that normalizes cache contents after execution. \"\"\" def sort_by_entity_id ( dict_list : list [ dict [ str , Any ]]) -> list [ dict [ str , Any ]]: \"\"\"Sort a list of entities by the entity_id field. Args: dict_list: List of entity dictionaries. Returns: Sorted list of entities. \"\"\" return sorted ( dict_list , key = lambda x : x [ \"entity_id\" ]) def clean_entities ( self : CacheHolder , forbidden_prefixes : list [ str ], forbidden_substrings : list [ str ], ) -> HomeAssistantCache : \"\"\"Filter and normalize entities while populating sensors. Args: self: Cache holder to mutate. forbidden_prefixes: Entity ID prefixes to exclude. forbidden_substrings: Entity ID substrings to exclude. Returns: Updated HomeAssistantCache payload. \"\"\" for idx , entity in enumerate ( self . cache [ \"entities\" ]): if \"context\" in entity : self . cache [ \"entities\" ][ idx ] . pop ( \"context\" ) self . cache [ \"entities\" ][ idx ] . pop ( \"last_changed\" ) self . cache [ \"entities\" ][ idx ] . pop ( \"last_reported\" ) self . cache [ \"entities\" ][ idx ] . pop ( \"last_updated\" ) if \"attributes\" in entity : self . cache [ \"entities\" ][ idx ][ \"attributes\" ] . pop ( \"icon\" , None ) self . cache [ \"entities\" ][ idx ][ \"attributes\" ] . pop ( \"monitor_cert_days_remaining\" , None ) self . cache [ \"entities\" ][ idx ][ \"attributes\" ] . pop ( \"monitor_cert_is_valid\" , None ) self . cache [ \"entities\" ][ idx ][ \"attributes\" ] . pop ( \"monitor_hostname\" , None ) self . cache [ \"entities\" ][ idx ][ \"attributes\" ] . pop ( \"monitor_port\" , None ) if any ( entity [ \"entity_id\" ] . startswith ( prefix ) for prefix in forbidden_prefixes ): self . cache [ \"entities\" ] . remove ( entity ) if any ( substring in entity [ \"entity_id\" ] for substring in forbidden_substrings ): self . cache [ \"entities\" ] . remove ( entity ) if entity [ \"entity_id\" ] . startswith ( \"scene.\" ): self . cache [ \"entities\" ][ idx ] . pop ( \"state\" , None ) if entity [ \"entity_id\" ] . startswith ( \"sensor.\" ) or entity [ \"entity_id\" ] . startswith ( \"binary_sensor.\" ): self . cache [ \"sensors\" ] . append ( entity ) self . cache [ \"entities\" ] . pop ( idx ) self . cache [ \"entities\" ] = sort_by_entity_id ( self . cache [ \"entities\" ]) self . cache [ \"sensors\" ] = sort_by_entity_id ( self . cache [ \"sensors\" ]) return self . cache def wrapper ( self : SelfT , * args : P . args , ** kwargs : P . kwargs ) -> R : \"\"\"Invoke the wrapped function and normalize cache content. Args: self: Cache holder instance. *args: Positional arguments forwarded to the wrapped function. **kwargs: Keyword arguments forwarded to the wrapped function. Returns: Result of the wrapped function. \"\"\" result = func ( self , * args , ** kwargs ) forbidden_prefixes = [ \"alarm_control_panel.\" , \"automation.\" , \"binary_sensor.remote_ui\" , \"camera.\" , \"climate\" , \"conversation\" , \"device_tracker.kraken_raspberry_pi_5\" , \"media_player.axios\" , \"media_player.axios_2\" , \"media_player.chrome\" , \"media_player.fire_tv_192_168_1_12\" , \"person.\" , \"remote.\" , \"script.higher\" , \"sensor.hacs\" , \"sensor.hacs\" , \"sensor.kraken_raspberry_pi_5_\" , \"sensor.sonarr_commands\" , \"sensor.sun\" , \"sensor.uptimekuma_\" , \"stt.\" , \"sun.\" , \"switch.\" , \"switch.adam\" , \"switch.bedroom_camera_camera_motion_detection\" , \"tts.\" , \"update.\" , \"zone.home\" , ] forbidden_substrings = [ \"blink_kk_bedroom\" ] self . cache [ \"sensor\" ] = [] # Clean entities self . cache = clean_entities ( self , forbidden_prefixes , forbidden_substrings ) # Clean services self . cache [ \"services\" ] = [ service for service in self . cache [ \"services\" ] if service [ \"domain\" ] in self . cache [ \"allowed_domains\" ] ] # Retrieve entity and sensor IDs self . cache [ \"entity_ids\" ] = sorted ( self . cache [ \"entity_ids\" ]) self . cache [ \"sensor_ids\" ] = sorted ( self . cache [ \"sensor_ids\" ]) logging . info ( ( \"` {} ` modified cache to <(len) Entity IDs: {} ; (len) Entities: {} ; \" \"(len) Sensors: {} ; (len) Services: {} ;>\" ), func . __name__ , len ( self . cache [ \"entity_ids\" ]), len ( self . cache [ \"entities\" ]), len ( self . cache [ \"sensors\" ]), len ( self . cache [ \"services\" ]), ) return result return wrapper meeseeks_tools.integration.mcp MCP tool runner for integrating MCP servers into Meeseeks. MCPToolRunner Wrapper to invoke MCP tools via langchain-mcp-adapters. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/mcp.py 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 class MCPToolRunner : \"\"\"Wrapper to invoke MCP tools via langchain-mcp-adapters.\"\"\" def __init__ ( self , server_name : str , tool_name : str ) -> None : \"\"\"Initialize the MCP tool runner for a specific server tool. Args: server_name: MCP server name from configuration. tool_name: Tool name to invoke on the server. \"\"\" self . server_name = server_name self . tool_name = tool_name async def _invoke_async ( self , input_payload : str | dict [ str , Any ]) -> str : \"\"\"Invoke an MCP tool asynchronously and return its output. Args: input_payload: Input payload to send to the MCP tool. Returns: Stringified tool response. Raises: RuntimeError: If MCP adapters are not installed. ValueError: If the server or tool is not configured. \"\"\" try : from langchain_mcp_adapters.client import MultiServerMCPClient except Exception as exc : # pragma: no cover - runtime dependency raise RuntimeError ( \"langchain-mcp-adapters is required for MCP tools.\" ) from exc config = _load_mcp_config () servers = config . get ( \"servers\" , {}) if not servers or self . server_name not in servers : raise ValueError ( f \"MCP server ' { self . server_name } ' not found in config.\" ) client = MultiServerMCPClient ({ self . server_name : servers [ self . server_name ]}) tools = await client . get_tools ( server_name = self . server_name ) tool_map = { tool . name : tool for tool in tools } tool = tool_map . get ( self . tool_name ) if tool is None : raise ValueError ( f \"Tool ' { self . tool_name } ' not found on MCP server ' { self . server_name } '.\" ) try : result = await tool . ainvoke ( _prepare_mcp_input ( tool , input_payload )) return str ( result ) except Exception as exc : _log_runtime_failure ( self . server_name , self . tool_name , exc ) raise def run ( self , action_step : ActionStep ) -> MockSpeaker : \"\"\"Execute the MCP tool using the action step argument. Args: action_step: Action step containing the prompt argument. Returns: MockSpeaker with the tool response content. Raises: ValueError: If action_step is None. \"\"\" if action_step is None : raise ValueError ( \"Action step cannot be None.\" ) MockSpeakerType = get_mock_speaker () result = asyncio . run ( self . _invoke_async ( action_step . tool_input )) return MockSpeakerType ( content = result ) __init__ ( server_name : str , tool_name : str ) -> None Initialize the MCP tool runner for a specific server tool. Parameters: Name Type Description Default server_name str MCP server name from configuration. required tool_name str Tool name to invoke on the server. required Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/mcp.py 265 266 267 268 269 270 271 272 273 def __init__ ( self , server_name : str , tool_name : str ) -> None : \"\"\"Initialize the MCP tool runner for a specific server tool. Args: server_name: MCP server name from configuration. tool_name: Tool name to invoke on the server. \"\"\" self . server_name = server_name self . tool_name = tool_name run ( action_step : ActionStep ) -> MockSpeaker Execute the MCP tool using the action step argument. Parameters: Name Type Description Default action_step ActionStep Action step containing the prompt argument. required Returns: Type Description MockSpeaker MockSpeaker with the tool response content. Raises: Type Description ValueError If action_step is None. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/mcp.py 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 def run ( self , action_step : ActionStep ) -> MockSpeaker : \"\"\"Execute the MCP tool using the action step argument. Args: action_step: Action step containing the prompt argument. Returns: MockSpeaker with the tool response content. Raises: ValueError: If action_step is None. \"\"\" if action_step is None : raise ValueError ( \"Action step cannot be None.\" ) MockSpeakerType = get_mock_speaker () result = asyncio . run ( self . _invoke_async ( action_step . tool_input )) return MockSpeakerType ( content = result ) discover_mcp_tool_details ( config : dict [ str , Any ]) -> dict [ str , list [ dict [ str , Any ]]] Discover MCP tool names and schemas per server from configuration. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/mcp.py 206 207 208 def discover_mcp_tool_details ( config : dict [ str , Any ]) -> dict [ str , list [ dict [ str , Any ]]]: \"\"\"Discover MCP tool names and schemas per server from configuration.\"\"\" return _run_async ( _discover_mcp_tool_details_async ( _normalize_mcp_config ( config ))) discover_mcp_tool_details_with_failures ( config : dict [ str , Any ]) -> tuple [ dict [ str , list [ dict [ str , Any ]]], dict [ str , Exception ]] Discover MCP tool names, schemas, and per-server failures. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/mcp.py 211 212 213 214 215 216 217 218 219 def discover_mcp_tool_details_with_failures ( config : dict [ str , Any ], ) -> tuple [ dict [ str , list [ dict [ str , Any ]]], dict [ str , Exception ]]: \"\"\"Discover MCP tool names, schemas, and per-server failures.\"\"\" discovered , failures = _run_async ( _discover_mcp_tool_details_with_failures_async ( _normalize_mcp_config ( config )) ) _record_discovery_failures ( failures ) return discovered , failures discover_mcp_tools ( config : dict [ str , Any ]) -> dict [ str , list [ str ]] Discover MCP tool names per server from configuration. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/mcp.py 197 198 199 200 201 202 203 def discover_mcp_tools ( config : dict [ str , Any ]) -> dict [ str , list [ str ]]: \"\"\"Discover MCP tool names per server from configuration.\"\"\" details = discover_mcp_tool_details ( config ) return { server_name : [ tool [ \"name\" ] for tool in tools if tool . get ( \"name\" )] for server_name , tools in details . items () } get_last_discovery_failures () -> dict [ str , str ] Return last MCP discovery failures per server (if any). Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/mcp.py 229 230 231 def get_last_discovery_failures () -> dict [ str , str ]: \"\"\"Return last MCP discovery failures per server (if any).\"\"\" return dict ( _LAST_DISCOVERY_FAILURES ) mark_tool_auto_approved ( config : dict [ str , Any ], server_name : str , tool_name : str ) -> dict [ str , Any ] Record a tool as auto-approved in the MCP config. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/mcp.py 247 248 249 250 251 252 253 254 255 256 257 258 259 def mark_tool_auto_approved ( config : dict [ str , Any ], server_name : str , tool_name : str , ) -> dict [ str , Any ]: \"\"\"Record a tool as auto-approved in the MCP config.\"\"\" servers = config . setdefault ( \"servers\" , {}) server_config = servers . setdefault ( server_name , {}) allowlist = server_config . setdefault ( \"auto_approve_tools\" , []) if tool_name not in allowlist : allowlist . append ( tool_name ) server_config [ \"auto_approve_tools\" ] = sorted ( set ( allowlist )) return config save_mcp_config ( config : dict [ str , Any ], path : str | None = None ) -> None Persist an MCP configuration payload to disk. Parameters: Name Type Description Default config dict [ str , Any ] MCP configuration payload to write. required path str | None Optional explicit file path (defaults to the configured MCP path). None Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/mcp.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 def save_mcp_config ( config : dict [ str , Any ], path : str | None = None ) -> None : \"\"\"Persist an MCP configuration payload to disk. Args: config: MCP configuration payload to write. path: Optional explicit file path (defaults to the configured MCP path). \"\"\" config_path = path or get_mcp_config_path () if not config_path : raise ValueError ( \"MCP config path is not set.\" ) config_path = os . path . abspath ( config_path ) with open ( config_path , \"w\" , encoding = \"utf-8\" ) as handle : json . dump ( config , handle , indent = 2 ) handle . write ( \" \\n \" ) tool_auto_approved ( config : dict [ str , Any ], server_name : str , tool_name : str ) -> bool Return True when a tool is marked as auto-approved. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/mcp.py 234 235 236 237 238 239 240 241 242 243 244 def tool_auto_approved ( config : dict [ str , Any ], server_name : str , tool_name : str , ) -> bool : \"\"\"Return True when a tool is marked as auto-approved.\"\"\" server_config = config . get ( \"servers\" , {}) . get ( server_name , {}) if server_config . get ( \"auto_approve_all\" ): return True allowlist = server_config . get ( \"auto_approve_tools\" , []) return tool_name in allowlist Home Assistant Integration meeseeks_ha_conversation.api Meeseeks API client. MeeseeksApiClient Meeseeks API Client. Source code in meeseeks_ha_conversation/api.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 class MeeseeksApiClient : \"\"\"Meeseeks API Client.\"\"\" def __init__ ( self , base_url : str , timeout : int , session : aiohttp . ClientSession , ) -> None : \"\"\"Initialize the API client. Args: base_url: Base URL for the Meeseeks API. timeout: Request timeout in seconds. session: Shared aiohttp client session. \"\"\" self . _base_url = base_url . rstrip ( \"/\" ) self . _api_key = \"msk-strong-password\" self . timeout = timeout self . _session = session async def async_get_heartbeat ( self ) -> bool : \"\"\"Get heartbeat from the API. Returns: True when the service is considered healthy. \"\"\" # TODO: Implement a heartbeat check return True async def async_get_models ( self ) -> str : \"\"\"Get models from the API. Returns: JSON-serialized model list. \"\"\" # TODO: This is monkey-patched for now response_data : ModelsResponse = { \"models\" : [ { \"name\" : \"meeseeks\" , \"modified_at\" : \"2023-11-01T00:00:00.000000000-04:00\" , \"size\" : 0 , \"digest\" : None , } ] } return json . dumps ( response_data ) async def async_generate ( self , data : dict [ str , Any ] | None = None ) -> MeeseeksQueryResponse : \"\"\"Generate a completion from the API. Args: data: Request payload including prompt and optional session ID. Returns: Parsed query response payload. Raises: ValueError: If prompt data is missing. ApiJsonError: If the API returns unexpected data. \"\"\" if not data or \"prompt\" not in data : raise ValueError ( \"Missing prompt in request data.\" ) url_query = f \" { self . _base_url } /api/query\" data_custom = { \"query\" : str ( data [ \"prompt\" ]) . strip (), } session_id = data . get ( \"session_id\" ) if isinstance ( data , dict ) else None if session_id : data_custom [ \"session_id\" ] = session_id # Pass headers as None to use the default headers result = await self . _meeseeks_api_wrapper ( method = \"post\" , url = url_query , data = data_custom , headers = None , ) if isinstance ( result , str ): raise ApiJsonError ( \"Unexpected text response from Meeseeks API.\" ) return result async def _meeseeks_api_wrapper ( self , method : str , url : str , data : dict [ str , Any ] | None = None , headers : dict [ str , str ] | None = None , decode_json : bool = True , ) -> MeeseeksQueryResponse | str : \"\"\"Perform an HTTP request to the Meeseeks API. Args: method: HTTP method to use. url: Fully qualified request URL. data: Optional JSON payload to send. headers: Optional HTTP headers override. decode_json: Whether to parse JSON responses. Returns: Parsed response payload or raw text depending on decode_json. Raises: ApiJsonError: If the API returns an error payload. aiohttp.ClientResponseError: For non-2xx responses. \"\"\" if headers is None : headers = { \"accept\" : \"application/json\" , \"X-API-KEY\" : self . _api_key , \"Content-Type\" : \"application/json\" , } async with async_timeout . timeout ( self . timeout ): response = await self . _session . request ( method = method , url = url , headers = headers , json = data , ) response . raise_for_status () if decode_json : raw_data : dict [ str , Any ] = await response . json () if response . status == 404 : raise ApiJsonError ( raw_data . get ( \"error\" , \"Unknown error\" )) task_result = str ( raw_data . get ( \"task_result\" , \"\" )) response_data : MeeseeksQueryResponse = { \"task_result\" : task_result , \"response\" : str ( raw_data . get ( \"response\" , task_result )), \"context\" : str ( raw_data . get ( \"context\" , task_result )), \"session_id\" : raw_data . get ( \"session_id\" ), } LOGGER . debug ( \"Response data: %s \" , response_data ) return response_data else : LOGGER . debug ( \"Fallback to text response\" ) return await response . text () __init__ ( base_url : str , timeout : int , session : aiohttp . ClientSession ) -> None Initialize the API client. Parameters: Name Type Description Default base_url str Base URL for the Meeseeks API. required timeout int Request timeout in seconds. required session ClientSession Shared aiohttp client session. required Source code in meeseeks_ha_conversation/api.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def __init__ ( self , base_url : str , timeout : int , session : aiohttp . ClientSession , ) -> None : \"\"\"Initialize the API client. Args: base_url: Base URL for the Meeseeks API. timeout: Request timeout in seconds. session: Shared aiohttp client session. \"\"\" self . _base_url = base_url . rstrip ( \"/\" ) self . _api_key = \"msk-strong-password\" self . timeout = timeout self . _session = session async_generate ( data : dict [ str , Any ] | None = None ) -> MeeseeksQueryResponse async Generate a completion from the API. Parameters: Name Type Description Default data dict [ str , Any ] | None Request payload including prompt and optional session ID. None Returns: Type Description MeeseeksQueryResponse Parsed query response payload. Raises: Type Description ValueError If prompt data is missing. ApiJsonError If the API returns unexpected data. Source code in meeseeks_ha_conversation/api.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 async def async_generate ( self , data : dict [ str , Any ] | None = None ) -> MeeseeksQueryResponse : \"\"\"Generate a completion from the API. Args: data: Request payload including prompt and optional session ID. Returns: Parsed query response payload. Raises: ValueError: If prompt data is missing. ApiJsonError: If the API returns unexpected data. \"\"\" if not data or \"prompt\" not in data : raise ValueError ( \"Missing prompt in request data.\" ) url_query = f \" { self . _base_url } /api/query\" data_custom = { \"query\" : str ( data [ \"prompt\" ]) . strip (), } session_id = data . get ( \"session_id\" ) if isinstance ( data , dict ) else None if session_id : data_custom [ \"session_id\" ] = session_id # Pass headers as None to use the default headers result = await self . _meeseeks_api_wrapper ( method = \"post\" , url = url_query , data = data_custom , headers = None , ) if isinstance ( result , str ): raise ApiJsonError ( \"Unexpected text response from Meeseeks API.\" ) return result async_get_heartbeat () -> bool async Get heartbeat from the API. Returns: Type Description bool True when the service is considered healthy. Source code in meeseeks_ha_conversation/api.py 53 54 55 56 57 58 59 60 async def async_get_heartbeat ( self ) -> bool : \"\"\"Get heartbeat from the API. Returns: True when the service is considered healthy. \"\"\" # TODO: Implement a heartbeat check return True async_get_models () -> str async Get models from the API. Returns: Type Description str JSON-serialized model list. Source code in meeseeks_ha_conversation/api.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 async def async_get_models ( self ) -> str : \"\"\"Get models from the API. Returns: JSON-serialized model list. \"\"\" # TODO: This is monkey-patched for now response_data : ModelsResponse = { \"models\" : [ { \"name\" : \"meeseeks\" , \"modified_at\" : \"2023-11-01T00:00:00.000000000-04:00\" , \"size\" : 0 , \"digest\" : None , } ] } return json . dumps ( response_data ) MeeseeksQueryResponse Bases: TypedDict Schema for the main query response. Source code in meeseeks_ha_conversation/api.py 23 24 25 26 27 28 29 class MeeseeksQueryResponse ( TypedDict ): \"\"\"Schema for the main query response.\"\"\" task_result : str response : str context : str session_id : str | None ModelsResponse Bases: TypedDict Schema for the models list endpoint response. Source code in meeseeks_ha_conversation/api.py 17 18 19 20 class ModelsResponse ( TypedDict ): \"\"\"Schema for the models list endpoint response.\"\"\" models : list [ dict [ str , Any ]] meeseeks_ha_conversation.config_flow Adds config flow for Meeseeks. MeeseeksConfigFlow Bases: ConfigFlow Handle a config flow for Meeseeks Conversation. Handles UI wizard. Source code in meeseeks_ha_conversation/config_flow.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 class MeeseeksConfigFlow ( config_entries . ConfigFlow , domain = DOMAIN ): # type: ignore[call-arg] \"\"\"Handle a config flow for Meeseeks Conversation. Handles UI wizard.\"\"\" VERSION = 1 client : MeeseeksApiClient async def async_step_user ( self , user_input : dict [ str , Any ] | None = None ) -> FlowResult : \"\"\"Handle the initial config flow step. Args: user_input: Submitted form data, if available. Returns: FlowResult for the configuration step. \"\"\" if user_input is None : return self . async_show_form ( step_id = \"user\" , data_schema = STEP_USER_DATA_SCHEMA ) # Search for duplicates with the same CONF_BASE_URL value. for existing_entry in self . _async_current_entries ( include_ignore = False ): if existing_entry . data . get ( CONF_BASE_URL ) == user_input [ CONF_BASE_URL ]: return self . async_abort ( reason = \"already_configured\" ) errors : dict [ str , str ] = {} try : self . client = MeeseeksApiClient ( base_url = cv . url_no_path ( user_input [ CONF_BASE_URL ]), timeout = user_input [ CONF_TIMEOUT ], session = async_create_clientsession ( self . hass ), ) response = await self . client . async_get_heartbeat () if not response : raise vol . Invalid ( \"Invalid Meeseeks server\" ) # except vol.Invalid: # errors[\"base\"] = \"invalid_url\" # except ApiTimeoutError: # errors[\"base\"] = \"timeout_connect\" # except ApiCommError: # errors[\"base\"] = \"cannot_connect\" # except ApiClientError as exception: # LOGGER.exception(\"Unexpected exception: %s\", exception) # errors[\"base\"] = \"unknown\" except Exception as exception : LOGGER . exception ( \"Unexpected exception: %s \" , exception ) errors [ \"base\" ] = \"unknown\" else : return self . async_create_entry ( title = f \"Meeseeks - { user_input [ CONF_BASE_URL ] } \" , data = { CONF_BASE_URL : user_input [ CONF_BASE_URL ]}, options = { CONF_TIMEOUT : user_input [ CONF_TIMEOUT ]}, ) return self . async_show_form ( step_id = \"user\" , data_schema = STEP_USER_DATA_SCHEMA , errors = errors ) @staticmethod def async_get_options_flow ( config_entry : config_entries . ConfigEntry , ) -> config_entries . OptionsFlow : \"\"\"Create the options flow. Args: config_entry: Existing config entry to edit. Returns: Options flow handler. \"\"\" return MeeseeksOptionsFlow ( config_entry ) async_get_options_flow ( config_entry : config_entries . ConfigEntry ) -> config_entries . OptionsFlow staticmethod Create the options flow. Parameters: Name Type Description Default config_entry ConfigEntry Existing config entry to edit. required Returns: Type Description OptionsFlow Options flow handler. Source code in meeseeks_ha_conversation/config_flow.py 108 109 110 111 112 113 114 115 116 117 118 119 120 @staticmethod def async_get_options_flow ( config_entry : config_entries . ConfigEntry , ) -> config_entries . OptionsFlow : \"\"\"Create the options flow. Args: config_entry: Existing config entry to edit. Returns: Options flow handler. \"\"\" return MeeseeksOptionsFlow ( config_entry ) async_step_user ( user_input : dict [ str , Any ] | None = None ) -> FlowResult async Handle the initial config flow step. Parameters: Name Type Description Default user_input dict [ str , Any ] | None Submitted form data, if available. None Returns: Type Description FlowResult FlowResult for the configuration step. Source code in meeseeks_ha_conversation/config_flow.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 async def async_step_user ( self , user_input : dict [ str , Any ] | None = None ) -> FlowResult : \"\"\"Handle the initial config flow step. Args: user_input: Submitted form data, if available. Returns: FlowResult for the configuration step. \"\"\" if user_input is None : return self . async_show_form ( step_id = \"user\" , data_schema = STEP_USER_DATA_SCHEMA ) # Search for duplicates with the same CONF_BASE_URL value. for existing_entry in self . _async_current_entries ( include_ignore = False ): if existing_entry . data . get ( CONF_BASE_URL ) == user_input [ CONF_BASE_URL ]: return self . async_abort ( reason = \"already_configured\" ) errors : dict [ str , str ] = {} try : self . client = MeeseeksApiClient ( base_url = cv . url_no_path ( user_input [ CONF_BASE_URL ]), timeout = user_input [ CONF_TIMEOUT ], session = async_create_clientsession ( self . hass ), ) response = await self . client . async_get_heartbeat () if not response : raise vol . Invalid ( \"Invalid Meeseeks server\" ) # except vol.Invalid: # errors[\"base\"] = \"invalid_url\" # except ApiTimeoutError: # errors[\"base\"] = \"timeout_connect\" # except ApiCommError: # errors[\"base\"] = \"cannot_connect\" # except ApiClientError as exception: # LOGGER.exception(\"Unexpected exception: %s\", exception) # errors[\"base\"] = \"unknown\" except Exception as exception : LOGGER . exception ( \"Unexpected exception: %s \" , exception ) errors [ \"base\" ] = \"unknown\" else : return self . async_create_entry ( title = f \"Meeseeks - { user_input [ CONF_BASE_URL ] } \" , data = { CONF_BASE_URL : user_input [ CONF_BASE_URL ]}, options = { CONF_TIMEOUT : user_input [ CONF_TIMEOUT ]}, ) return self . async_show_form ( step_id = \"user\" , data_schema = STEP_USER_DATA_SCHEMA , errors = errors ) MeeseeksOptionsFlow Bases: OptionsFlow Meeseeks config flow options handler. Source code in meeseeks_ha_conversation/config_flow.py 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 class MeeseeksOptionsFlow ( config_entries . OptionsFlow ): \"\"\"Meeseeks config flow options handler.\"\"\" def __init__ ( self , config_entry : config_entries . ConfigEntry ) -> None : \"\"\"Initialize options flow. Args: config_entry: Config entry to manage. \"\"\" self . config_entry = config_entry self . options = dict ( config_entry . options ) async def async_step_init ( self , user_input : dict [ str , Any ] | None = None ) -> FlowResult : \"\"\"Show the options menu. Args: user_input: Submitted form data, if available. Returns: FlowResult for the options menu. \"\"\" return self . async_show_menu ( step_id = \"init\" , menu_options = MENU_OPTIONS ) async def async_step_all_set ( self , user_input : dict [ str , Any ] | None = None ) -> FlowResult : \"\"\"Handle the \"all_set\" options step. Args: user_input: Submitted form data, if available. Returns: FlowResult for the options menu. \"\"\" return self . async_show_menu ( step_id = \"init\" , menu_options = MENU_OPTIONS ) async def async_step_general_config ( self , user_input : dict [ str , Any ] | None = None ) -> FlowResult : \"\"\"Handle the general configuration step. Args: user_input: Submitted form data, if available. Returns: FlowResult for the options menu. \"\"\" return self . async_show_menu ( step_id = \"init\" , menu_options = MENU_OPTIONS ) async def async_step_prompt_system ( self , user_input : dict [ str , Any ] | None = None ) -> FlowResult : \"\"\"Handle the prompt system configuration step. Args: user_input: Submitted form data, if available. Returns: FlowResult for the options menu. \"\"\" return self . async_show_menu ( step_id = \"init\" , menu_options = MENU_OPTIONS ) async def async_step_model_config ( self , user_input : dict [ str , Any ] | None = None ) -> FlowResult : \"\"\"Handle the model configuration step. Args: user_input: Submitted form data, if available. Returns: FlowResult for the options menu. \"\"\" return self . async_show_menu ( step_id = \"init\" , menu_options = MENU_OPTIONS ) __init__ ( config_entry : config_entries . ConfigEntry ) -> None Initialize options flow. Parameters: Name Type Description Default config_entry ConfigEntry Config entry to manage. required Source code in meeseeks_ha_conversation/config_flow.py 126 127 128 129 130 131 132 133 def __init__ ( self , config_entry : config_entries . ConfigEntry ) -> None : \"\"\"Initialize options flow. Args: config_entry: Config entry to manage. \"\"\" self . config_entry = config_entry self . options = dict ( config_entry . options ) async_step_all_set ( user_input : dict [ str , Any ] | None = None ) -> FlowResult async Handle the \"all_set\" options step. Parameters: Name Type Description Default user_input dict [ str , Any ] | None Submitted form data, if available. None Returns: Type Description FlowResult FlowResult for the options menu. Source code in meeseeks_ha_conversation/config_flow.py 146 147 148 149 150 151 152 153 154 155 async def async_step_all_set ( self , user_input : dict [ str , Any ] | None = None ) -> FlowResult : \"\"\"Handle the \"all_set\" options step. Args: user_input: Submitted form data, if available. Returns: FlowResult for the options menu. \"\"\" return self . async_show_menu ( step_id = \"init\" , menu_options = MENU_OPTIONS ) async_step_general_config ( user_input : dict [ str , Any ] | None = None ) -> FlowResult async Handle the general configuration step. Parameters: Name Type Description Default user_input dict [ str , Any ] | None Submitted form data, if available. None Returns: Type Description FlowResult FlowResult for the options menu. Source code in meeseeks_ha_conversation/config_flow.py 157 158 159 160 161 162 163 164 165 166 167 168 async def async_step_general_config ( self , user_input : dict [ str , Any ] | None = None ) -> FlowResult : \"\"\"Handle the general configuration step. Args: user_input: Submitted form data, if available. Returns: FlowResult for the options menu. \"\"\" return self . async_show_menu ( step_id = \"init\" , menu_options = MENU_OPTIONS ) async_step_init ( user_input : dict [ str , Any ] | None = None ) -> FlowResult async Show the options menu. Parameters: Name Type Description Default user_input dict [ str , Any ] | None Submitted form data, if available. None Returns: Type Description FlowResult FlowResult for the options menu. Source code in meeseeks_ha_conversation/config_flow.py 135 136 137 138 139 140 141 142 143 144 async def async_step_init ( self , user_input : dict [ str , Any ] | None = None ) -> FlowResult : \"\"\"Show the options menu. Args: user_input: Submitted form data, if available. Returns: FlowResult for the options menu. \"\"\" return self . async_show_menu ( step_id = \"init\" , menu_options = MENU_OPTIONS ) async_step_model_config ( user_input : dict [ str , Any ] | None = None ) -> FlowResult async Handle the model configuration step. Parameters: Name Type Description Default user_input dict [ str , Any ] | None Submitted form data, if available. None Returns: Type Description FlowResult FlowResult for the options menu. Source code in meeseeks_ha_conversation/config_flow.py 183 184 185 186 187 188 189 190 191 192 async def async_step_model_config ( self , user_input : dict [ str , Any ] | None = None ) -> FlowResult : \"\"\"Handle the model configuration step. Args: user_input: Submitted form data, if available. Returns: FlowResult for the options menu. \"\"\" return self . async_show_menu ( step_id = \"init\" , menu_options = MENU_OPTIONS ) async_step_prompt_system ( user_input : dict [ str , Any ] | None = None ) -> FlowResult async Handle the prompt system configuration step. Parameters: Name Type Description Default user_input dict [ str , Any ] | None Submitted form data, if available. None Returns: Type Description FlowResult FlowResult for the options menu. Source code in meeseeks_ha_conversation/config_flow.py 170 171 172 173 174 175 176 177 178 179 180 181 async def async_step_prompt_system ( self , user_input : dict [ str , Any ] | None = None ) -> FlowResult : \"\"\"Handle the prompt system configuration step. Args: user_input: Submitted form data, if available. Returns: FlowResult for the options menu. \"\"\" return self . async_show_menu ( step_id = \"init\" , menu_options = MENU_OPTIONS ) meeseeks_ha_conversation.const Constants for meeseeks_conversation. meeseeks_ha_conversation.coordinator DataUpdateCoordinator for meeseeks_conversation. MeeseeksDataUpdateCoordinator Bases: DataUpdateCoordinator Class to manage fetching data from the API. Source code in meeseeks_ha_conversation/coordinator.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 class MeeseeksDataUpdateCoordinator ( DataUpdateCoordinator ): \"\"\"Class to manage fetching data from the API.\"\"\" config_entry : ConfigEntry def __init__ ( self , hass : HomeAssistant , client : MeeseeksApiClient , ) -> None : \"\"\"Initialize the coordinator. Args: hass: Home Assistant core instance. client: API client for Meeseeks. \"\"\" self . client = client super () . __init__ ( hass = hass , logger = LOGGER , name = DOMAIN , update_interval = timedelta ( minutes = 5 ), ) async def _async_update_data ( self ) -> bool : \"\"\"Update data via library. Returns: True when the heartbeat check succeeds. Raises: UpdateFailed: If the API heartbeat fails. \"\"\" try : return await self . client . async_get_heartbeat () except ApiClientError as exception : raise UpdateFailed ( exception ) from exception __init__ ( hass : HomeAssistant , client : MeeseeksApiClient ) -> None Initialize the coordinator. Parameters: Name Type Description Default hass HomeAssistant Home Assistant core instance. required client MeeseeksApiClient API client for Meeseeks. required Source code in meeseeks_ha_conversation/coordinator.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def __init__ ( self , hass : HomeAssistant , client : MeeseeksApiClient , ) -> None : \"\"\"Initialize the coordinator. Args: hass: Home Assistant core instance. client: API client for Meeseeks. \"\"\" self . client = client super () . __init__ ( hass = hass , logger = LOGGER , name = DOMAIN , update_interval = timedelta ( minutes = 5 ), ) meeseeks_ha_conversation.exceptions The exceptions used by Extended OpenAI Conversation. ApiClientError Bases: HomeAssistantError Exception to indicate a general API error. Source code in meeseeks_ha_conversation/exceptions.py 6 7 class ApiClientError ( HomeAssistantError ): \"\"\"Exception to indicate a general API error.\"\"\" ApiCommError Bases: ApiClientError Exception to indicate a communication error. Source code in meeseeks_ha_conversation/exceptions.py 10 11 class ApiCommError ( ApiClientError ): \"\"\"Exception to indicate a communication error.\"\"\" ApiJsonError Bases: ApiClientError Exception to indicate an error with json response. Source code in meeseeks_ha_conversation/exceptions.py 14 15 class ApiJsonError ( ApiClientError ): \"\"\"Exception to indicate an error with json response.\"\"\" ApiTimeoutError Bases: ApiClientError Exception to indicate a timeout error. Source code in meeseeks_ha_conversation/exceptions.py 18 19 class ApiTimeoutError ( ApiClientError ): \"\"\"Exception to indicate a timeout error.\"\"\" meeseeks_ha_conversation.helpers Helper functions for Meeseeks. ExposedEntity Bases: TypedDict Typed representation of a Home Assistant entity exposed to conversation. Source code in meeseeks_ha_conversation/helpers.py 13 14 15 16 17 18 19 class ExposedEntity ( TypedDict ): \"\"\"Typed representation of a Home Assistant entity exposed to conversation.\"\"\" entity_id : str name : str state : str aliases : list [ str ] get_exposed_entities ( hass : HomeAssistant ) -> list [ ExposedEntity ] Return exposed entities. Parameters: Name Type Description Default hass HomeAssistant Home Assistant core instance. required Returns: Type Description list [ ExposedEntity ] List of exposed entities and their metadata. Source code in meeseeks_ha_conversation/helpers.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 def get_exposed_entities ( hass : HomeAssistant ) -> list [ ExposedEntity ]: \"\"\"Return exposed entities. Args: hass: Home Assistant core instance. Returns: List of exposed entities and their metadata. \"\"\" hass_entity = entity_registry . async_get ( hass ) exposed_entities : list [ ExposedEntity ] = [] for state in hass . states . async_all (): if async_should_expose ( hass , CONVERSATION_DOMAIN , state . entity_id ): entity = hass_entity . async_get ( state . entity_id ) exposed_entities . append ( { \"entity_id\" : state . entity_id , \"name\" : state . name , \"state\" : state . state , \"aliases\" : entity . aliases if entity else [], } ) return exposed_entities","title":"Reference"},{"location":"reference/#core","text":"SessionStore now includes archive helpers; see meeseeks_core.session_store for details.","title":"Core"},{"location":"reference/#meeseeks_core.classes","text":"Core data models and tool abstractions for Meeseeks orchestration.","title":"classes"},{"location":"reference/#meeseeks_core.classes.AbstractTool","text":"Bases: ABC Base tool with shared initialization helpers. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 class AbstractTool ( abc . ABC ): \"\"\"Base tool with shared initialization helpers.\"\"\" def __init__ ( self , name : str , description : str , model_name : str | None = None , use_llm : bool = True , ) -> None : \"\"\"Initialize tool configuration.\"\"\" tool_model = get_config_value ( \"llm\" , \"tool_model\" ) default_model = get_config_value ( \"llm\" , \"default_model\" , default = \"gpt-5.2\" ) self . model_name = cast ( str , model_name or tool_model or default_model , ) self . name = name self . description = description self . use_llm = use_llm self . _id = f \" { name . lower () . replace ( ' ' , '_' ) } _tool\" session_id = f \" { self . _id } -tool-id- { get_unique_timestamp () } \" logging . info ( f \"Tool created <name= { name } ; session_id= { session_id } ;>\" ) self . langfuse_handler = build_langfuse_handler ( user_id = f \"meeseeks- { name } \" , session_id = session_id , trace_name = f \"meeseeks- { self . _id } \" , version = get_config_value ( \"runtime\" , \"version\" , default = \"Not Specified\" ), release = get_config_value ( \"runtime\" , \"envmode\" , default = \"Not Specified\" ), ) self . model = None if self . use_llm : self . model = build_chat_model ( model_name = self . model_name , openai_api_base = get_config_value ( \"llm\" , \"api_base\" ), api_key = get_config_value ( \"llm\" , \"api_key\" ), ) root_cache_dir = get_config_value ( \"runtime\" , \"cache_dir\" , default = \".cache\" ) if not root_cache_dir : raise ValueError ( \"runtime.cache_dir is not set.\" ) self . cache_dir = os . path . abspath ( os . path . join ( str ( root_cache_dir ), self . _id )) logging . debug ( \" {} cache directory is {} .\" , self . _id , self . cache_dir ) def _save_json ( self , data : object , filename : str ) -> None : \"\"\"Persist JSON data under the cache directory.\"\"\" if not os . path . exists ( self . cache_dir ): os . makedirs ( self . cache_dir ) filename = os . path . join ( self . cache_dir , filename ) with open ( filename , \"w\" , encoding = \"utf-8\" ) as f : json . dump ( data , f , indent = 4 ) logging . info ( f \"Data saved to { filename } .\" ) def _load_rag_json ( self , filename : str ) -> list [ Document ]: \"\"\"Load JSON content as documents.\"\"\" logging . debug ( \"RAG directory is {} .\" , self . cache_dir ) logging . info ( f \"Loading ` { filename } ` as JSON.\" ) filename = os . path . join ( self . cache_dir , filename ) filename = os . path . abspath ( filename ) loader = JSONLoader ( file_path = filename , jq_schema = \".\" , text_content = False ) data = loader . load () return data def _load_rag_documents ( self , filenames : list [ str ]) -> list [ Document ]: \"\"\"Load and concatenate multiple JSON files.\"\"\" rag_documents : list [ Document ] = [] for rag_file in filenames : data = self . _load_rag_json ( rag_file ) rag_documents . extend ( data ) return rag_documents def set_state ( self , action_step : ActionStep | None = None ) -> MockSpeaker : \"\"\"Perform a state-changing action.\"\"\" MockSpeaker = get_mock_speaker () return MockSpeaker ( content = \"Not implemented yet.\" ) def get_state ( self , action_step : ActionStep | None = None ) -> MockSpeaker : \"\"\"Perform a read-only action.\"\"\" MockSpeaker = get_mock_speaker () return MockSpeaker ( content = \"Not implemented yet.\" ) def run ( self , action_step : ActionStep ) -> MockSpeaker : \"\"\"Execute the action based on the operation.\"\"\" if action_step . operation == \"set\" : return self . set_state ( action_step ) if action_step . operation == \"get\" : return self . get_state ( action_step ) raise ValueError ( f \"Invalid operation: { action_step . operation } \" )","title":"AbstractTool"},{"location":"reference/#meeseeks_core.classes.AbstractTool.__init__","text":"Initialize tool configuration. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 def __init__ ( self , name : str , description : str , model_name : str | None = None , use_llm : bool = True , ) -> None : \"\"\"Initialize tool configuration.\"\"\" tool_model = get_config_value ( \"llm\" , \"tool_model\" ) default_model = get_config_value ( \"llm\" , \"default_model\" , default = \"gpt-5.2\" ) self . model_name = cast ( str , model_name or tool_model or default_model , ) self . name = name self . description = description self . use_llm = use_llm self . _id = f \" { name . lower () . replace ( ' ' , '_' ) } _tool\" session_id = f \" { self . _id } -tool-id- { get_unique_timestamp () } \" logging . info ( f \"Tool created <name= { name } ; session_id= { session_id } ;>\" ) self . langfuse_handler = build_langfuse_handler ( user_id = f \"meeseeks- { name } \" , session_id = session_id , trace_name = f \"meeseeks- { self . _id } \" , version = get_config_value ( \"runtime\" , \"version\" , default = \"Not Specified\" ), release = get_config_value ( \"runtime\" , \"envmode\" , default = \"Not Specified\" ), ) self . model = None if self . use_llm : self . model = build_chat_model ( model_name = self . model_name , openai_api_base = get_config_value ( \"llm\" , \"api_base\" ), api_key = get_config_value ( \"llm\" , \"api_key\" ), ) root_cache_dir = get_config_value ( \"runtime\" , \"cache_dir\" , default = \".cache\" ) if not root_cache_dir : raise ValueError ( \"runtime.cache_dir is not set.\" ) self . cache_dir = os . path . abspath ( os . path . join ( str ( root_cache_dir ), self . _id )) logging . debug ( \" {} cache directory is {} .\" , self . _id , self . cache_dir )","title":"__init__"},{"location":"reference/#meeseeks_core.classes.AbstractTool.get_state","text":"Perform a read-only action. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 231 232 233 234 def get_state ( self , action_step : ActionStep | None = None ) -> MockSpeaker : \"\"\"Perform a read-only action.\"\"\" MockSpeaker = get_mock_speaker () return MockSpeaker ( content = \"Not implemented yet.\" )","title":"get_state"},{"location":"reference/#meeseeks_core.classes.AbstractTool.run","text":"Execute the action based on the operation. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 236 237 238 239 240 241 242 def run ( self , action_step : ActionStep ) -> MockSpeaker : \"\"\"Execute the action based on the operation.\"\"\" if action_step . operation == \"set\" : return self . set_state ( action_step ) if action_step . operation == \"get\" : return self . get_state ( action_step ) raise ValueError ( f \"Invalid operation: { action_step . operation } \" )","title":"run"},{"location":"reference/#meeseeks_core.classes.AbstractTool.set_state","text":"Perform a state-changing action. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 226 227 228 229 def set_state ( self , action_step : ActionStep | None = None ) -> MockSpeaker : \"\"\"Perform a state-changing action.\"\"\" MockSpeaker = get_mock_speaker () return MockSpeaker ( content = \"Not implemented yet.\" )","title":"set_state"},{"location":"reference/#meeseeks_core.classes.ActionStep","text":"Bases: BaseModel Action step with validation metadata. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 class ActionStep ( BaseModel ): \"\"\"Action step with validation metadata.\"\"\" title : str | None = Field ( default = None , description = \"Short header summarizing the task for this step.\" , ) objective : str | None = Field ( default = None , description = \"Brief objective explaining why this step is needed.\" , ) execution_checklist : list [ str ] = Field ( default_factory = list , description = \"Short checklist of execution details for this step.\" , ) expected_output : str | None = Field ( default = None , description = \"Optional description of what success looks like.\" , ) tool_id : str = Field ( description = ( \"Specify the tool_id that should execute the action. \" \"Use only tool IDs listed under Available tools.\" ) ) operation : str = Field ( description = \"Specify the execution type (get/set or execute).\" ) tool_input : ToolInput = Field ( description = ( \"Provide details for the action. If 'task', specify the task to perform. \" \"If 'talk', include the message to speak to the user.\" ) ) result : object | None = Field ( alias = \"_result\" , default = None , description = \"Private field to persist the action status and other data.\" , ) class Config : \"\"\"Allow both alias and field-name population.\"\"\" allow_population_by_field_name = True extra = \"forbid\"","title":"ActionStep"},{"location":"reference/#meeseeks_core.classes.ActionStep.Config","text":"Allow both alias and field-name population. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 70 71 72 73 74 class Config : \"\"\"Allow both alias and field-name population.\"\"\" allow_population_by_field_name = True extra = \"forbid\"","title":"Config"},{"location":"reference/#meeseeks_core.classes.OrchestrationState","text":"Bases: BaseModel State for the orchestration loop. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 143 144 145 146 147 148 149 150 151 152 153 class OrchestrationState ( BaseModel ): \"\"\"State for the orchestration loop.\"\"\" goal : str session_id : str | None = None plan : list [ PlanStep ] = Field ( default_factory = list ) tool_results : list [ str ] = Field ( default_factory = list ) open_questions : list [ str ] = Field ( default_factory = list ) done : bool = False done_reason : str | None = None summary : str | None = None","title":"OrchestrationState"},{"location":"reference/#meeseeks_core.classes.Plan","text":"Bases: BaseModel Plan with human-readable steps. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 84 85 86 87 88 89 90 91 92 class Plan ( BaseModel ): \"\"\"Plan with human-readable steps.\"\"\" human_message : str | None = Field ( alias = \"_human_message\" , default = None , description = \"Human message associated with the plan.\" , ) steps : list [ PlanStep ] = Field ( default_factory = list )","title":"Plan"},{"location":"reference/#meeseeks_core.classes.PlanStep","text":"Bases: BaseModel High-level plan step produced by the planner. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 77 78 79 80 81 class PlanStep ( BaseModel ): \"\"\"High-level plan step produced by the planner.\"\"\" title : str = Field ( description = \"Short title for the step.\" ) description : str = Field ( description = \"One-paragraph description of the step.\" )","title":"PlanStep"},{"location":"reference/#meeseeks_core.classes.TaskQueue","text":"Bases: BaseModel Queue of executed tool steps and results. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 class TaskQueue ( BaseModel ): \"\"\"Queue of executed tool steps and results.\"\"\" human_message : str | None = Field ( alias = \"_human_message\" , default = None , description = \"Human message associated with the task queue.\" , ) plan_steps : list [ PlanStep ] = Field ( default_factory = list ) action_steps : list [ ActionStep ] = Field ( default_factory = list ) task_result : str | None = Field ( alias = \"_task_result\" , default = None , description = \"Store the result for the entire task queue\" ) last_error : str | None = Field ( alias = \"_last_error\" , default = None , description = \"Short description of the most recent tool failure.\" , ) @validator ( \"action_steps\" , allow_reuse = True ) # pylint: disable=E0213,W0613 def validate_actions ( cls , field : list [ ActionStep ]) -> list [ ActionStep ]: \"\"\"Normalize and validate action steps.\"\"\" for action in field : action . tool_id = action . tool_id . lower () action . operation = action . operation . lower () error_msg_list = [] if action . tool_id not in AVAILABLE_TOOLS : error_msg_list . append ( f \"` { action . tool_id } ` is not a valid Assistant tool.\" ) if action . operation not in [ \"get\" , \"set\" , \"execute\" ]: error_msg = f \"` { action . operation } ` is not a valid operation.\" error_msg_list . append ( error_msg ) if action . tool_input is None : error_msg_list . append ( \"Tool input cannot be None.\" ) if error_msg_list : for msg in error_msg_list : logging . error ( msg ) return field","title":"TaskQueue"},{"location":"reference/#meeseeks_core.classes.TaskQueue.validate_actions","text":"Normalize and validate action steps. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 @validator ( \"action_steps\" , allow_reuse = True ) # pylint: disable=E0213,W0613 def validate_actions ( cls , field : list [ ActionStep ]) -> list [ ActionStep ]: \"\"\"Normalize and validate action steps.\"\"\" for action in field : action . tool_id = action . tool_id . lower () action . operation = action . operation . lower () error_msg_list = [] if action . tool_id not in AVAILABLE_TOOLS : error_msg_list . append ( f \"` { action . tool_id } ` is not a valid Assistant tool.\" ) if action . operation not in [ \"get\" , \"set\" , \"execute\" ]: error_msg = f \"` { action . operation } ` is not a valid operation.\" error_msg_list . append ( error_msg ) if action . tool_input is None : error_msg_list . append ( \"Tool input cannot be None.\" ) if error_msg_list : for msg in error_msg_list : logging . error ( msg ) return field","title":"validate_actions"},{"location":"reference/#meeseeks_core.classes.create_plan","text":"Create a Plan from serialized step data. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 260 261 262 263 264 265 266 267 268 269 270 271 def create_plan ( step_data : list [ dict [ str , str ]] | None = None , is_example : bool = True , ) -> Plan : \"\"\"Create a Plan from serialized step data.\"\"\" if step_data is None : raise ValueError ( \"Step data cannot be None.\" ) steps = [ PlanStep ( ** step ) for step in step_data ] plan = Plan ( steps = steps ) if is_example : del plan . human_message return plan","title":"create_plan"},{"location":"reference/#meeseeks_core.classes.create_task_queue","text":"Create a TaskQueue from serialized action data. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 245 246 247 248 249 250 251 252 253 254 255 256 257 def create_task_queue ( action_data : list [ ActionStepPayload ] | None = None , is_example : bool = True , ) -> TaskQueue : \"\"\"Create a TaskQueue from serialized action data.\"\"\" if action_data is None : raise ValueError ( \"Action data cannot be None.\" ) action_steps = [ ActionStep ( ** action ) for action in action_data ] task_queue = TaskQueue ( action_steps = action_steps ) if is_example : del task_queue . human_message return task_queue","title":"create_task_queue"},{"location":"reference/#meeseeks_core.classes.get_task_master_examples","text":"Return serialized example plan data. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 def get_task_master_examples ( example_id : int = 0 , available_tools : Sequence [ str ] | None = None , ) -> str : \"\"\"Return serialized example plan data.\"\"\" if available_tools is None : available_tools = AVAILABLE_TOOLS include_home_assistant = \"home_assistant_tool\" in available_tools if include_home_assistant : examples : list [ list [ dict [ str , str ]]] = [ [ { \"title\" : \"Turn on strip lights\" , \"description\" : \"Use Home Assistant to switch on the strip lights.\" , }, { \"title\" : \"Turn on heater\" , \"description\" : \"Use Home Assistant to switch on the heater.\" , }, ], [ { \"title\" : \"Check weather\" , \"description\" : \"Use Home Assistant to retrieve today's weather details.\" , }, ], ] else : examples = [[], []] if example_id not in range ( 0 , len ( examples )): raise ValueError ( f \"Invalid example ID: { example_id } \" ) return create_plan ( step_data = examples [ example_id ], is_example = True ) . json ()","title":"get_task_master_examples"},{"location":"reference/#meeseeks_core.classes.set_available_tools","text":"Update available tool IDs for validation. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 26 27 28 29 def set_available_tools ( tool_ids : list [ str ]) -> None : \"\"\"Update available tool IDs for validation.\"\"\" global AVAILABLE_TOOLS AVAILABLE_TOOLS = tool_ids","title":"set_available_tools"},{"location":"reference/#meeseeks_core.common","text":"Common helpers shared across the assistant runtime.","title":"common"},{"location":"reference/#meeseeks_core.common.MockSpeaker","text":"Bases: NamedTuple Simple mock response container used across tools and tests. Source code in packages/meeseeks_core/src/meeseeks_core/common.py 22 23 24 25 class MockSpeaker ( NamedTuple ): \"\"\"Simple mock response container used across tools and tests.\"\"\" content : str","title":"MockSpeaker"},{"location":"reference/#meeseeks_core.common.format_tool_input","text":"Format a tool input for logs and prompts. Source code in packages/meeseeks_core/src/meeseeks_core/common.py 169 170 171 172 173 def format_tool_input ( tool_input : object ) -> str : \"\"\"Format a tool input for logs and prompts.\"\"\" if isinstance ( tool_input , dict ): return json . dumps ( tool_input , ensure_ascii = True ) return str ( tool_input )","title":"format_tool_input"},{"location":"reference/#meeseeks_core.common.get_logger","text":"Get the logger for the module. Source code in packages/meeseeks_core/src/meeseeks_core/common.py 131 132 133 134 135 136 def get_logger ( name : str | None = None ): \"\"\"Get the logger for the module.\"\"\" _configure_logging () if not name : name = __name__ return loguru_logger . bind ( name = name )","title":"get_logger"},{"location":"reference/#meeseeks_core.common.get_mock_speaker","text":"Return a mock speaker for testing. Source code in packages/meeseeks_core/src/meeseeks_core/common.py 28 29 30 def get_mock_speaker () -> type [ MockSpeaker ]: \"\"\"Return a mock speaker for testing.\"\"\" return MockSpeaker","title":"get_mock_speaker"},{"location":"reference/#meeseeks_core.common.get_system_prompt","text":"Get the system prompt for the task queue. Source code in packages/meeseeks_core/src/meeseeks_core/common.py 157 158 159 160 161 162 163 164 165 166 def get_system_prompt ( name : str = \"action-planner\" ) -> str : \"\"\"Get the system prompt for the task queue.\"\"\" logging = get_logger ( name = \"core.common.get_system_prompt\" ) prompt_resource = resources . files ( \"meeseeks_core\" ) . joinpath ( \"prompts\" ) . joinpath ( f \" { name } .txt\" ) with resources . as_file ( prompt_resource ) as system_prompt_path : with open ( system_prompt_path , encoding = \"utf-8\" ) as system_prompt_file : system_prompt = system_prompt_file . read () logging . debug ( \"Getting system prompt from ` {} `\" , system_prompt_path ) del logging return system_prompt . strip ()","title":"get_system_prompt"},{"location":"reference/#meeseeks_core.common.get_unique_timestamp","text":"Get a unique timestamp for the task queue. Source code in packages/meeseeks_core/src/meeseeks_core/common.py 147 148 149 150 151 152 153 154 def get_unique_timestamp () -> int : \"\"\"Get a unique timestamp for the task queue.\"\"\" # Get the number of seconds since epoch (Jan 1, 1970) as a float current_timestamp = int ( time . time ()) # Convert it to string for uniqueness and consistency unique_timestamp = str ( current_timestamp ) # Return the integer version of this string timestamp return int ( \"\" . join ( str ( x ) for x in map ( int , unique_timestamp )))","title":"get_unique_timestamp"},{"location":"reference/#meeseeks_core.common.ha_render_system_prompt","text":"Render the Home Assistant Jinja2 system prompt. Source code in packages/meeseeks_core/src/meeseeks_core/common.py 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 def ha_render_system_prompt ( all_entities : object | None = None , name : str = \"homeassistant-set-state\" , ) -> str : \"\"\"Render the Home Assistant Jinja2 system prompt.\"\"\" if all_entities is not None : all_entities = str ( all_entities ) . strip () logging = get_logger ( name = \"core.common.render_system_prompt\" ) # TODO: Catch and log TemplateNotFound when necessary. template_env = Environment ( loader = PackageLoader ( \"meeseeks_core\" , \"prompts\" )) template = template_env . get_template ( f \" { name } .txt\" ) logging . debug ( \"Render system prompt for ` {} `\" , name ) del logging return template . render ( ALL_ENTITIES = all_entities )","title":"ha_render_system_prompt"},{"location":"reference/#meeseeks_core.common.num_tokens_from_string","text":"Get the number of tokens in a string using a specific model. Source code in packages/meeseeks_core/src/meeseeks_core/common.py 139 140 141 142 143 144 def num_tokens_from_string ( string : str , encoding_name : str = \"cl100k_base\" ) -> int : \"\"\"Get the number of tokens in a string using a specific model.\"\"\" # TODO: Add support for dynamic model selection encoding = tiktoken . get_encoding ( encoding_name ) num_tokens = len ( encoding . encode ( string )) return num_tokens","title":"num_tokens_from_string"},{"location":"reference/#meeseeks_core.common.session_log_context","text":"Context manager that logs all session output to a session log file. Source code in packages/meeseeks_core/src/meeseeks_core/common.py 120 121 122 123 124 125 126 127 128 @contextmanager def session_log_context ( session_id : str , log_dir : str | None = None ): \"\"\"Context manager that logs all session output to a session log file.\"\"\" _ensure_session_log_sink ( session_id , log_dir = log_dir ) try : with loguru_logger . contextualize ( session_id = session_id ): yield finally : _release_session_log_sink ( session_id )","title":"session_log_context"},{"location":"reference/#meeseeks_core.compaction","text":"Transcript compaction utilities.","title":"compaction"},{"location":"reference/#meeseeks_core.compaction.should_compact","text":"Return True when the event list meets the compaction threshold. Parameters: Name Type Description Default events Iterable [ EventRecord ] Iterable of event records to count. required threshold int Minimum number of events that triggers compaction. 50 Returns: Type Description bool True when compaction should run. Source code in packages/meeseeks_core/src/meeseeks_core/compaction.py 40 41 42 43 44 45 46 47 48 49 50 def should_compact ( events : Iterable [ EventRecord ], threshold : int = 50 ) -> bool : \"\"\"Return True when the event list meets the compaction threshold. Args: events: Iterable of event records to count. threshold: Minimum number of events that triggers compaction. Returns: True when compaction should run. \"\"\" return len ( list ( events )) >= threshold","title":"should_compact"},{"location":"reference/#meeseeks_core.compaction.summarize_events","text":"Generate a lightweight summary of recent events. Parameters: Name Type Description Default events Iterable [ EventRecord ] Iterable of event records to summarize. required max_items int Maximum number of recent events to include. 20 Returns: Type Description str Concise summary string of recent events. Source code in packages/meeseeks_core/src/meeseeks_core/compaction.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def summarize_events ( events : Iterable [ EventRecord ], max_items : int = 20 ) -> str : \"\"\"Generate a lightweight summary of recent events. Args: events: Iterable of event records to summarize. max_items: Maximum number of recent events to include. Returns: Concise summary string of recent events. \"\"\" snippets : list [ str ] = [] for event in list ( events )[ - max_items :]: event_type = event . get ( \"type\" , \"event\" ) payload_value : object = event . get ( \"payload\" , \"\" ) if isinstance ( payload_value , dict ): payload_data = dict ( payload_value ) payload_value = ( payload_data . get ( \"text\" ) or payload_data . get ( \"message\" ) or str ( payload_data ) ) if payload_value : snippets . append ( f \" { event_type } : { payload_value } \" ) else : snippets . append ( f \" { event_type } .\" ) return \" | \" . join ( snippets ) . strip ()","title":"summarize_events"},{"location":"reference/#meeseeks_core.components","text":"Helpers for optional components and observability integration.","title":"components"},{"location":"reference/#meeseeks_core.components.ComponentStatus","text":"Describe whether a component is enabled and why. Source code in packages/meeseeks_core/src/meeseeks_core/components.py 34 35 36 37 38 39 40 41 @dataclass ( frozen = True ) class ComponentStatus : \"\"\"Describe whether a component is enabled and why.\"\"\" name : str enabled : bool reason : str | None = None metadata : dict [ str , JsonValue ] = field ( default_factory = dict )","title":"ComponentStatus"},{"location":"reference/#meeseeks_core.components.build_langfuse_handler","text":"Create a Langfuse callback handler when configured. Source code in packages/meeseeks_core/src/meeseeks_core/components.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def build_langfuse_handler ( * , user_id : str , session_id : str , trace_name : str , version : str , release : str , trace_context : TraceContext | None = None , ) -> LangfuseCallbackHandler | None : \"\"\"Create a Langfuse callback handler when configured.\"\"\" status = resolve_langfuse_status () if not status . enabled : logging . debug ( \"Langfuse disabled: {} \" , status . reason ) return None config = get_config () . langfuse _ensure_langfuse_client ( config ) from langfuse.langchain import CallbackHandler trace_context = trace_context or _LANGFUSE_TRACE_CONTEXT . get () session_id_value = _LANGFUSE_SESSION_ID . get () or session_id user_id_value = _LANGFUSE_USER_ID . get () or user_id try : handler = CallbackHandler ( public_key = config . public_key or None , trace_context = trace_context ) _attach_langfuse_metadata ( handler , user_id = user_id_value , session_id = session_id_value , trace_name = trace_name , version = version , release = release , ) return handler except Exception as exc : # pragma: no cover - defensive logging . warning ( \"Langfuse initialization failed: {} \" , exc ) return None","title":"build_langfuse_handler"},{"location":"reference/#meeseeks_core.components.format_component_status","text":"Format component statuses for inclusion in prompts. Source code in packages/meeseeks_core/src/meeseeks_core/components.py 101 102 103 104 105 106 107 108 def format_component_status ( statuses : Iterable [ ComponentStatus ]) -> str : \"\"\"Format component statuses for inclusion in prompts.\"\"\" lines : list [ str ] = [] for status in statuses : state = \"enabled\" if status . enabled else \"disabled\" reason = f \" ( { status . reason } )\" if status . reason else \"\" lines . append ( f \"- { status . name } : { state }{ reason } \" ) return \" \\n \" . join ( lines )","title":"format_component_status"},{"location":"reference/#meeseeks_core.components.langfuse_session_context","text":"Bind a stable Langfuse trace context to the current session. Source code in packages/meeseeks_core/src/meeseeks_core/components.py 133 134 135 136 137 138 139 140 141 142 143 144 145 @contextmanager def langfuse_session_context ( session_id : str , * , user_id : str | None = None ) -> Iterator [ None ]: \"\"\"Bind a stable Langfuse trace context to the current session.\"\"\" trace_context = _build_langfuse_trace_context ( session_id ) token_ctx = _LANGFUSE_TRACE_CONTEXT . set ( trace_context ) token_session = _LANGFUSE_SESSION_ID . set ( session_id ) token_user = _LANGFUSE_USER_ID . set ( user_id or session_id ) try : yield finally : _LANGFUSE_TRACE_CONTEXT . reset ( token_ctx ) _LANGFUSE_SESSION_ID . reset ( token_session ) _LANGFUSE_USER_ID . reset ( token_user )","title":"langfuse_session_context"},{"location":"reference/#meeseeks_core.components.langfuse_trace_span","text":"Open a Langfuse span bound to the current session trace context. Source code in packages/meeseeks_core/src/meeseeks_core/components.py 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 @contextmanager def langfuse_trace_span ( name : str ) -> Iterator [ object | None ]: \"\"\"Open a Langfuse span bound to the current session trace context.\"\"\" status = resolve_langfuse_status () if not status . enabled : yield None return trace_context = _LANGFUSE_TRACE_CONTEXT . get () if not trace_context : yield None return try : from langfuse import get_client except Exception : # pragma: no cover - defensive yield None return try : langfuse = get_client () with langfuse . start_as_current_observation ( as_type = \"span\" , name = name , trace_context = trace_context , ) as span : yield span except Exception : # pragma: no cover - defensive yield None","title":"langfuse_trace_span"},{"location":"reference/#meeseeks_core.components.resolve_home_assistant_status","text":"Determine whether the Home Assistant tool is configured. Source code in packages/meeseeks_core/src/meeseeks_core/components.py 90 91 92 93 94 95 96 97 98 def resolve_home_assistant_status () -> ComponentStatus : \"\"\"Determine whether the Home Assistant tool is configured.\"\"\" enabled , reason , metadata = get_config () . home_assistant . evaluate () return ComponentStatus ( name = \"home_assistant_tool\" , enabled = enabled , reason = reason , metadata = metadata , )","title":"resolve_home_assistant_status"},{"location":"reference/#meeseeks_core.components.resolve_langfuse_status","text":"Determine whether Langfuse callbacks are available and configured. Source code in packages/meeseeks_core/src/meeseeks_core/components.py 44 45 46 47 def resolve_langfuse_status () -> ComponentStatus : \"\"\"Determine whether Langfuse callbacks are available and configured.\"\"\" enabled , reason , metadata = get_config () . langfuse . evaluate () return ComponentStatus ( name = \"langfuse\" , enabled = enabled , reason = reason , metadata = metadata )","title":"resolve_langfuse_status"},{"location":"reference/#meeseeks_core.hooks","text":"Hook manager for orchestration lifecycle events.","title":"hooks"},{"location":"reference/#meeseeks_core.hooks.HookManager","text":"Container for hook callbacks used during orchestration. Source code in packages/meeseeks_core/src/meeseeks_core/hooks.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 @dataclass class HookManager : \"\"\"Container for hook callbacks used during orchestration.\"\"\" pre_tool_use : list [ Callable [[ ActionStep ], ActionStep ]] = field ( default_factory = list ) post_tool_use : list [ Callable [[ ActionStep , MockSpeaker ], MockSpeaker ]] = field ( default_factory = list ) permission_request : list [ Callable [[ ActionStep , PermissionDecision ], PermissionDecision ]] = ( field ( default_factory = list ) ) pre_compact : list [ Callable [[ list [ EventRecord ]], list [ EventRecord ]]] = field ( default_factory = list ) def run_pre_tool_use ( self , action_step : ActionStep ) -> ActionStep : \"\"\"Apply pre-tool hooks to an action step. Args: action_step: Action step to process. Returns: Updated action step after hooks run. \"\"\" for hook in self . pre_tool_use : action_step = hook ( action_step ) return action_step def run_post_tool_use ( self , action_step : ActionStep , result : MockSpeaker ) -> MockSpeaker : \"\"\"Apply post-tool hooks to a tool result. Args: action_step: Action step that was executed. result: Result returned by the tool. Returns: Updated result after hooks run. \"\"\" for hook in self . post_tool_use : result = hook ( action_step , result ) return result def run_permission_request ( self , action_step : ActionStep , decision : PermissionDecision ) -> PermissionDecision : \"\"\"Apply permission hooks to a decision outcome. Args: action_step: Action step under review. decision: Current decision to modify. Returns: Updated permission decision after hooks run. \"\"\" for hook in self . permission_request : decision = hook ( action_step , decision ) return decision def run_pre_compact ( self , events : Iterable [ EventRecord ]) -> list [ EventRecord ]: \"\"\"Apply compaction hooks to events prior to summarization. Args: events: Iterable of event records. Returns: List of event records after hooks run. \"\"\" event_list : list [ EventRecord ] = list ( events ) for hook in self . pre_compact : event_list = hook ( event_list ) return event_list","title":"HookManager"},{"location":"reference/#meeseeks_core.hooks.HookManager.run_permission_request","text":"Apply permission hooks to a decision outcome. Parameters: Name Type Description Default action_step ActionStep Action step under review. required decision PermissionDecision Current decision to modify. required Returns: Type Description PermissionDecision Updated permission decision after hooks run. Source code in packages/meeseeks_core/src/meeseeks_core/hooks.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 def run_permission_request ( self , action_step : ActionStep , decision : PermissionDecision ) -> PermissionDecision : \"\"\"Apply permission hooks to a decision outcome. Args: action_step: Action step under review. decision: Current decision to modify. Returns: Updated permission decision after hooks run. \"\"\" for hook in self . permission_request : decision = hook ( action_step , decision ) return decision","title":"run_permission_request"},{"location":"reference/#meeseeks_core.hooks.HookManager.run_post_tool_use","text":"Apply post-tool hooks to a tool result. Parameters: Name Type Description Default action_step ActionStep Action step that was executed. required result MockSpeaker Result returned by the tool. required Returns: Type Description MockSpeaker Updated result after hooks run. Source code in packages/meeseeks_core/src/meeseeks_core/hooks.py 43 44 45 46 47 48 49 50 51 52 53 54 55 def run_post_tool_use ( self , action_step : ActionStep , result : MockSpeaker ) -> MockSpeaker : \"\"\"Apply post-tool hooks to a tool result. Args: action_step: Action step that was executed. result: Result returned by the tool. Returns: Updated result after hooks run. \"\"\" for hook in self . post_tool_use : result = hook ( action_step , result ) return result","title":"run_post_tool_use"},{"location":"reference/#meeseeks_core.hooks.HookManager.run_pre_compact","text":"Apply compaction hooks to events prior to summarization. Parameters: Name Type Description Default events Iterable [ EventRecord ] Iterable of event records. required Returns: Type Description list [ EventRecord ] List of event records after hooks run. Source code in packages/meeseeks_core/src/meeseeks_core/hooks.py 73 74 75 76 77 78 79 80 81 82 83 84 85 def run_pre_compact ( self , events : Iterable [ EventRecord ]) -> list [ EventRecord ]: \"\"\"Apply compaction hooks to events prior to summarization. Args: events: Iterable of event records. Returns: List of event records after hooks run. \"\"\" event_list : list [ EventRecord ] = list ( events ) for hook in self . pre_compact : event_list = hook ( event_list ) return event_list","title":"run_pre_compact"},{"location":"reference/#meeseeks_core.hooks.HookManager.run_pre_tool_use","text":"Apply pre-tool hooks to an action step. Parameters: Name Type Description Default action_step ActionStep Action step to process. required Returns: Type Description ActionStep Updated action step after hooks run. Source code in packages/meeseeks_core/src/meeseeks_core/hooks.py 30 31 32 33 34 35 36 37 38 39 40 41 def run_pre_tool_use ( self , action_step : ActionStep ) -> ActionStep : \"\"\"Apply pre-tool hooks to an action step. Args: action_step: Action step to process. Returns: Updated action step after hooks run. \"\"\" for hook in self . pre_tool_use : action_step = hook ( action_step ) return action_step","title":"run_pre_tool_use"},{"location":"reference/#meeseeks_core.hooks.default_hook_manager","text":"Create a hook manager with no custom hooks registered. Returns: Type Description HookManager Empty HookManager instance. Source code in packages/meeseeks_core/src/meeseeks_core/hooks.py 88 89 90 91 92 93 94 def default_hook_manager () -> HookManager : \"\"\"Create a hook manager with no custom hooks registered. Returns: Empty HookManager instance. \"\"\" return HookManager ()","title":"default_hook_manager"},{"location":"reference/#meeseeks_core.llm","text":"Model configuration helpers for ChatLiteLLM.","title":"llm"},{"location":"reference/#meeseeks_core.llm.ChatModel","text":"Bases: Protocol Protocol for LangChain-compatible chat models. Source code in packages/meeseeks_core/src/meeseeks_core/llm.py 12 13 14 15 16 class ChatModel ( Protocol ): \"\"\"Protocol for LangChain-compatible chat models.\"\"\" def invoke ( self , input_data : object , config : object | None = None , ** kwargs : object ) -> object : \"\"\"Invoke the model with structured input.\"\"\"","title":"ChatModel"},{"location":"reference/#meeseeks_core.llm.ChatModel.invoke","text":"Invoke the model with structured input. Source code in packages/meeseeks_core/src/meeseeks_core/llm.py 15 16 def invoke ( self , input_data : object , config : object | None = None , ** kwargs : object ) -> object : \"\"\"Invoke the model with structured input.\"\"\"","title":"invoke"},{"location":"reference/#meeseeks_core.llm.build_chat_model","text":"Build a ChatLiteLLM model with reasoning-effort compatibility. Source code in packages/meeseeks_core/src/meeseeks_core/llm.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def build_chat_model ( model_name : str , * , openai_api_base : str | None = None , api_key : str | None = None , ) -> ChatModel : \"\"\"Build a ChatLiteLLM model with reasoning-effort compatibility.\"\"\" try : from langchain_litellm import ChatLiteLLM except ImportError as exc : # pragma: no cover - dependency guard raise ImportError ( \"langchain-litellm is required to build ChatLiteLLM\" ) from exc reasoning_effort = resolve_reasoning_effort ( model_name ) model_kwargs : dict [ str , Any ] = {} if reasoning_effort is not None : model_kwargs [ \"reasoning_effort\" ] = reasoning_effort kwargs : dict [ str , Any ] = { \"model\" : _resolve_litellm_model ( model_name , openai_api_base ), } if openai_api_base : kwargs [ \"api_base\" ] = openai_api_base if api_key : kwargs [ \"api_key\" ] = api_key if model_kwargs : kwargs [ \"model_kwargs\" ] = model_kwargs return cast ( ChatModel , ChatLiteLLM ( ** kwargs ))","title":"build_chat_model"},{"location":"reference/#meeseeks_core.llm.model_supports_reasoning_effort","text":"Return True if the model is known to support reasoning_effort. Source code in packages/meeseeks_core/src/meeseeks_core/llm.py 47 48 49 50 51 52 53 54 55 56 57 58 def model_supports_reasoning_effort ( model_name : str | None ) -> bool : \"\"\"Return True if the model is known to support reasoning_effort.\"\"\" if not model_name : return False raw = model_name . lower () normalized = _strip_provider ( model_name ) allowlist = _normalize_model_list ( get_config_value ( \"llm\" , \"reasoning_effort_models\" , default = []) ) if _matches_model_list ( raw , allowlist ) or _matches_model_list ( normalized , allowlist ): return True return normalized . startswith ( \"gpt-5\" )","title":"model_supports_reasoning_effort"},{"location":"reference/#meeseeks_core.llm.resolve_reasoning_effort","text":"Resolve the reasoning effort to use for a model. Source code in packages/meeseeks_core/src/meeseeks_core/llm.py 61 62 63 64 65 66 67 68 69 70 71 def resolve_reasoning_effort ( model_name : str | None ) -> str | None : \"\"\"Resolve the reasoning effort to use for a model.\"\"\" configured = get_config_value ( \"llm\" , \"reasoning_effort\" , default = \"\" ) if isinstance ( configured , str ) and configured . strip (): return configured . strip () . lower () if not model_supports_reasoning_effort ( model_name ): return None normalized = _strip_provider ( model_name ) if \"gpt-5-pro\" in normalized : return \"high\" return \"medium\"","title":"resolve_reasoning_effort"},{"location":"reference/#meeseeks_core.permissions","text":"Permission policies for tool execution.","title":"permissions"},{"location":"reference/#meeseeks_core.permissions.PermissionDecision","text":"Bases: str , Enum Outcomes for a permission check. Source code in packages/meeseeks_core/src/meeseeks_core/permissions.py 23 24 25 26 27 28 class PermissionDecision ( str , Enum ): \"\"\"Outcomes for a permission check.\"\"\" ALLOW = \"allow\" DENY = \"deny\" ASK = \"ask\"","title":"PermissionDecision"},{"location":"reference/#meeseeks_core.permissions.PermissionPolicy","text":"Evaluate permission rules for action steps. Source code in packages/meeseeks_core/src/meeseeks_core/permissions.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 class PermissionPolicy : \"\"\"Evaluate permission rules for action steps.\"\"\" def __init__ ( self , rules : list [ PermissionRule ] | None = None , default_by_operation : dict [ str , PermissionDecision ] | None = None , default_decision : PermissionDecision = PermissionDecision . ASK , ) -> None : \"\"\"Initialize the permission policy.\"\"\" self . _rules = rules or [] self . _default_by_operation = default_by_operation or {} self . _default_decision = default_decision def decide ( self , action_step : ActionStep ) -> PermissionDecision : \"\"\"Return the permission decision for an action step.\"\"\" for rule in self . _rules : if rule . matches ( action_step ): return rule . decision operation_decision = self . _default_by_operation . get ( action_step . operation ) if operation_decision is not None : return operation_decision return self . _default_decision","title":"PermissionPolicy"},{"location":"reference/#meeseeks_core.permissions.PermissionPolicy.__init__","text":"Initialize the permission policy. Source code in packages/meeseeks_core/src/meeseeks_core/permissions.py 49 50 51 52 53 54 55 56 57 58 def __init__ ( self , rules : list [ PermissionRule ] | None = None , default_by_operation : dict [ str , PermissionDecision ] | None = None , default_decision : PermissionDecision = PermissionDecision . ASK , ) -> None : \"\"\"Initialize the permission policy.\"\"\" self . _rules = rules or [] self . _default_by_operation = default_by_operation or {} self . _default_decision = default_decision","title":"__init__"},{"location":"reference/#meeseeks_core.permissions.PermissionPolicy.decide","text":"Return the permission decision for an action step. Source code in packages/meeseeks_core/src/meeseeks_core/permissions.py 60 61 62 63 64 65 66 67 68 def decide ( self , action_step : ActionStep ) -> PermissionDecision : \"\"\"Return the permission decision for an action step.\"\"\" for rule in self . _rules : if rule . matches ( action_step ): return rule . decision operation_decision = self . _default_by_operation . get ( action_step . operation ) if operation_decision is not None : return operation_decision return self . _default_decision","title":"decide"},{"location":"reference/#meeseeks_core.permissions.PermissionRule","text":"Rule describing a tool/action permission decision. Source code in packages/meeseeks_core/src/meeseeks_core/permissions.py 31 32 33 34 35 36 37 38 39 40 41 42 43 @dataclass ( frozen = True ) class PermissionRule : \"\"\"Rule describing a tool/action permission decision.\"\"\" tool_id : str = \"*\" operation : str = \"*\" decision : PermissionDecision = PermissionDecision . ASK def matches ( self , action_step : ActionStep ) -> bool : \"\"\"Return True when the action step matches the rule pattern.\"\"\" return fnmatch ( action_step . tool_id , self . tool_id ) and fnmatch ( action_step . operation , self . operation )","title":"PermissionRule"},{"location":"reference/#meeseeks_core.permissions.PermissionRule.matches","text":"Return True when the action step matches the rule pattern. Source code in packages/meeseeks_core/src/meeseeks_core/permissions.py 39 40 41 42 43 def matches ( self , action_step : ActionStep ) -> bool : \"\"\"Return True when the action step matches the rule pattern.\"\"\" return fnmatch ( action_step . tool_id , self . tool_id ) and fnmatch ( action_step . operation , self . operation )","title":"matches"},{"location":"reference/#meeseeks_core.permissions.approval_callback_from_config","text":"Return an approval callback based on config settings. Source code in packages/meeseeks_core/src/meeseeks_core/permissions.py 149 150 151 152 153 154 155 156 157 def approval_callback_from_config () -> Callable [[ ActionStep ], bool ] | None : \"\"\"Return an approval callback based on config settings.\"\"\" mode_raw = get_config_value ( \"permissions\" , \"approval_mode\" , default = \"\" ) mode = str ( mode_raw or \"\" ) . strip () . lower () if mode in { \"allow\" , \"auto\" , \"approve\" , \"yes\" }: return lambda _ : True if mode in { \"deny\" , \"never\" , \"no\" }: return lambda _ : False return None","title":"approval_callback_from_config"},{"location":"reference/#meeseeks_core.permissions.auto_approve","text":"Approval callback that always approves. Source code in packages/meeseeks_core/src/meeseeks_core/permissions.py 160 161 162 def auto_approve ( _ : ActionStep ) -> bool : \"\"\"Approval callback that always approves.\"\"\" return True","title":"auto_approve"},{"location":"reference/#meeseeks_core.permissions.auto_deny","text":"Approval callback that always denies. Source code in packages/meeseeks_core/src/meeseeks_core/permissions.py 165 166 167 def auto_deny ( _ : ActionStep ) -> bool : \"\"\"Approval callback that always denies.\"\"\" return False","title":"auto_deny"},{"location":"reference/#meeseeks_core.permissions.load_permission_policy","text":"Load permission policy configuration from disk or defaults. Source code in packages/meeseeks_core/src/meeseeks_core/permissions.py 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 def load_permission_policy ( path : str | None = None ) -> PermissionPolicy : \"\"\"Load permission policy configuration from disk or defaults.\"\"\" if path is None : path = get_config_value ( \"permissions\" , \"policy_path\" ) if not path : return _default_policy () if not os . path . exists ( path ): logging . warning ( \"Permission policy file not found: {} \" , path ) return _default_policy () try : payload = _load_policy_data ( path ) except ( json . JSONDecodeError , OSError , tomllib . TOMLDecodeError ) as exc : logging . warning ( \"Failed to load permission policy: {} \" , exc ) return _default_policy () rules : list [ PermissionRule ] = [] for rule_data in payload . get ( \"rules\" , []): decision = _parse_decision ( rule_data . get ( \"decision\" )) if decision is None : continue rules . append ( PermissionRule ( tool_id = str ( rule_data . get ( \"tool_id\" , \"*\" )), operation = str ( rule_data . get ( \"operation\" , \"*\" )), decision = decision , ) ) default_by_operation : dict [ str , PermissionDecision ] = {} for key , value in payload . get ( \"default_by_operation\" , {}) . items (): parsed = _parse_decision ( str ( value )) if parsed is not None : default_by_operation [ str ( key )] = parsed default_decision = _parse_decision ( payload . get ( \"default_decision\" )) if default_decision is None : default_decision = PermissionDecision . ASK return PermissionPolicy ( rules = rules , default_by_operation = default_by_operation , default_decision = default_decision , )","title":"load_permission_policy"},{"location":"reference/#meeseeks_core.session_runtime","text":"Shared session runtime utilities for CLI and API.","title":"session_runtime"},{"location":"reference/#meeseeks_core.session_runtime.RunHandle","text":"Active orchestration thread tracking. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 41 42 43 44 45 46 47 @dataclass ( frozen = True ) class RunHandle : \"\"\"Active orchestration thread tracking.\"\"\" thread : threading . Thread cancel_event : threading . Event started_at : str","title":"RunHandle"},{"location":"reference/#meeseeks_core.session_runtime.RunRegistry","text":"Track active orchestration threads per session. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 class RunRegistry : \"\"\"Track active orchestration threads per session.\"\"\" def __init__ ( self ) -> None : \"\"\"Initialize the run registry.\"\"\" self . _lock = threading . Lock () self . _runs : dict [ str , RunHandle ] = {} def start ( self , session_id : str , target : Callable [[ threading . Event ], None ], ) -> bool : \"\"\"Start a new run for the session if one is not already active.\"\"\" with self . _lock : existing = self . _runs . get ( session_id ) if existing and existing . thread . is_alive (): return False cancel_event = threading . Event () thread = threading . Thread ( target = self . _wrap_run , args = ( session_id , cancel_event , target ), daemon = True , ) self . _runs [ session_id ] = RunHandle ( thread = thread , cancel_event = cancel_event , started_at = _utc_now (), ) thread . start () return True def _wrap_run ( self , session_id : str , cancel_event : threading . Event , target : Callable [[ threading . Event ], None ], ) -> None : try : target ( cancel_event ) finally : with self . _lock : handle = self . _runs . get ( session_id ) if handle and handle . thread . ident == threading . current_thread () . ident : self . _runs . pop ( session_id , None ) def cancel ( self , session_id : str ) -> bool : \"\"\"Request cancellation for an active session run.\"\"\" with self . _lock : handle = self . _runs . get ( session_id ) if not handle : return False handle . cancel_event . set () return True def is_running ( self , session_id : str ) -> bool : \"\"\"Return True if the session has an active run.\"\"\" with self . _lock : handle = self . _runs . get ( session_id ) return bool ( handle and handle . thread . is_alive ()) def get_cancel_event ( self , session_id : str ) -> threading . Event | None : \"\"\"Return the cancel event for a session, if present.\"\"\" with self . _lock : handle = self . _runs . get ( session_id ) return handle . cancel_event if handle else None","title":"RunRegistry"},{"location":"reference/#meeseeks_core.session_runtime.RunRegistry.__init__","text":"Initialize the run registry. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 53 54 55 56 def __init__ ( self ) -> None : \"\"\"Initialize the run registry.\"\"\" self . _lock = threading . Lock () self . _runs : dict [ str , RunHandle ] = {}","title":"__init__"},{"location":"reference/#meeseeks_core.session_runtime.RunRegistry.cancel","text":"Request cancellation for an active session run. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 96 97 98 99 100 101 102 103 def cancel ( self , session_id : str ) -> bool : \"\"\"Request cancellation for an active session run.\"\"\" with self . _lock : handle = self . _runs . get ( session_id ) if not handle : return False handle . cancel_event . set () return True","title":"cancel"},{"location":"reference/#meeseeks_core.session_runtime.RunRegistry.get_cancel_event","text":"Return the cancel event for a session, if present. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 111 112 113 114 115 def get_cancel_event ( self , session_id : str ) -> threading . Event | None : \"\"\"Return the cancel event for a session, if present.\"\"\" with self . _lock : handle = self . _runs . get ( session_id ) return handle . cancel_event if handle else None","title":"get_cancel_event"},{"location":"reference/#meeseeks_core.session_runtime.RunRegistry.is_running","text":"Return True if the session has an active run. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 105 106 107 108 109 def is_running ( self , session_id : str ) -> bool : \"\"\"Return True if the session has an active run.\"\"\" with self . _lock : handle = self . _runs . get ( session_id ) return bool ( handle and handle . thread . is_alive ())","title":"is_running"},{"location":"reference/#meeseeks_core.session_runtime.RunRegistry.start","text":"Start a new run for the session if one is not already active. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def start ( self , session_id : str , target : Callable [[ threading . Event ], None ], ) -> bool : \"\"\"Start a new run for the session if one is not already active.\"\"\" with self . _lock : existing = self . _runs . get ( session_id ) if existing and existing . thread . is_alive (): return False cancel_event = threading . Event () thread = threading . Thread ( target = self . _wrap_run , args = ( session_id , cancel_event , target ), daemon = True , ) self . _runs [ session_id ] = RunHandle ( thread = thread , cancel_event = cancel_event , started_at = _utc_now (), ) thread . start () return True","title":"start"},{"location":"reference/#meeseeks_core.session_runtime.SessionRuntime","text":"Shared orchestration runtime surface for CLI and API. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 class SessionRuntime : \"\"\"Shared orchestration runtime surface for CLI and API.\"\"\" def __init__ ( self , * , session_store : SessionStore | None = None , run_registry : RunRegistry | None = None , ) -> None : \"\"\"Initialize the runtime with session storage and optional run registry.\"\"\" self . _session_store = session_store or SessionStore () self . _run_registry = run_registry or RunRegistry () @property def session_store ( self ) -> SessionStore : \"\"\"Expose the underlying session store.\"\"\" return self . _session_store def resolve_session ( self , * , session_id : str | None = None , session_tag : str | None = None , fork_from : str | None = None , ) -> str : \"\"\"Resolve session identifiers, tags, and forks to a session id.\"\"\" if fork_from : source_session_id = self . _session_store . resolve_tag ( fork_from ) or fork_from session_id = self . _session_store . fork_session ( source_session_id ) if session_tag and not session_id : resolved = self . _session_store . resolve_tag ( session_tag ) session_id = resolved if resolved else None if not session_id : session_id = self . _session_store . create_session () if session_tag : self . _session_store . tag_session ( session_id , session_tag ) assert session_id is not None return session_id def append_context_event ( self , session_id : str , context : dict [ str , object ]) -> None : \"\"\"Append a context event to the session transcript.\"\"\" if not context : return self . _session_store . append_event ( session_id , { \"type\" : \"context\" , \"payload\" : context }) def summarize_session ( self , session_id : str , * , events : list [ EventRecord ] | None = None , ) -> dict [ str , object ]: \"\"\"Return a summarized view of a session.\"\"\" if events is None : events = self . _session_store . load_transcript ( session_id ) created_at = events [ 0 ][ \"ts\" ] if events else None title = None status = \"idle\" done_reason = None context : dict [ str , object ] | None = None has_user_event = False for event in events : if event . get ( \"type\" ) == \"context\" : payload = event . get ( \"payload\" ) if isinstance ( payload , dict ): context = payload if title is None and event . get ( \"type\" ) == \"user\" : has_user_event = True payload = event . get ( \"payload\" , {}) if isinstance ( payload , dict ): title = payload . get ( \"text\" ) if event . get ( \"type\" ) == \"completion\" : payload = event . get ( \"payload\" , {}) if isinstance ( payload , dict ): done_reason = payload . get ( \"done_reason\" ) status = \"completed\" if payload . get ( \"done\" ) else \"incomplete\" running = self . is_running ( session_id ) if running : status = \"running\" if not has_user_event and not running : created_at = None if not title : title = f \"Session { session_id [: 8 ] } \" return { \"session_id\" : session_id , \"title\" : title , \"created_at\" : created_at , \"status\" : status , \"done_reason\" : done_reason , \"running\" : running , \"context\" : context or {}, \"archived\" : self . _session_store . is_archived ( session_id ), } def list_sessions ( self , * , include_archived : bool = False ) -> list [ dict [ str , object ]]: \"\"\"List sessions with summary metadata.\"\"\" summaries : list [ dict [ str , object ]] = [] for session_id in self . _session_store . list_sessions (): events = self . _session_store . load_transcript ( session_id ) summary = self . summarize_session ( session_id , events = events ) has_visible_event = any ( event . get ( \"type\" ) not in { \"session\" , \"context\" } for event in events ) if not has_visible_event and not summary . get ( \"running\" ): continue if summary . get ( \"created_at\" ) is None and not summary . get ( \"running\" ): continue if not include_archived and summary . get ( \"archived\" ): continue summaries . append ( summary ) return summaries def load_events ( self , session_id : str , after : str | None = None ) -> list [ EventRecord ]: \"\"\"Load events for a session with optional timestamp filtering.\"\"\" events = self . _session_store . load_transcript ( session_id ) return _filter_events ( events , after ) def start_async ( self , * , session_id : str , user_query : str , model_name : str | None = None , max_iters : int = 3 , initial_plan : Plan | None = None , tool_registry = None , permission_policy = None , approval_callback = None , hook_manager = None , mode : str | None = None , ) -> bool : \"\"\"Start an asynchronous orchestration run for the session.\"\"\" def _run ( cancel_event : threading . Event ) -> None : self . run_sync ( user_query = user_query , session_id = session_id , model_name = model_name , max_iters = max_iters , initial_plan = initial_plan , tool_registry = tool_registry , permission_policy = permission_policy , approval_callback = approval_callback , hook_manager = hook_manager , mode = mode , should_cancel = cancel_event . is_set , ) return self . _run_registry . start ( session_id , target = _run ) def run_sync ( self , * , user_query : str , session_id : str , model_name : str | None = None , max_iters : int = 3 , initial_plan : Plan | None = None , tool_registry = None , permission_policy = None , approval_callback = None , hook_manager = None , mode : str | None = None , should_cancel : Callable [[], bool ] | None = None , ) -> TaskQueue : \"\"\"Run an orchestration request synchronously.\"\"\" return orchestrate_session ( user_query = user_query , model_name = model_name , max_iters = max_iters , initial_plan = initial_plan , session_id = session_id , session_store = self . _session_store , tool_registry = tool_registry , permission_policy = permission_policy , approval_callback = approval_callback , hook_manager = hook_manager , mode = mode , should_cancel = should_cancel , ) def cancel ( self , session_id : str ) -> bool : \"\"\"Cancel an active run if present.\"\"\" return self . _run_registry . cancel ( session_id ) def is_running ( self , session_id : str ) -> bool : \"\"\"Return True if session has an active run.\"\"\" return self . _run_registry . is_running ( session_id )","title":"SessionRuntime"},{"location":"reference/#meeseeks_core.session_runtime.SessionRuntime.session_store","text":"Expose the underlying session store.","title":"session_store"},{"location":"reference/#meeseeks_core.session_runtime.SessionRuntime.__init__","text":"Initialize the runtime with session storage and optional run registry. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 135 136 137 138 139 140 141 142 143 def __init__ ( self , * , session_store : SessionStore | None = None , run_registry : RunRegistry | None = None , ) -> None : \"\"\"Initialize the runtime with session storage and optional run registry.\"\"\" self . _session_store = session_store or SessionStore () self . _run_registry = run_registry or RunRegistry ()","title":"__init__"},{"location":"reference/#meeseeks_core.session_runtime.SessionRuntime.append_context_event","text":"Append a context event to the session transcript. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 171 172 173 174 175 def append_context_event ( self , session_id : str , context : dict [ str , object ]) -> None : \"\"\"Append a context event to the session transcript.\"\"\" if not context : return self . _session_store . append_event ( session_id , { \"type\" : \"context\" , \"payload\" : context })","title":"append_context_event"},{"location":"reference/#meeseeks_core.session_runtime.SessionRuntime.cancel","text":"Cancel an active run if present. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 312 313 314 def cancel ( self , session_id : str ) -> bool : \"\"\"Cancel an active run if present.\"\"\" return self . _run_registry . cancel ( session_id )","title":"cancel"},{"location":"reference/#meeseeks_core.session_runtime.SessionRuntime.is_running","text":"Return True if session has an active run. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 316 317 318 def is_running ( self , session_id : str ) -> bool : \"\"\"Return True if session has an active run.\"\"\" return self . _run_registry . is_running ( session_id )","title":"is_running"},{"location":"reference/#meeseeks_core.session_runtime.SessionRuntime.list_sessions","text":"List sessions with summary metadata. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 def list_sessions ( self , * , include_archived : bool = False ) -> list [ dict [ str , object ]]: \"\"\"List sessions with summary metadata.\"\"\" summaries : list [ dict [ str , object ]] = [] for session_id in self . _session_store . list_sessions (): events = self . _session_store . load_transcript ( session_id ) summary = self . summarize_session ( session_id , events = events ) has_visible_event = any ( event . get ( \"type\" ) not in { \"session\" , \"context\" } for event in events ) if not has_visible_event and not summary . get ( \"running\" ): continue if summary . get ( \"created_at\" ) is None and not summary . get ( \"running\" ): continue if not include_archived and summary . get ( \"archived\" ): continue summaries . append ( summary ) return summaries","title":"list_sessions"},{"location":"reference/#meeseeks_core.session_runtime.SessionRuntime.load_events","text":"Load events for a session with optional timestamp filtering. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 243 244 245 246 def load_events ( self , session_id : str , after : str | None = None ) -> list [ EventRecord ]: \"\"\"Load events for a session with optional timestamp filtering.\"\"\" events = self . _session_store . load_transcript ( session_id ) return _filter_events ( events , after )","title":"load_events"},{"location":"reference/#meeseeks_core.session_runtime.SessionRuntime.resolve_session","text":"Resolve session identifiers, tags, and forks to a session id. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 def resolve_session ( self , * , session_id : str | None = None , session_tag : str | None = None , fork_from : str | None = None , ) -> str : \"\"\"Resolve session identifiers, tags, and forks to a session id.\"\"\" if fork_from : source_session_id = self . _session_store . resolve_tag ( fork_from ) or fork_from session_id = self . _session_store . fork_session ( source_session_id ) if session_tag and not session_id : resolved = self . _session_store . resolve_tag ( session_tag ) session_id = resolved if resolved else None if not session_id : session_id = self . _session_store . create_session () if session_tag : self . _session_store . tag_session ( session_id , session_tag ) assert session_id is not None return session_id","title":"resolve_session"},{"location":"reference/#meeseeks_core.session_runtime.SessionRuntime.run_sync","text":"Run an orchestration request synchronously. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 def run_sync ( self , * , user_query : str , session_id : str , model_name : str | None = None , max_iters : int = 3 , initial_plan : Plan | None = None , tool_registry = None , permission_policy = None , approval_callback = None , hook_manager = None , mode : str | None = None , should_cancel : Callable [[], bool ] | None = None , ) -> TaskQueue : \"\"\"Run an orchestration request synchronously.\"\"\" return orchestrate_session ( user_query = user_query , model_name = model_name , max_iters = max_iters , initial_plan = initial_plan , session_id = session_id , session_store = self . _session_store , tool_registry = tool_registry , permission_policy = permission_policy , approval_callback = approval_callback , hook_manager = hook_manager , mode = mode , should_cancel = should_cancel , )","title":"run_sync"},{"location":"reference/#meeseeks_core.session_runtime.SessionRuntime.start_async","text":"Start an asynchronous orchestration run for the session. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 def start_async ( self , * , session_id : str , user_query : str , model_name : str | None = None , max_iters : int = 3 , initial_plan : Plan | None = None , tool_registry = None , permission_policy = None , approval_callback = None , hook_manager = None , mode : str | None = None , ) -> bool : \"\"\"Start an asynchronous orchestration run for the session.\"\"\" def _run ( cancel_event : threading . Event ) -> None : self . run_sync ( user_query = user_query , session_id = session_id , model_name = model_name , max_iters = max_iters , initial_plan = initial_plan , tool_registry = tool_registry , permission_policy = permission_policy , approval_callback = approval_callback , hook_manager = hook_manager , mode = mode , should_cancel = cancel_event . is_set , ) return self . _run_registry . start ( session_id , target = _run )","title":"start_async"},{"location":"reference/#meeseeks_core.session_runtime.SessionRuntime.summarize_session","text":"Return a summarized view of a session. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 def summarize_session ( self , session_id : str , * , events : list [ EventRecord ] | None = None , ) -> dict [ str , object ]: \"\"\"Return a summarized view of a session.\"\"\" if events is None : events = self . _session_store . load_transcript ( session_id ) created_at = events [ 0 ][ \"ts\" ] if events else None title = None status = \"idle\" done_reason = None context : dict [ str , object ] | None = None has_user_event = False for event in events : if event . get ( \"type\" ) == \"context\" : payload = event . get ( \"payload\" ) if isinstance ( payload , dict ): context = payload if title is None and event . get ( \"type\" ) == \"user\" : has_user_event = True payload = event . get ( \"payload\" , {}) if isinstance ( payload , dict ): title = payload . get ( \"text\" ) if event . get ( \"type\" ) == \"completion\" : payload = event . get ( \"payload\" , {}) if isinstance ( payload , dict ): done_reason = payload . get ( \"done_reason\" ) status = \"completed\" if payload . get ( \"done\" ) else \"incomplete\" running = self . is_running ( session_id ) if running : status = \"running\" if not has_user_event and not running : created_at = None if not title : title = f \"Session { session_id [: 8 ] } \" return { \"session_id\" : session_id , \"title\" : title , \"created_at\" : created_at , \"status\" : status , \"done_reason\" : done_reason , \"running\" : running , \"context\" : context or {}, \"archived\" : self . _session_store . is_archived ( session_id ), }","title":"summarize_session"},{"location":"reference/#meeseeks_core.session_runtime.parse_core_command","text":"Return the core command token if present. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 33 34 35 36 37 38 def parse_core_command ( text : str ) -> str | None : \"\"\"Return the core command token if present.\"\"\" if not text : return None command = text . strip () . lower () . split ()[ 0 ] return command if command in CORE_COMMANDS else None","title":"parse_core_command"},{"location":"reference/#meeseeks_core.session_store","text":"Session transcript storage and management.","title":"session_store"},{"location":"reference/#meeseeks_core.session_store.SessionPaths","text":"Resolved filesystem paths for a session. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 @dataclass ( frozen = True ) class SessionPaths : \"\"\"Resolved filesystem paths for a session.\"\"\" root : str session_id : str @property def session_dir ( self ) -> str : \"\"\"Directory for session artifacts.\"\"\" return os . path . join ( self . root , self . session_id ) @property def transcript_path ( self ) -> str : \"\"\"Path to the JSONL transcript file.\"\"\" return os . path . join ( self . session_dir , \"transcript.jsonl\" ) @property def summary_path ( self ) -> str : \"\"\"Path to the summary JSON file.\"\"\" return os . path . join ( self . session_dir , \"summary.json\" )","title":"SessionPaths"},{"location":"reference/#meeseeks_core.session_store.SessionPaths.session_dir","text":"Directory for session artifacts.","title":"session_dir"},{"location":"reference/#meeseeks_core.session_store.SessionPaths.summary_path","text":"Path to the summary JSON file.","title":"summary_path"},{"location":"reference/#meeseeks_core.session_store.SessionPaths.transcript_path","text":"Path to the JSONL transcript file.","title":"transcript_path"},{"location":"reference/#meeseeks_core.session_store.SessionStore","text":"Filesystem-backed storage for session transcripts and summaries. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 class SessionStore : \"\"\"Filesystem-backed storage for session transcripts and summaries.\"\"\" def __init__ ( self , root_dir : str | None = None ) -> None : \"\"\"Initialize the store and ensure the root directory exists.\"\"\" if root_dir is None : root_dir = get_config_value ( \"runtime\" , \"session_dir\" , default = \"./data/sessions\" ) self . root_dir = os . path . abspath ( root_dir ) os . makedirs ( self . root_dir , exist_ok = True ) def _index_path ( self ) -> str : \"\"\"Return the path for the session index file.\"\"\" return os . path . join ( self . root_dir , \"index.json\" ) def _load_index ( self ) -> dict [ str , dict [ str , str ]]: \"\"\"Load the session index from disk or return defaults.\"\"\" index_path = self . _index_path () if not os . path . exists ( index_path ): return { \"tags\" : {}, \"archived\" : {}} with open ( index_path , encoding = \"utf-8\" ) as handle : return json . load ( handle ) def _save_index ( self , data : dict [ str , dict [ str , str ]]) -> None : \"\"\"Persist the session index to disk.\"\"\" with open ( self . _index_path (), \"w\" , encoding = \"utf-8\" ) as handle : json . dump ( data , handle , indent = 2 ) def create_session ( self ) -> str : \"\"\"Create a new session directory and return its identifier.\"\"\" session_id = uuid . uuid4 () . hex paths = self . _paths ( session_id ) os . makedirs ( paths . session_dir , exist_ok = True ) return session_id def _paths ( self , session_id : str ) -> SessionPaths : \"\"\"Build filesystem paths for a session.\"\"\" return SessionPaths ( root = self . root_dir , session_id = session_id ) def append_event ( self , session_id : str , event : Event ) -> None : \"\"\"Append a single event record to the session transcript.\"\"\" paths = self . _paths ( session_id ) os . makedirs ( paths . session_dir , exist_ok = True ) payload : EventRecord = { \"ts\" : _utc_now (), ** event } with open ( paths . transcript_path , \"a\" , encoding = \"utf-8\" ) as handle : handle . write ( json . dumps ( payload ) + \" \\n \" ) def load_transcript ( self , session_id : str ) -> list [ EventRecord ]: \"\"\"Load all transcript events for a session.\"\"\" paths = self . _paths ( session_id ) if not os . path . exists ( paths . transcript_path ): return [] events : list [ EventRecord ] = [] with open ( paths . transcript_path , encoding = \"utf-8\" ) as handle : for line in handle : line = line . strip () if not line : continue try : events . append ( json . loads ( line )) except json . JSONDecodeError : logging . warning ( \"Skipping malformed transcript line.\" ) return events def load_recent_events ( self , session_id : str , limit : int = 8 , include_types : set [ str ] | None = None , ) -> list [ EventRecord ]: \"\"\"Load the most recent events, optionally filtered by type.\"\"\" events = self . load_transcript ( session_id ) if include_types : events = [ event for event in events if event . get ( \"type\" ) in include_types ] if limit <= 0 : return [] return events [ - limit :] def save_summary ( self , session_id : str , summary : str ) -> None : \"\"\"Persist a summary for a session.\"\"\" paths = self . _paths ( session_id ) os . makedirs ( paths . session_dir , exist_ok = True ) with open ( paths . summary_path , \"w\" , encoding = \"utf-8\" ) as handle : json . dump ({ \"summary\" : summary , \"updated_at\" : _utc_now ()}, handle , indent = 2 ) def load_summary ( self , session_id : str ) -> str | None : \"\"\"Load a previously saved summary, if present.\"\"\" paths = self . _paths ( session_id ) if not os . path . exists ( paths . summary_path ): return None with open ( paths . summary_path , encoding = \"utf-8\" ) as handle : data = json . load ( handle ) return data . get ( \"summary\" ) def list_sessions ( self ) -> list [ str ]: \"\"\"List all session IDs present in the root directory.\"\"\" if not os . path . exists ( self . root_dir ): return [] return sorted ( name for name in os . listdir ( self . root_dir ) if os . path . isdir ( os . path . join ( self . root_dir , name )) ) def fork_session ( self , source_session_id : str ) -> str : \"\"\"Create a new session by copying events and summary from another.\"\"\" events = self . load_transcript ( source_session_id ) summary = self . load_summary ( source_session_id ) new_session_id = self . create_session () for event in events : self . append_event ( new_session_id , event ) if summary : self . save_summary ( new_session_id , summary ) return new_session_id def tag_session ( self , session_id : str , tag : str ) -> None : \"\"\"Associate a tag with a session ID for quick lookup.\"\"\" index = self . _load_index () index . setdefault ( \"tags\" , {})[ tag ] = session_id self . _save_index ( index ) def resolve_tag ( self , tag : str ) -> str | None : \"\"\"Resolve a tag to a session ID, if present.\"\"\" index = self . _load_index () return index . get ( \"tags\" , {}) . get ( tag ) def list_tags ( self ) -> dict [ str , str ]: \"\"\"Return a mapping of tags to session IDs.\"\"\" index = self . _load_index () return dict ( index . get ( \"tags\" , {})) def archive_session ( self , session_id : str ) -> None : \"\"\"Mark a session as archived.\"\"\" index = self . _load_index () archived = index . setdefault ( \"archived\" , {}) archived [ session_id ] = _utc_now () self . _save_index ( index ) def unarchive_session ( self , session_id : str ) -> None : \"\"\"Remove archived status from a session.\"\"\" index = self . _load_index () archived = index . get ( \"archived\" , {}) if session_id in archived : archived . pop ( session_id , None ) index [ \"archived\" ] = archived self . _save_index ( index ) def is_archived ( self , session_id : str ) -> bool : \"\"\"Return True if a session is archived.\"\"\" index = self . _load_index () archived = index . get ( \"archived\" , {}) return session_id in archived","title":"SessionStore"},{"location":"reference/#meeseeks_core.session_store.SessionStore.__init__","text":"Initialize the store and ensure the root directory exists. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 50 51 52 53 54 55 def __init__ ( self , root_dir : str | None = None ) -> None : \"\"\"Initialize the store and ensure the root directory exists.\"\"\" if root_dir is None : root_dir = get_config_value ( \"runtime\" , \"session_dir\" , default = \"./data/sessions\" ) self . root_dir = os . path . abspath ( root_dir ) os . makedirs ( self . root_dir , exist_ok = True )","title":"__init__"},{"location":"reference/#meeseeks_core.session_store.SessionStore.append_event","text":"Append a single event record to the session transcript. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 85 86 87 88 89 90 91 def append_event ( self , session_id : str , event : Event ) -> None : \"\"\"Append a single event record to the session transcript.\"\"\" paths = self . _paths ( session_id ) os . makedirs ( paths . session_dir , exist_ok = True ) payload : EventRecord = { \"ts\" : _utc_now (), ** event } with open ( paths . transcript_path , \"a\" , encoding = \"utf-8\" ) as handle : handle . write ( json . dumps ( payload ) + \" \\n \" )","title":"append_event"},{"location":"reference/#meeseeks_core.session_store.SessionStore.archive_session","text":"Mark a session as archived. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 177 178 179 180 181 182 def archive_session ( self , session_id : str ) -> None : \"\"\"Mark a session as archived.\"\"\" index = self . _load_index () archived = index . setdefault ( \"archived\" , {}) archived [ session_id ] = _utc_now () self . _save_index ( index )","title":"archive_session"},{"location":"reference/#meeseeks_core.session_store.SessionStore.create_session","text":"Create a new session directory and return its identifier. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 74 75 76 77 78 79 def create_session ( self ) -> str : \"\"\"Create a new session directory and return its identifier.\"\"\" session_id = uuid . uuid4 () . hex paths = self . _paths ( session_id ) os . makedirs ( paths . session_dir , exist_ok = True ) return session_id","title":"create_session"},{"location":"reference/#meeseeks_core.session_store.SessionStore.fork_session","text":"Create a new session by copying events and summary from another. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 150 151 152 153 154 155 156 157 158 159 def fork_session ( self , source_session_id : str ) -> str : \"\"\"Create a new session by copying events and summary from another.\"\"\" events = self . load_transcript ( source_session_id ) summary = self . load_summary ( source_session_id ) new_session_id = self . create_session () for event in events : self . append_event ( new_session_id , event ) if summary : self . save_summary ( new_session_id , summary ) return new_session_id","title":"fork_session"},{"location":"reference/#meeseeks_core.session_store.SessionStore.is_archived","text":"Return True if a session is archived. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 193 194 195 196 197 def is_archived ( self , session_id : str ) -> bool : \"\"\"Return True if a session is archived.\"\"\" index = self . _load_index () archived = index . get ( \"archived\" , {}) return session_id in archived","title":"is_archived"},{"location":"reference/#meeseeks_core.session_store.SessionStore.list_sessions","text":"List all session IDs present in the root directory. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 140 141 142 143 144 145 146 147 148 def list_sessions ( self ) -> list [ str ]: \"\"\"List all session IDs present in the root directory.\"\"\" if not os . path . exists ( self . root_dir ): return [] return sorted ( name for name in os . listdir ( self . root_dir ) if os . path . isdir ( os . path . join ( self . root_dir , name )) )","title":"list_sessions"},{"location":"reference/#meeseeks_core.session_store.SessionStore.list_tags","text":"Return a mapping of tags to session IDs. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 172 173 174 175 def list_tags ( self ) -> dict [ str , str ]: \"\"\"Return a mapping of tags to session IDs.\"\"\" index = self . _load_index () return dict ( index . get ( \"tags\" , {}))","title":"list_tags"},{"location":"reference/#meeseeks_core.session_store.SessionStore.load_recent_events","text":"Load the most recent events, optionally filtered by type. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 110 111 112 113 114 115 116 117 118 119 120 121 122 def load_recent_events ( self , session_id : str , limit : int = 8 , include_types : set [ str ] | None = None , ) -> list [ EventRecord ]: \"\"\"Load the most recent events, optionally filtered by type.\"\"\" events = self . load_transcript ( session_id ) if include_types : events = [ event for event in events if event . get ( \"type\" ) in include_types ] if limit <= 0 : return [] return events [ - limit :]","title":"load_recent_events"},{"location":"reference/#meeseeks_core.session_store.SessionStore.load_summary","text":"Load a previously saved summary, if present. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 131 132 133 134 135 136 137 138 def load_summary ( self , session_id : str ) -> str | None : \"\"\"Load a previously saved summary, if present.\"\"\" paths = self . _paths ( session_id ) if not os . path . exists ( paths . summary_path ): return None with open ( paths . summary_path , encoding = \"utf-8\" ) as handle : data = json . load ( handle ) return data . get ( \"summary\" )","title":"load_summary"},{"location":"reference/#meeseeks_core.session_store.SessionStore.load_transcript","text":"Load all transcript events for a session. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 def load_transcript ( self , session_id : str ) -> list [ EventRecord ]: \"\"\"Load all transcript events for a session.\"\"\" paths = self . _paths ( session_id ) if not os . path . exists ( paths . transcript_path ): return [] events : list [ EventRecord ] = [] with open ( paths . transcript_path , encoding = \"utf-8\" ) as handle : for line in handle : line = line . strip () if not line : continue try : events . append ( json . loads ( line )) except json . JSONDecodeError : logging . warning ( \"Skipping malformed transcript line.\" ) return events","title":"load_transcript"},{"location":"reference/#meeseeks_core.session_store.SessionStore.resolve_tag","text":"Resolve a tag to a session ID, if present. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 167 168 169 170 def resolve_tag ( self , tag : str ) -> str | None : \"\"\"Resolve a tag to a session ID, if present.\"\"\" index = self . _load_index () return index . get ( \"tags\" , {}) . get ( tag )","title":"resolve_tag"},{"location":"reference/#meeseeks_core.session_store.SessionStore.save_summary","text":"Persist a summary for a session. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 124 125 126 127 128 129 def save_summary ( self , session_id : str , summary : str ) -> None : \"\"\"Persist a summary for a session.\"\"\" paths = self . _paths ( session_id ) os . makedirs ( paths . session_dir , exist_ok = True ) with open ( paths . summary_path , \"w\" , encoding = \"utf-8\" ) as handle : json . dump ({ \"summary\" : summary , \"updated_at\" : _utc_now ()}, handle , indent = 2 )","title":"save_summary"},{"location":"reference/#meeseeks_core.session_store.SessionStore.tag_session","text":"Associate a tag with a session ID for quick lookup. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 161 162 163 164 165 def tag_session ( self , session_id : str , tag : str ) -> None : \"\"\"Associate a tag with a session ID for quick lookup.\"\"\" index = self . _load_index () index . setdefault ( \"tags\" , {})[ tag ] = session_id self . _save_index ( index )","title":"tag_session"},{"location":"reference/#meeseeks_core.session_store.SessionStore.unarchive_session","text":"Remove archived status from a session. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 184 185 186 187 188 189 190 191 def unarchive_session ( self , session_id : str ) -> None : \"\"\"Remove archived status from a session.\"\"\" index = self . _load_index () archived = index . get ( \"archived\" , {}) if session_id in archived : archived . pop ( session_id , None ) index [ \"archived\" ] = archived self . _save_index ( index )","title":"unarchive_session"},{"location":"reference/#meeseeks_core.task_master","text":"Task planning and orchestration loop for Meeseeks.","title":"task_master"},{"location":"reference/#meeseeks_core.task_master.generate_action_plan","text":"Generate a plan for a user query. Source code in packages/meeseeks_core/src/meeseeks_core/task_master.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 def generate_action_plan ( user_query : str , model_name : str | None = None , tool_registry : ToolRegistry | None = None , session_summary : str | None = None , recent_events : list [ EventRecord ] | None = None , selected_events : list [ EventRecord ] | None = None , * , mode : str = \"act\" , ) -> Plan : \"\"\"Generate a plan for a user query.\"\"\" tool_registry = tool_registry or load_registry () resolved_model = cast ( str , model_name or get_config_value ( \"llm\" , \"action_plan_model\" ) or get_config_value ( \"llm\" , \"default_model\" , default = \"gpt-5.2\" ), ) context = _build_context_snapshot ( session_summary , recent_events , selected_events , resolved_model , ) return Planner ( tool_registry ) . generate ( user_query , resolved_model , context = context , mode = mode )","title":"generate_action_plan"},{"location":"reference/#meeseeks_core.task_master.orchestrate_session","text":"Run the plan-act-observe orchestration loop. Source code in packages/meeseeks_core/src/meeseeks_core/task_master.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 def orchestrate_session ( user_query : str , model_name : str | None = None , max_iters : int = 3 , initial_plan : Plan | None = None , return_state : bool = False , session_id : str | None = None , session_store : SessionStore | None = None , tool_registry : ToolRegistry | None = None , permission_policy : PermissionPolicy | None = None , approval_callback : Callable [[ ActionStep ], bool ] | None = None , hook_manager : HookManager | None = None , mode : str | None = None , should_cancel : Callable [[], bool ] | None = None , ) -> TaskQueue | tuple [ TaskQueue , OrchestrationState ]: \"\"\"Run the plan-act-observe orchestration loop.\"\"\" return Orchestrator ( model_name = model_name , session_store = session_store , tool_registry = tool_registry , permission_policy = permission_policy , approval_callback = approval_callback , hook_manager = hook_manager , ) . run ( user_query , max_iters = max_iters , initial_plan = initial_plan , return_state = return_state , session_id = session_id , mode = mode , should_cancel = should_cancel , )","title":"orchestrate_session"},{"location":"reference/#meeseeks_core.task_master.run_action_plan","text":"Execute a task queue with permissions and hooks. Source code in packages/meeseeks_core/src/meeseeks_core/task_master.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 def run_action_plan ( task_queue : TaskQueue , tool_registry : ToolRegistry | None = None , event_logger : Callable [[ Event ], None ] | None = None , permission_policy : PermissionPolicy | None = None , approval_callback : Callable [[ ActionStep ], bool ] | None = None , hook_manager : HookManager | None = None , model_name : str | None = None , * , mode : str = \"act\" , ) -> TaskQueue : \"\"\"Execute a task queue with permissions and hooks.\"\"\" tool_registry = tool_registry or load_registry () permission_policy = permission_policy or load_permission_policy () approval_callback = approval_callback or approval_callback_from_config () hook_manager = hook_manager or default_hook_manager () runner = ActionPlanRunner ( tool_registry = tool_registry , permission_policy = permission_policy , approval_callback = approval_callback , hook_manager = hook_manager , event_logger = event_logger , reflector = StepReflector ( model_name ), mode = mode , ) return runner . run ( task_queue )","title":"run_action_plan"},{"location":"reference/#meeseeks_core.token_budget","text":"Token budgeting utilities.","title":"token_budget"},{"location":"reference/#meeseeks_core.token_budget.TokenBudget","text":"Token accounting snapshot used to decide compaction. Source code in packages/meeseeks_core/src/meeseeks_core/token_budget.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @dataclass ( frozen = True ) class TokenBudget : \"\"\"Token accounting snapshot used to decide compaction.\"\"\" total_tokens : int summary_tokens : int event_tokens : int context_window : int remaining_tokens : int utilization : float threshold : float @property def needs_compact ( self ) -> bool : \"\"\"Return True when utilization exceeds the configured threshold.\"\"\" return self . utilization >= self . threshold","title":"TokenBudget"},{"location":"reference/#meeseeks_core.token_budget.TokenBudget.needs_compact","text":"Return True when utilization exceeds the configured threshold.","title":"needs_compact"},{"location":"reference/#meeseeks_core.token_budget.estimate_event_tokens","text":"Estimate total tokens for a sequence of events. Source code in packages/meeseeks_core/src/meeseeks_core/token_budget.py 84 85 86 87 88 89 90 def estimate_event_tokens ( events : Iterable [ EventRecord ]) -> int : \"\"\"Estimate total tokens for a sequence of events.\"\"\" texts = [ _event_to_text ( event ) for event in events ] joined = \" \\n \" . join ( text for text in texts if text ) if not joined : return 0 return num_tokens_from_string ( joined )","title":"estimate_event_tokens"},{"location":"reference/#meeseeks_core.token_budget.estimate_summary_tokens","text":"Estimate token usage for the stored summary. Source code in packages/meeseeks_core/src/meeseeks_core/token_budget.py 93 94 95 96 97 def estimate_summary_tokens ( summary : str | None ) -> int : \"\"\"Estimate token usage for the stored summary.\"\"\" if not summary : return 0 return num_tokens_from_string ( summary )","title":"estimate_summary_tokens"},{"location":"reference/#meeseeks_core.token_budget.get_context_window","text":"Resolve the context window for a model name or default. Source code in packages/meeseeks_core/src/meeseeks_core/token_budget.py 58 59 60 61 62 63 64 65 66 67 68 69 def get_context_window ( model_name : str | None ) -> int : \"\"\"Resolve the context window for a model name or default.\"\"\" default_window = int ( get_config_value ( \"token_budget\" , \"default_context_window\" , default = 128000 )) if not model_name : return default_window overrides = _load_context_overrides () if model_name in overrides : return overrides [ model_name ] parsed = _parse_context_from_model ( model_name ) if parsed : return parsed return default_window","title":"get_context_window"},{"location":"reference/#meeseeks_core.token_budget.get_token_budget","text":"Calculate token utilization and remaining context budget. Source code in packages/meeseeks_core/src/meeseeks_core/token_budget.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 def get_token_budget ( events : Iterable [ EventRecord ], summary : str | None , model_name : str | None , threshold : float | None = None , ) -> TokenBudget : \"\"\"Calculate token utilization and remaining context budget.\"\"\" event_tokens = estimate_event_tokens ( events ) summary_tokens = estimate_summary_tokens ( summary ) total_tokens = event_tokens + summary_tokens context_window = get_context_window ( model_name ) remaining_tokens = max ( context_window - total_tokens , 0 ) if threshold is None : threshold = float ( get_config_value ( \"token_budget\" , \"auto_compact_threshold\" , default = 0.8 )) utilization = total_tokens / context_window if context_window else 0.0 return TokenBudget ( total_tokens = total_tokens , summary_tokens = summary_tokens , event_tokens = event_tokens , context_window = context_window , remaining_tokens = remaining_tokens , utilization = utilization , threshold = threshold , )","title":"get_token_budget"},{"location":"reference/#meeseeks_core.tool_registry","text":"Tool registry and manifest loading for Meeseeks.","title":"tool_registry"},{"location":"reference/#meeseeks_core.tool_registry.ToolRegistry","text":"Registry of configured tools and their instantiated runners. Source code in packages/meeseeks_core/src/meeseeks_core/tool_registry.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 class ToolRegistry : \"\"\"Registry of configured tools and their instantiated runners.\"\"\" def __init__ ( self ) -> None : \"\"\"Initialize an empty registry.\"\"\" self . _tools : dict [ str , ToolSpec ] = {} self . _instances : dict [ str , ToolRunner ] = {} def disable ( self , tool_id : str , reason : str ) -> None : \"\"\"Disable a tool and store a reason for later reporting.\"\"\" spec = self . _tools . get ( tool_id ) if spec is None : return metadata = dict ( spec . metadata ) metadata [ \"disabled_reason\" ] = reason self . _tools [ tool_id ] = ToolSpec ( tool_id = spec . tool_id , name = spec . name , description = spec . description , factory = spec . factory , enabled = False , kind = spec . kind , prompt_path = spec . prompt_path , metadata = metadata , ) if tool_id in self . _instances : self . _instances . pop ( tool_id , None ) set_available_tools ( [ current_id for current_id , current_spec in self . _tools . items () if current_spec . enabled ] ) def register ( self , spec : ToolSpec ) -> None : \"\"\"Register a tool specification and update action validation.\"\"\" self . _tools [ spec . tool_id ] = spec set_available_tools ( [ tool_id for tool_id , tool_spec in self . _tools . items () if tool_spec . enabled ] ) def get ( self , tool_id : str ) -> ToolRunner | None : \"\"\"Return an enabled tool runner, instantiating it if needed.\"\"\" spec = self . _tools . get ( tool_id ) if spec is None or not spec . enabled : return None if tool_id not in self . _instances : try : self . _instances [ tool_id ] = spec . factory () except Exception as exc : # pragma: no cover - defensive reason = f \"Initialization failed: { exc } \" logging . warning ( \"Disabling tool {} : {} \" , tool_id , reason ) self . disable ( tool_id , reason ) return None return self . _instances [ tool_id ] def get_spec ( self , tool_id : str ) -> ToolSpec | None : \"\"\"Return the tool specification, even if disabled.\"\"\" return self . _tools . get ( tool_id ) def list_specs ( self , include_disabled : bool = False ) -> list [ ToolSpec ]: \"\"\"List tool specifications, optionally including disabled tools.\"\"\" specs = list ( self . _tools . values ()) if include_disabled : return specs return [ spec for spec in specs if spec . enabled ] def list_specs_for_mode ( self , mode : str , * , include_disabled : bool = False ) -> list [ ToolSpec ]: \"\"\"List specs filtered by orchestration mode.\"\"\" specs = self . list_specs ( include_disabled = include_disabled ) if mode != \"plan\" : return specs return [ spec for spec in specs if spec . is_plan_safe ()] def tool_catalog ( self ) -> list [ dict [ str , str ]]: \"\"\"Return a serialized catalog of registered tool metadata.\"\"\" return [ { \"tool_id\" : spec . tool_id , \"name\" : spec . name , \"description\" : spec . description , } for spec in self . list_specs () ]","title":"ToolRegistry"},{"location":"reference/#meeseeks_core.tool_registry.ToolRegistry.__init__","text":"Initialize an empty registry. Source code in packages/meeseeks_core/src/meeseeks_core/tool_registry.py 65 66 67 68 def __init__ ( self ) -> None : \"\"\"Initialize an empty registry.\"\"\" self . _tools : dict [ str , ToolSpec ] = {} self . _instances : dict [ str , ToolRunner ] = {}","title":"__init__"},{"location":"reference/#meeseeks_core.tool_registry.ToolRegistry.disable","text":"Disable a tool and store a reason for later reporting. Source code in packages/meeseeks_core/src/meeseeks_core/tool_registry.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 def disable ( self , tool_id : str , reason : str ) -> None : \"\"\"Disable a tool and store a reason for later reporting.\"\"\" spec = self . _tools . get ( tool_id ) if spec is None : return metadata = dict ( spec . metadata ) metadata [ \"disabled_reason\" ] = reason self . _tools [ tool_id ] = ToolSpec ( tool_id = spec . tool_id , name = spec . name , description = spec . description , factory = spec . factory , enabled = False , kind = spec . kind , prompt_path = spec . prompt_path , metadata = metadata , ) if tool_id in self . _instances : self . _instances . pop ( tool_id , None ) set_available_tools ( [ current_id for current_id , current_spec in self . _tools . items () if current_spec . enabled ] )","title":"disable"},{"location":"reference/#meeseeks_core.tool_registry.ToolRegistry.get","text":"Return an enabled tool runner, instantiating it if needed. Source code in packages/meeseeks_core/src/meeseeks_core/tool_registry.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 def get ( self , tool_id : str ) -> ToolRunner | None : \"\"\"Return an enabled tool runner, instantiating it if needed.\"\"\" spec = self . _tools . get ( tool_id ) if spec is None or not spec . enabled : return None if tool_id not in self . _instances : try : self . _instances [ tool_id ] = spec . factory () except Exception as exc : # pragma: no cover - defensive reason = f \"Initialization failed: { exc } \" logging . warning ( \"Disabling tool {} : {} \" , tool_id , reason ) self . disable ( tool_id , reason ) return None return self . _instances [ tool_id ]","title":"get"},{"location":"reference/#meeseeks_core.tool_registry.ToolRegistry.get_spec","text":"Return the tool specification, even if disabled. Source code in packages/meeseeks_core/src/meeseeks_core/tool_registry.py 115 116 117 def get_spec ( self , tool_id : str ) -> ToolSpec | None : \"\"\"Return the tool specification, even if disabled.\"\"\" return self . _tools . get ( tool_id )","title":"get_spec"},{"location":"reference/#meeseeks_core.tool_registry.ToolRegistry.list_specs","text":"List tool specifications, optionally including disabled tools. Source code in packages/meeseeks_core/src/meeseeks_core/tool_registry.py 119 120 121 122 123 124 def list_specs ( self , include_disabled : bool = False ) -> list [ ToolSpec ]: \"\"\"List tool specifications, optionally including disabled tools.\"\"\" specs = list ( self . _tools . values ()) if include_disabled : return specs return [ spec for spec in specs if spec . enabled ]","title":"list_specs"},{"location":"reference/#meeseeks_core.tool_registry.ToolRegistry.list_specs_for_mode","text":"List specs filtered by orchestration mode. Source code in packages/meeseeks_core/src/meeseeks_core/tool_registry.py 126 127 128 129 130 131 def list_specs_for_mode ( self , mode : str , * , include_disabled : bool = False ) -> list [ ToolSpec ]: \"\"\"List specs filtered by orchestration mode.\"\"\" specs = self . list_specs ( include_disabled = include_disabled ) if mode != \"plan\" : return specs return [ spec for spec in specs if spec . is_plan_safe ()]","title":"list_specs_for_mode"},{"location":"reference/#meeseeks_core.tool_registry.ToolRegistry.register","text":"Register a tool specification and update action validation. Source code in packages/meeseeks_core/src/meeseeks_core/tool_registry.py 93 94 95 96 97 98 def register ( self , spec : ToolSpec ) -> None : \"\"\"Register a tool specification and update action validation.\"\"\" self . _tools [ spec . tool_id ] = spec set_available_tools ( [ tool_id for tool_id , tool_spec in self . _tools . items () if tool_spec . enabled ] )","title":"register"},{"location":"reference/#meeseeks_core.tool_registry.ToolRegistry.tool_catalog","text":"Return a serialized catalog of registered tool metadata. Source code in packages/meeseeks_core/src/meeseeks_core/tool_registry.py 133 134 135 136 137 138 139 140 141 142 def tool_catalog ( self ) -> list [ dict [ str , str ]]: \"\"\"Return a serialized catalog of registered tool metadata.\"\"\" return [ { \"tool_id\" : spec . tool_id , \"name\" : spec . name , \"description\" : spec . description , } for spec in self . list_specs () ]","title":"tool_catalog"},{"location":"reference/#meeseeks_core.tool_registry.ToolRunner","text":"Bases: Protocol Source code in packages/meeseeks_core/src/meeseeks_core/tool_registry.py 32 33 34 35 36 37 38 39 40 41 class ToolRunner ( Protocol ): def run ( self , action_step : ActionStep ) -> MockSpeaker : # pragma: no cover \"\"\"Execute an action step and return a speaker response. Args: action_step: Action step payload to execute. Returns: MockSpeaker response from the tool. \"\"\"","title":"ToolRunner"},{"location":"reference/#meeseeks_core.tool_registry.ToolRunner.run","text":"Execute an action step and return a speaker response. Parameters: Name Type Description Default action_step ActionStep Action step payload to execute. required Returns: Type Description MockSpeaker MockSpeaker response from the tool. Source code in packages/meeseeks_core/src/meeseeks_core/tool_registry.py 33 34 35 36 37 38 39 40 41 def run ( self , action_step : ActionStep ) -> MockSpeaker : # pragma: no cover \"\"\"Execute an action step and return a speaker response. Args: action_step: Action step payload to execute. Returns: MockSpeaker response from the tool. \"\"\"","title":"run"},{"location":"reference/#meeseeks_core.tool_registry.ToolSpec","text":"Metadata describing a tool available to the assistant. Source code in packages/meeseeks_core/src/meeseeks_core/tool_registry.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 @dataclass ( frozen = True ) class ToolSpec : \"\"\"Metadata describing a tool available to the assistant.\"\"\" tool_id : str name : str description : str factory : Callable [[], ToolRunner ] enabled : bool = True kind : str = \"local\" prompt_path : str | None = None metadata : dict [ str , JsonValue ] = field ( default_factory = dict ) def is_plan_safe ( self ) -> bool : \"\"\"Return True if the tool is safe to use in plan mode.\"\"\" return bool ( self . metadata . get ( \"plan_safe\" ))","title":"ToolSpec"},{"location":"reference/#meeseeks_core.tool_registry.ToolSpec.is_plan_safe","text":"Return True if the tool is safe to use in plan mode. Source code in packages/meeseeks_core/src/meeseeks_core/tool_registry.py 57 58 59 def is_plan_safe ( self ) -> bool : \"\"\"Return True if the tool is safe to use in plan mode.\"\"\" return bool ( self . metadata . get ( \"plan_safe\" ))","title":"is_plan_safe"},{"location":"reference/#meeseeks_core.tool_registry.load_registry","text":"Load tool registry, auto-discovering MCP tools when configured. Source code in packages/meeseeks_core/src/meeseeks_core/tool_registry.py 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 def load_registry ( manifest_path : str | None = None ) -> ToolRegistry : \"\"\"Load tool registry, auto-discovering MCP tools when configured.\"\"\" if manifest_path is None : mcp_config_path = get_mcp_config_path () if mcp_config_path and os . path . exists ( mcp_config_path ): manifest_path = _ensure_auto_manifest ( mcp_config_path ) if not manifest_path : return _default_registry () manifest_path = os . path . abspath ( manifest_path ) if not os . path . exists ( manifest_path ): logging . warning ( \"Tool manifest not found: {} \" , manifest_path ) return _default_registry () try : with open ( manifest_path , encoding = \"utf-8\" ) as handle : manifest = json . load ( handle ) except Exception as exc : # pragma: no cover - defensive logging . error ( \"Failed to load tool manifest: {} \" , exc ) return _default_registry () registry = ToolRegistry () for tool in manifest . get ( \"tools\" , []): kind = tool . get ( \"kind\" , \"local\" ) prompt_path = tool . get ( \"prompt\" ) if kind == \"local\" : module_path = tool . get ( \"module\" ) class_name = tool . get ( \"class\" ) if not module_path or not class_name : logging . warning ( \"Skipping tool with missing module/class: {} \" , tool ) continue factory = _import_factory ( module_path , class_name ) else : mcp_module = _load_mcp_support () if mcp_module is None : logging . warning ( \"Skipping MCP tool because MCP support is not installed: {} \" , tool , ) continue MCPToolRunner = mcp_module . MCPToolRunner server_name = tool . get ( \"server\" ) tool_name = tool . get ( \"tool\" ) if not server_name or not tool_name : logging . warning ( \"Skipping MCP tool with missing server/tool: {} \" , tool ) continue def _mcp_factory ( server_name : str = server_name , tool_name : str = tool_name , ) -> ToolRunner : return MCPToolRunner ( server_name = server_name , tool_name = tool_name ) factory = _mcp_factory spec = ToolSpec ( tool_id = tool . get ( \"tool_id\" , \"\" ), name = tool . get ( \"name\" , tool . get ( \"tool_id\" , \"\" )), description = tool . get ( \"description\" , \"\" ), factory = factory , enabled = tool . get ( \"enabled\" , True ), kind = kind , prompt_path = prompt_path , metadata = { key : value for key , value in tool . items () if key not in { \"tool_id\" , \"name\" , \"description\" , \"module\" , \"class\" , \"enabled\" , \"kind\" , \"prompt\" , } }, ) if not spec . tool_id : logging . warning ( \"Skipping tool with empty tool_id: {} \" , tool ) continue registry . register ( spec ) if not registry . list_specs ( include_disabled = True ): return _default_registry () builtin_registry = _default_registry () existing_ids = { spec . tool_id for spec in registry . list_specs ( include_disabled = True )} for spec in builtin_registry . list_specs ( include_disabled = True ): if spec . tool_id in existing_ids : continue registry . register ( spec ) existing_ids . add ( spec . tool_id ) set_available_tools ([ spec . tool_id for spec in registry . list_specs ()]) return registry","title":"load_registry"},{"location":"reference/#meeseeks_core.types","text":"Shared type definitions for core components.","title":"types"},{"location":"reference/#meeseeks_core.types.ActionPlanPayload","text":"Bases: TypedDict Payload describing an action plan. Source code in packages/meeseeks_core/src/meeseeks_core/types.py 21 22 23 24 class ActionPlanPayload ( TypedDict ): \"\"\"Payload describing an action plan.\"\"\" steps : list [ PlanStepPayload ]","title":"ActionPlanPayload"},{"location":"reference/#meeseeks_core.types.ActionStepPayload","text":"Bases: TypedDict Serialized tool call data sent to/from execution. Source code in packages/meeseeks_core/src/meeseeks_core/types.py 27 28 29 30 31 32 33 34 35 36 class ActionStepPayload ( TypedDict ): \"\"\"Serialized tool call data sent to/from execution.\"\"\" tool_id : str operation : str tool_input : ToolInput title : NotRequired [ str ] objective : NotRequired [ str ] execution_checklist : NotRequired [ list [ str ]] expected_output : NotRequired [ str ]","title":"ActionStepPayload"},{"location":"reference/#meeseeks_core.types.AssistantPayload","text":"Bases: TypedDict Payload describing an assistant response. Source code in packages/meeseeks_core/src/meeseeks_core/types.py 66 67 68 69 class AssistantPayload ( TypedDict ): \"\"\"Payload describing an assistant response.\"\"\" text : str","title":"AssistantPayload"},{"location":"reference/#meeseeks_core.types.CompletionPayload","text":"Bases: TypedDict Payload describing overall completion state. Source code in packages/meeseeks_core/src/meeseeks_core/types.py 72 73 74 75 76 77 78 79 class CompletionPayload ( TypedDict ): \"\"\"Payload describing overall completion state.\"\"\" done : bool done_reason : str | None task_result : str | None error : NotRequired [ str ] last_error : NotRequired [ str ]","title":"CompletionPayload"},{"location":"reference/#meeseeks_core.types.Event","text":"Bases: TypedDict Base event payload stored in transcripts. Source code in packages/meeseeks_core/src/meeseeks_core/types.py 93 94 95 96 97 class Event ( TypedDict ): \"\"\"Base event payload stored in transcripts.\"\"\" type : str payload : EventPayload","title":"Event"},{"location":"reference/#meeseeks_core.types.EventRecord","text":"Bases: Event Event payload with a persisted timestamp. Source code in packages/meeseeks_core/src/meeseeks_core/types.py 100 101 102 103 class EventRecord ( Event ): \"\"\"Event payload with a persisted timestamp.\"\"\" ts : str","title":"EventRecord"},{"location":"reference/#meeseeks_core.types.PermissionPayload","text":"Bases: TypedDict Payload emitted for permission decisions. Source code in packages/meeseeks_core/src/meeseeks_core/types.py 39 40 41 42 43 44 45 class PermissionPayload ( TypedDict ): \"\"\"Payload emitted for permission decisions.\"\"\" tool_id : str operation : str tool_input : str decision : str","title":"PermissionPayload"},{"location":"reference/#meeseeks_core.types.PlanStepPayload","text":"Bases: TypedDict Payload describing a single plan step. Source code in packages/meeseeks_core/src/meeseeks_core/types.py 14 15 16 17 18 class PlanStepPayload ( TypedDict ): \"\"\"Payload describing a single plan step.\"\"\" title : str description : str","title":"PlanStepPayload"},{"location":"reference/#meeseeks_core.types.ToolResultPayload","text":"Bases: TypedDict Payload describing the outcome of a tool invocation. Source code in packages/meeseeks_core/src/meeseeks_core/types.py 48 49 50 51 52 53 54 55 56 57 class ToolResultPayload ( TypedDict ): \"\"\"Payload describing the outcome of a tool invocation.\"\"\" tool_id : str operation : str tool_input : ToolInput result : str | None success : NotRequired [ bool ] summary : NotRequired [ str ] error : NotRequired [ str ]","title":"ToolResultPayload"},{"location":"reference/#meeseeks_core.types.UserPayload","text":"Bases: TypedDict Payload describing a user message. Source code in packages/meeseeks_core/src/meeseeks_core/types.py 60 61 62 63 class UserPayload ( TypedDict ): \"\"\"Payload describing a user message.\"\"\" text : str","title":"UserPayload"},{"location":"reference/#tools","text":"","title":"Tools"},{"location":"reference/#meeseeks_tools.integration.homeassistant","text":"Home Assistant integration tools and data models.","title":"homeassistant"},{"location":"reference/#meeseeks_tools.integration.homeassistant.CacheHolder","text":"Bases: Protocol Protocol describing objects with a Home Assistant cache attribute. Attributes: Name Type Description cache HomeAssistantCache Home Assistant cache payload. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 45 46 47 48 49 50 51 52 53 @runtime_checkable class CacheHolder ( Protocol ): \"\"\"Protocol describing objects with a Home Assistant cache attribute. Attributes: cache: Home Assistant cache payload. \"\"\" cache : HomeAssistantCache","title":"CacheHolder"},{"location":"reference/#meeseeks_tools.integration.homeassistant.HomeAssistant","text":"Bases: AbstractTool A service to manage and interact with Home Assistant. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 class HomeAssistant ( AbstractTool ): \"\"\"A service to manage and interact with Home Assistant.\"\"\" def __init__ ( self ) -> None : \"\"\"Initialize the Home Assistant tool with environment defaults.\"\"\" super () . __init__ ( name = \"Home Assistant\" , description = \"A service to manage and interact with Home Assistant\" , ) self . base_url = get_config_value ( \"home_assistant\" , \"url\" ) self . _api_token = get_config_value ( \"home_assistant\" , \"token\" ) self . cache : HomeAssistantCache = { \"entity_ids\" : [], \"sensor_ids\" : [], \"entities\" : [], \"services\" : [], \"sensors\" : [], \"allowed_domains\" : [ \"scene\" , \"switch\" , \"weather\" , \"kodi\" , \"automation\" ], } if not self . base_url or not self . _api_token : raise ValueError ( \"home_assistant.url and home_assistant.token must be set.\" ) self . api_headers : dict [ str , str ] = { \"Authorization\" : f \"Bearer { self . _api_token } \" , \"Content-Type\" : \"application/json\" , } @cache_monitor def update_services ( self ) -> bool : \"\"\"Update the list of services from Home Assistant. Returns: True when services are fetched successfully. \"\"\" url = f \" { self . base_url } /services\" try : response = requests . get ( url , headers = self . api_headers , timeout = 30 ) status_code = getattr ( response , \"status_code\" , None ) if status_code in { 401 , 403 }: logging . error ( \"Home Assistant authorization failed with status {} .\" , status_code ) raise PermissionError ( \"Home Assistant authorization failed.\" ) response . raise_for_status () self . cache [ \"services\" ] = response . json () self . _save_json ( self . cache [ \"services\" ], \"services.json\" ) return True except requests . exceptions . RequestException as e : logging . error ( \"Error: {} \" , e ) return False @cache_monitor def update_entities ( self ) -> bool : \"\"\"Update the list of entities from Home Assistant. Returns: True when entities are fetched successfully. \"\"\" url = f \" { self . base_url } /states\" try : response = requests . get ( url , headers = self . api_headers , timeout = 30 ) status_code = getattr ( response , \"status_code\" , None ) if status_code in { 401 , 403 }: logging . error ( \"Home Assistant authorization failed with status {} .\" , status_code ) raise PermissionError ( \"Home Assistant authorization failed.\" ) response . raise_for_status () self . cache [ \"entities\" ] = response . json () return True except requests . exceptions . RequestException as e : logging . error ( \"Error: {} \" , e ) return False @cache_monitor def update_entity_ids ( self ) -> bool : \"\"\"Update the list of entity IDs from Home Assistant. Returns: True when entity IDs are populated. Raises: ValueError: If no entities are available for ID extraction. \"\"\" # TODO: Always assumes blacklist by default due to cache_monitor. self . update_entities () entities = self . cache [ \"entities\" ] if not entities : raise ValueError ( \"No entities found while updating entity IDs.\" ) self . cache [ \"entity_ids\" ] = [ entity [ \"entity_id\" ] for entity in entities ] logging . info ( \"Entity IDs updated.\" ) return True @cache_monitor def update_cache ( self ) -> None : \"\"\"Update the entire cache. Raises: ValueError: If entity IDs cannot be derived. \"\"\" self . update_entity_ids () self . update_services () self . _save_json ( self . cache [ \"entities\" ], \"entities.json\" ) self . _save_json ( self . cache [ \"sensors\" ], \"sensors.json\" ) def call_service ( self , domain : str , service : str , entity_id : str , data : dict | None = None , ) -> tuple [ bool , list [ dict [ str , Any ]]]: \"\"\"Call a service in Home Assistant. Args: domain: Home Assistant domain name (e.g., \"light\"). service: Service name within the domain (e.g., \"turn_on\"). entity_id: Entity ID to target. data: Optional extra payload for the service call. Returns: Tuple of success flag and JSON response payload. Raises: ValueError: If the domain is not allowed. \"\"\" if domain not in self . cache [ \"allowed_domains\" ]: raise ValueError ( f \"Domain does not exist or blacklisted: { domain } \" ) url = f \" { self . base_url } /services/ { domain } / { service } \" payload = { \"entity_id\" : entity_id } if data : payload . update ( data ) try : response = requests . post ( url , headers = self . api_headers , json = payload , timeout = 30 ) status_code = getattr ( response , \"status_code\" , None ) if status_code in { 401 , 403 }: logging . error ( \"Home Assistant authorization failed with status {} .\" , status_code ) raise PermissionError ( \"Home Assistant authorization failed.\" ) response . raise_for_status () logging . info ( \"Service < {} . {} > called on entity < {} > returned ` {} `.\" , domain , service , entity_id , response . text , ) return True , response . json () except requests . exceptions . RequestException as e : logging . error ( \"Unable to call service < {} . {} > on entity < {} >: {} \" , domain , service , entity_id , e ) return False , [] @staticmethod def _create_set_prompt ( system_prompt : str , parser : PydanticOutputParser , ) -> ChatPromptTemplate : \"\"\"Create the prompt template for a set-state operation. Args: system_prompt: System prompt content. parser: Pydantic output parser for HomeAssistantCall. Returns: ChatPromptTemplate configured for set-state tasks. \"\"\" example = HomeAssistantCall ( domain = \"scene\" , service = \"turn_on\" , entity_id = \"scene.lamp_power_on\" ) prompt = ChatPromptTemplate ( messages = [ SystemMessage ( content = system_prompt ), HumanMessage ( content = \"Turn on the lamp lights.\" ), AIMessage ( content = example . json ()), HumanMessagePromptTemplate . from_template ( \"The user asked you to ` {action_step} `. You must use the information \" \"provided to pick the right Home Assistant service call values only \" \"considering the current user query. \\n\\n \" \"## Format Instructions \\n {format_instructions} \\n\\n \" \"## Home Assistant Entities and Domain-Services \\n ``` \\n {context} ``` \\n \" ), ], partial_variables = { \"format_instructions\" : parser . get_format_instructions ()}, input_variables = [ \"action_step\" ], ) return prompt @staticmethod def _create_get_prompt ( system_prompt : str ) -> ChatPromptTemplate : \"\"\"Create the prompt template for a get-state operation. Args: system_prompt: System prompt content. Returns: ChatPromptTemplate configured for get-state tasks. \"\"\" prompt = ChatPromptTemplate ( messages = [ SystemMessage ( content = system_prompt ), HumanMessage ( content = \"How is the air quality today?\" ), AIMessage ( content = ( \"AccuWeather reported today's air quality in your home as good. \" \"This level of air quality ensures that the environment is healthy, \" \"supporting your daily activities and wellbeing without any air \" \"quality-related risks.\" ) ), HumanMessagePromptTemplate . from_template ( \"The user asked you to ` {action_step} `. You must use the sensor \" \"information to answer the user's query. Keep your answer \" \"analytical, brief and useful. \\n\\n \" \"## Home Assistant Sensors \\n ``` \\n {context} ``` \\n \" ), ], input_variables = [ \"action_step\" ], ) return prompt @staticmethod def _clean_answer ( answer : str ) -> str : \"\"\"Clean the answer by removing/replacing characters. Args: answer: Raw answer string to normalize. Returns: Cleaned answer string. \"\"\" replacements = { # Common entities \"RealFeel\" : \"Real Feel\" , # Confident Abbreviations \"km/h\" : \" kilometer per hour\" , \"\u00b0C\" : \" degrees celsius\" , \"%\" : \" percent\" , \"mm/h\" : \" millimeter per hour\" , \"Gb/s\" : \" gigabits per second\" , \"Mb/s\" : \" megabits per second\" , \"Kb/s\" : \" kilobits per second\" , \"GHz\" : \"Gigahertz\" , # Formatting '\"' : \"\" , } # Replace using the dictionary for old , new in replacements . items (): answer = answer . replace ( old , new ) # Remove extra spaces and new lines, condense all multiple spaces # to a single space answer = re . sub ( r \"\\s+\" , \" \" , answer ) . strip () return answer def _invoke_service_and_set_state ( self , chain : SupportsInvoke , rag_documents : list [ Document ], action_step : ActionStep , ) -> MockSpeaker : \"\"\"Invoke the service and set the state. Args: chain: Runnable chain that yields HomeAssistantCall. rag_documents: Context documents for the chain. action_step: Action step describing the request. Returns: MockSpeaker with a status message. \"\"\" MockSpeaker = get_mock_speaker () try : action_step_curr = str ( action_step . tool_input ) . strip () call_service_values = chain . invoke ( { \"action_step\" : action_step_curr , \"context\" : rag_documents , \"cache\" : self . cache }, ) logging . debug ( \"Call Service Values for ` {} `: ` {} `\" , action_step_curr , call_service_values ) status_bool , response_json = self . call_service ( domain = call_service_values . domain , service = call_service_values . service , entity_id = call_service_values . entity_id , ) if status_bool : tmp_return_message = f \"Successfully called service: ` { response_json } `\" else : tmp_return_message = f \"Failed to call service: ` { response_json } `\" except Exception as err_mesaage : logging . error ( \"Error: {} \" , err_mesaage ) tmp_return_message = f \"I received an error - ` { err_mesaage } `\" return MockSpeaker ( content = tmp_return_message ) def set_state ( self , action_step : ActionStep | None = None ) -> MockSpeaker : \"\"\"Predict and call a service for a given action step. Args: action_step: Action step describing the desired change. Returns: MockSpeaker with a status message. Raises: ValueError: If action_step is None. \"\"\" if action_step is None : raise ValueError ( \"Action step cannot be None.\" ) self . update_cache () rag_documents = self . _load_rag_documents ([ \"entities.json\" , \"services.json\" ]) system_prompt = ha_render_system_prompt ( name = \"homeassistant-set-state\" , all_entities = self . cache [ \"entity_ids\" ] ) parser = PydanticOutputParser ( pydantic_object = HomeAssistantCall ) # type: ignore[type-var] prompt = self . _create_set_prompt ( system_prompt , parser ) if self . model is None : raise RuntimeError ( \"LLM client not initialized for Home Assistant.\" ) model = self . model chain : Any = prompt | model | parser logging . info ( \"Invoking `set` action chain using ` {} ` for ` {} `.\" , self . model_name , action_step ) # TODO: Interpret the response from call service. return self . _invoke_service_and_set_state ( chain , rag_documents , action_step ) def get_state ( self , action_step : ActionStep | None = None ) -> MockSpeaker : \"\"\"Generate response for a given action step based on sensors. Args: action_step: Action step describing the desired query. Returns: MockSpeaker with the generated response. Raises: ValueError: If action_step is None. \"\"\" if action_step is None : raise ValueError ( \"Action step cannot be None.\" ) self . update_cache () rag_documents = self . _load_rag_documents ([ \"sensors.json\" ]) system_prompt = ha_render_system_prompt ( name = \"homeassistant-get-state\" ) prompt = self . _create_get_prompt ( system_prompt ) if self . model is None : raise RuntimeError ( \"LLM client not initialized for Home Assistant.\" ) model = self . model chain : Any = prompt | model logging . info ( \"Invoking `get` action chain using ` {} `.\" , self . model_name ) message = chain . invoke ( { \"action_step\" : str ( action_step . tool_input ) . strip (), \"context\" : rag_documents , }, ) cleaned_message = self . _clean_answer ( str ( message . content )) MockSpeaker = get_mock_speaker () return MockSpeaker ( content = cleaned_message )","title":"HomeAssistant"},{"location":"reference/#meeseeks_tools.integration.homeassistant.HomeAssistant.__init__","text":"Initialize the Home Assistant tool with environment defaults. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 def __init__ ( self ) -> None : \"\"\"Initialize the Home Assistant tool with environment defaults.\"\"\" super () . __init__ ( name = \"Home Assistant\" , description = \"A service to manage and interact with Home Assistant\" , ) self . base_url = get_config_value ( \"home_assistant\" , \"url\" ) self . _api_token = get_config_value ( \"home_assistant\" , \"token\" ) self . cache : HomeAssistantCache = { \"entity_ids\" : [], \"sensor_ids\" : [], \"entities\" : [], \"services\" : [], \"sensors\" : [], \"allowed_domains\" : [ \"scene\" , \"switch\" , \"weather\" , \"kodi\" , \"automation\" ], } if not self . base_url or not self . _api_token : raise ValueError ( \"home_assistant.url and home_assistant.token must be set.\" ) self . api_headers : dict [ str , str ] = { \"Authorization\" : f \"Bearer { self . _api_token } \" , \"Content-Type\" : \"application/json\" , }","title":"__init__"},{"location":"reference/#meeseeks_tools.integration.homeassistant.HomeAssistant.call_service","text":"Call a service in Home Assistant. Parameters: Name Type Description Default domain str Home Assistant domain name (e.g., \"light\"). required service str Service name within the domain (e.g., \"turn_on\"). required entity_id str Entity ID to target. required data dict | None Optional extra payload for the service call. None Returns: Type Description tuple [ bool , list [ dict [ str , Any ]]] Tuple of success flag and JSON response payload. Raises: Type Description ValueError If the domain is not allowed. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 def call_service ( self , domain : str , service : str , entity_id : str , data : dict | None = None , ) -> tuple [ bool , list [ dict [ str , Any ]]]: \"\"\"Call a service in Home Assistant. Args: domain: Home Assistant domain name (e.g., \"light\"). service: Service name within the domain (e.g., \"turn_on\"). entity_id: Entity ID to target. data: Optional extra payload for the service call. Returns: Tuple of success flag and JSON response payload. Raises: ValueError: If the domain is not allowed. \"\"\" if domain not in self . cache [ \"allowed_domains\" ]: raise ValueError ( f \"Domain does not exist or blacklisted: { domain } \" ) url = f \" { self . base_url } /services/ { domain } / { service } \" payload = { \"entity_id\" : entity_id } if data : payload . update ( data ) try : response = requests . post ( url , headers = self . api_headers , json = payload , timeout = 30 ) status_code = getattr ( response , \"status_code\" , None ) if status_code in { 401 , 403 }: logging . error ( \"Home Assistant authorization failed with status {} .\" , status_code ) raise PermissionError ( \"Home Assistant authorization failed.\" ) response . raise_for_status () logging . info ( \"Service < {} . {} > called on entity < {} > returned ` {} `.\" , domain , service , entity_id , response . text , ) return True , response . json () except requests . exceptions . RequestException as e : logging . error ( \"Unable to call service < {} . {} > on entity < {} >: {} \" , domain , service , entity_id , e ) return False , []","title":"call_service"},{"location":"reference/#meeseeks_tools.integration.homeassistant.HomeAssistant.get_state","text":"Generate response for a given action step based on sensors. Parameters: Name Type Description Default action_step ActionStep | None Action step describing the desired query. None Returns: Type Description MockSpeaker MockSpeaker with the generated response. Raises: Type Description ValueError If action_step is None. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 def get_state ( self , action_step : ActionStep | None = None ) -> MockSpeaker : \"\"\"Generate response for a given action step based on sensors. Args: action_step: Action step describing the desired query. Returns: MockSpeaker with the generated response. Raises: ValueError: If action_step is None. \"\"\" if action_step is None : raise ValueError ( \"Action step cannot be None.\" ) self . update_cache () rag_documents = self . _load_rag_documents ([ \"sensors.json\" ]) system_prompt = ha_render_system_prompt ( name = \"homeassistant-get-state\" ) prompt = self . _create_get_prompt ( system_prompt ) if self . model is None : raise RuntimeError ( \"LLM client not initialized for Home Assistant.\" ) model = self . model chain : Any = prompt | model logging . info ( \"Invoking `get` action chain using ` {} `.\" , self . model_name ) message = chain . invoke ( { \"action_step\" : str ( action_step . tool_input ) . strip (), \"context\" : rag_documents , }, ) cleaned_message = self . _clean_answer ( str ( message . content )) MockSpeaker = get_mock_speaker () return MockSpeaker ( content = cleaned_message )","title":"get_state"},{"location":"reference/#meeseeks_tools.integration.homeassistant.HomeAssistant.set_state","text":"Predict and call a service for a given action step. Parameters: Name Type Description Default action_step ActionStep | None Action step describing the desired change. None Returns: Type Description MockSpeaker MockSpeaker with a status message. Raises: Type Description ValueError If action_step is None. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 def set_state ( self , action_step : ActionStep | None = None ) -> MockSpeaker : \"\"\"Predict and call a service for a given action step. Args: action_step: Action step describing the desired change. Returns: MockSpeaker with a status message. Raises: ValueError: If action_step is None. \"\"\" if action_step is None : raise ValueError ( \"Action step cannot be None.\" ) self . update_cache () rag_documents = self . _load_rag_documents ([ \"entities.json\" , \"services.json\" ]) system_prompt = ha_render_system_prompt ( name = \"homeassistant-set-state\" , all_entities = self . cache [ \"entity_ids\" ] ) parser = PydanticOutputParser ( pydantic_object = HomeAssistantCall ) # type: ignore[type-var] prompt = self . _create_set_prompt ( system_prompt , parser ) if self . model is None : raise RuntimeError ( \"LLM client not initialized for Home Assistant.\" ) model = self . model chain : Any = prompt | model | parser logging . info ( \"Invoking `set` action chain using ` {} ` for ` {} `.\" , self . model_name , action_step ) # TODO: Interpret the response from call service. return self . _invoke_service_and_set_state ( chain , rag_documents , action_step )","title":"set_state"},{"location":"reference/#meeseeks_tools.integration.homeassistant.HomeAssistant.update_cache","text":"Update the entire cache. Raises: Type Description ValueError If entity IDs cannot be derived. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 380 381 382 383 384 385 386 387 388 389 390 @cache_monitor def update_cache ( self ) -> None : \"\"\"Update the entire cache. Raises: ValueError: If entity IDs cannot be derived. \"\"\" self . update_entity_ids () self . update_services () self . _save_json ( self . cache [ \"entities\" ], \"entities.json\" ) self . _save_json ( self . cache [ \"sensors\" ], \"sensors.json\" )","title":"update_cache"},{"location":"reference/#meeseeks_tools.integration.homeassistant.HomeAssistant.update_entities","text":"Update the list of entities from Home Assistant. Returns: Type Description bool True when entities are fetched successfully. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 @cache_monitor def update_entities ( self ) -> bool : \"\"\"Update the list of entities from Home Assistant. Returns: True when entities are fetched successfully. \"\"\" url = f \" { self . base_url } /states\" try : response = requests . get ( url , headers = self . api_headers , timeout = 30 ) status_code = getattr ( response , \"status_code\" , None ) if status_code in { 401 , 403 }: logging . error ( \"Home Assistant authorization failed with status {} .\" , status_code ) raise PermissionError ( \"Home Assistant authorization failed.\" ) response . raise_for_status () self . cache [ \"entities\" ] = response . json () return True except requests . exceptions . RequestException as e : logging . error ( \"Error: {} \" , e ) return False","title":"update_entities"},{"location":"reference/#meeseeks_tools.integration.homeassistant.HomeAssistant.update_entity_ids","text":"Update the list of entity IDs from Home Assistant. Returns: Type Description bool True when entity IDs are populated. Raises: Type Description ValueError If no entities are available for ID extraction. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 @cache_monitor def update_entity_ids ( self ) -> bool : \"\"\"Update the list of entity IDs from Home Assistant. Returns: True when entity IDs are populated. Raises: ValueError: If no entities are available for ID extraction. \"\"\" # TODO: Always assumes blacklist by default due to cache_monitor. self . update_entities () entities = self . cache [ \"entities\" ] if not entities : raise ValueError ( \"No entities found while updating entity IDs.\" ) self . cache [ \"entity_ids\" ] = [ entity [ \"entity_id\" ] for entity in entities ] logging . info ( \"Entity IDs updated.\" ) return True","title":"update_entity_ids"},{"location":"reference/#meeseeks_tools.integration.homeassistant.HomeAssistant.update_services","text":"Update the list of services from Home Assistant. Returns: Type Description bool True when services are fetched successfully. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 @cache_monitor def update_services ( self ) -> bool : \"\"\"Update the list of services from Home Assistant. Returns: True when services are fetched successfully. \"\"\" url = f \" { self . base_url } /services\" try : response = requests . get ( url , headers = self . api_headers , timeout = 30 ) status_code = getattr ( response , \"status_code\" , None ) if status_code in { 401 , 403 }: logging . error ( \"Home Assistant authorization failed with status {} .\" , status_code ) raise PermissionError ( \"Home Assistant authorization failed.\" ) response . raise_for_status () self . cache [ \"services\" ] = response . json () self . _save_json ( self . cache [ \"services\" ], \"services.json\" ) return True except requests . exceptions . RequestException as e : logging . error ( \"Error: {} \" , e ) return False","title":"update_services"},{"location":"reference/#meeseeks_tools.integration.homeassistant.HomeAssistantCache","text":"Bases: TypedDict Cached Home Assistant entity and service metadata. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 33 34 35 36 37 38 39 40 41 42 class HomeAssistantCache ( TypedDict ): \"\"\"Cached Home Assistant entity and service metadata.\"\"\" entity_ids : list [ str ] sensor_ids : list [ str ] entities : list [ dict [ str , Any ]] services : list [ dict [ str , Any ]] sensors : list [ dict [ str , Any ]] allowed_domains : list [ str ] sensor : NotRequired [ list [ dict [ str , Any ]]]","title":"HomeAssistantCache"},{"location":"reference/#meeseeks_tools.integration.homeassistant.HomeAssistantCall","text":"Bases: BaseModel Structured Home Assistant service call extracted from the model output. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 class HomeAssistantCall ( BaseModel ): \"\"\"Structured Home Assistant service call extracted from the model output.\"\"\" cache : CacheHolder | None = Field ( alias = \"_ha_cache\" , default = None ) domain : str = Field ( description = ( \"The category of the service to call, such as 'light', 'switch', or 'scene'.\" ) ) service : str = Field ( description = ( \"The specific action to perform within the domain, such as 'turn_on', \" \"'turn_off', or 'set_temperature'.\" ) ) entity_id : str = Field ( description = ( \"The ID of the specific device or entity within the domain to apply the \" \"service to, such as 'scene.heater'.\" ) ) @validator ( \"entity_id\" , allow_reuse = True ) # pylint: disable=E0213,W0613 def validate_entity_id ( cls , entity_id : str , values : dict [ str , Any ], ** kwargs : Any ) -> str : \"\"\"Validate the entity_id against the cache when available. Args: cls: Pydantic model class. entity_id: Candidate entity identifier. values: Parsed model values. **kwargs: Additional validator arguments. Returns: Validated entity identifier. Raises: ValueError: If the entity ID is not found in the cache. \"\"\" # ! BUG: The entity_id may not be validated correctly as the cache # ! is not passed to the validator. ha_cache = values . get ( \"ha_cache\" ) if ha_cache and entity_id not in ha_cache . cache [ \"entity_ids\" ]: raise ValueError ( f \"Entity ID ' { entity_id } ' is not in the Home Assistant cache.\" ) return entity_id @validator ( \"domain\" , allow_reuse = True ) # pylint: disable=E0213,W0613 def validate_domain ( cls , domain : str , values : dict [ str , Any ], ** kwargs : Any ) -> str : \"\"\"Validate the domain against the cache when available. Args: cls: Pydantic model class. domain: Domain string to validate. values: Parsed model values. **kwargs: Additional validator arguments. Returns: Validated domain string. Raises: ValueError: If the domain is not found in the cache. \"\"\" # ! BUG: The entity_id may not be validated correctly as the cache # ! is not passed to the validator. ha_cache = values . get ( \"ha_cache\" ) if ha_cache and domain not in ha_cache . cache [ \"allowed_domains\" ]: raise ValueError ( f \"Domain ' { domain } ' is not in the Home Assistant cache.\" ) return domain class Config : \"\"\"Pydantic configuration for HomeAssistantCall.\"\"\" arbitrary_types_allowed = True","title":"HomeAssistantCall"},{"location":"reference/#meeseeks_tools.integration.homeassistant.HomeAssistantCall.Config","text":"Pydantic configuration for HomeAssistantCall. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 284 285 286 287 class Config : \"\"\"Pydantic configuration for HomeAssistantCall.\"\"\" arbitrary_types_allowed = True","title":"Config"},{"location":"reference/#meeseeks_tools.integration.homeassistant.HomeAssistantCall.validate_domain","text":"Validate the domain against the cache when available. Parameters: Name Type Description Default cls Pydantic model class. required domain str Domain string to validate. required values dict [ str , Any ] Parsed model values. required **kwargs Any Additional validator arguments. {} Returns: Type Description str Validated domain string. Raises: Type Description ValueError If the domain is not found in the cache. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 @validator ( \"domain\" , allow_reuse = True ) # pylint: disable=E0213,W0613 def validate_domain ( cls , domain : str , values : dict [ str , Any ], ** kwargs : Any ) -> str : \"\"\"Validate the domain against the cache when available. Args: cls: Pydantic model class. domain: Domain string to validate. values: Parsed model values. **kwargs: Additional validator arguments. Returns: Validated domain string. Raises: ValueError: If the domain is not found in the cache. \"\"\" # ! BUG: The entity_id may not be validated correctly as the cache # ! is not passed to the validator. ha_cache = values . get ( \"ha_cache\" ) if ha_cache and domain not in ha_cache . cache [ \"allowed_domains\" ]: raise ValueError ( f \"Domain ' { domain } ' is not in the Home Assistant cache.\" ) return domain","title":"validate_domain"},{"location":"reference/#meeseeks_tools.integration.homeassistant.HomeAssistantCall.validate_entity_id","text":"Validate the entity_id against the cache when available. Parameters: Name Type Description Default cls Pydantic model class. required entity_id str Candidate entity identifier. required values dict [ str , Any ] Parsed model values. required **kwargs Any Additional validator arguments. {} Returns: Type Description str Validated entity identifier. Raises: Type Description ValueError If the entity ID is not found in the cache. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 @validator ( \"entity_id\" , allow_reuse = True ) # pylint: disable=E0213,W0613 def validate_entity_id ( cls , entity_id : str , values : dict [ str , Any ], ** kwargs : Any ) -> str : \"\"\"Validate the entity_id against the cache when available. Args: cls: Pydantic model class. entity_id: Candidate entity identifier. values: Parsed model values. **kwargs: Additional validator arguments. Returns: Validated entity identifier. Raises: ValueError: If the entity ID is not found in the cache. \"\"\" # ! BUG: The entity_id may not be validated correctly as the cache # ! is not passed to the validator. ha_cache = values . get ( \"ha_cache\" ) if ha_cache and entity_id not in ha_cache . cache [ \"entity_ids\" ]: raise ValueError ( f \"Entity ID ' { entity_id } ' is not in the Home Assistant cache.\" ) return entity_id","title":"validate_entity_id"},{"location":"reference/#meeseeks_tools.integration.homeassistant.SupportsInvoke","text":"Bases: Protocol Protocol for runnable chains that return HomeAssistantCall. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 56 57 58 59 60 61 62 63 64 65 66 67 68 class SupportsInvoke ( Protocol ): \"\"\"Protocol for runnable chains that return HomeAssistantCall.\"\"\" def invoke ( self , input_data : dict [ str , Any ]) -> HomeAssistantCall : \"\"\"Invoke the chain with structured input. Args: input_data: Input payload for the chain. Returns: Parsed HomeAssistantCall. \"\"\" ...","title":"SupportsInvoke"},{"location":"reference/#meeseeks_tools.integration.homeassistant.SupportsInvoke.invoke","text":"Invoke the chain with structured input. Parameters: Name Type Description Default input_data dict [ str , Any ] Input payload for the chain. required Returns: Type Description HomeAssistantCall Parsed HomeAssistantCall. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 59 60 61 62 63 64 65 66 67 68 def invoke ( self , input_data : dict [ str , Any ]) -> HomeAssistantCall : \"\"\"Invoke the chain with structured input. Args: input_data: Input payload for the chain. Returns: Parsed HomeAssistantCall. \"\"\" ...","title":"invoke"},{"location":"reference/#meeseeks_tools.integration.homeassistant.cache_monitor","text":"Decorator to monitor and update the cache. Parameters: Name Type Description Default func Callable [ Concatenate [ SelfT , P ], R ] Method that updates a portion of the cache. required Returns: Type Description Callable [ Concatenate [ SelfT , P ], R ] Wrapped function that normalizes cache contents after execution. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 def cache_monitor ( func : Callable [ Concatenate [ SelfT , P ], R ]) -> Callable [ Concatenate [ SelfT , P ], R ]: \"\"\"Decorator to monitor and update the cache. Args: func: Method that updates a portion of the cache. Returns: Wrapped function that normalizes cache contents after execution. \"\"\" def sort_by_entity_id ( dict_list : list [ dict [ str , Any ]]) -> list [ dict [ str , Any ]]: \"\"\"Sort a list of entities by the entity_id field. Args: dict_list: List of entity dictionaries. Returns: Sorted list of entities. \"\"\" return sorted ( dict_list , key = lambda x : x [ \"entity_id\" ]) def clean_entities ( self : CacheHolder , forbidden_prefixes : list [ str ], forbidden_substrings : list [ str ], ) -> HomeAssistantCache : \"\"\"Filter and normalize entities while populating sensors. Args: self: Cache holder to mutate. forbidden_prefixes: Entity ID prefixes to exclude. forbidden_substrings: Entity ID substrings to exclude. Returns: Updated HomeAssistantCache payload. \"\"\" for idx , entity in enumerate ( self . cache [ \"entities\" ]): if \"context\" in entity : self . cache [ \"entities\" ][ idx ] . pop ( \"context\" ) self . cache [ \"entities\" ][ idx ] . pop ( \"last_changed\" ) self . cache [ \"entities\" ][ idx ] . pop ( \"last_reported\" ) self . cache [ \"entities\" ][ idx ] . pop ( \"last_updated\" ) if \"attributes\" in entity : self . cache [ \"entities\" ][ idx ][ \"attributes\" ] . pop ( \"icon\" , None ) self . cache [ \"entities\" ][ idx ][ \"attributes\" ] . pop ( \"monitor_cert_days_remaining\" , None ) self . cache [ \"entities\" ][ idx ][ \"attributes\" ] . pop ( \"monitor_cert_is_valid\" , None ) self . cache [ \"entities\" ][ idx ][ \"attributes\" ] . pop ( \"monitor_hostname\" , None ) self . cache [ \"entities\" ][ idx ][ \"attributes\" ] . pop ( \"monitor_port\" , None ) if any ( entity [ \"entity_id\" ] . startswith ( prefix ) for prefix in forbidden_prefixes ): self . cache [ \"entities\" ] . remove ( entity ) if any ( substring in entity [ \"entity_id\" ] for substring in forbidden_substrings ): self . cache [ \"entities\" ] . remove ( entity ) if entity [ \"entity_id\" ] . startswith ( \"scene.\" ): self . cache [ \"entities\" ][ idx ] . pop ( \"state\" , None ) if entity [ \"entity_id\" ] . startswith ( \"sensor.\" ) or entity [ \"entity_id\" ] . startswith ( \"binary_sensor.\" ): self . cache [ \"sensors\" ] . append ( entity ) self . cache [ \"entities\" ] . pop ( idx ) self . cache [ \"entities\" ] = sort_by_entity_id ( self . cache [ \"entities\" ]) self . cache [ \"sensors\" ] = sort_by_entity_id ( self . cache [ \"sensors\" ]) return self . cache def wrapper ( self : SelfT , * args : P . args , ** kwargs : P . kwargs ) -> R : \"\"\"Invoke the wrapped function and normalize cache content. Args: self: Cache holder instance. *args: Positional arguments forwarded to the wrapped function. **kwargs: Keyword arguments forwarded to the wrapped function. Returns: Result of the wrapped function. \"\"\" result = func ( self , * args , ** kwargs ) forbidden_prefixes = [ \"alarm_control_panel.\" , \"automation.\" , \"binary_sensor.remote_ui\" , \"camera.\" , \"climate\" , \"conversation\" , \"device_tracker.kraken_raspberry_pi_5\" , \"media_player.axios\" , \"media_player.axios_2\" , \"media_player.chrome\" , \"media_player.fire_tv_192_168_1_12\" , \"person.\" , \"remote.\" , \"script.higher\" , \"sensor.hacs\" , \"sensor.hacs\" , \"sensor.kraken_raspberry_pi_5_\" , \"sensor.sonarr_commands\" , \"sensor.sun\" , \"sensor.uptimekuma_\" , \"stt.\" , \"sun.\" , \"switch.\" , \"switch.adam\" , \"switch.bedroom_camera_camera_motion_detection\" , \"tts.\" , \"update.\" , \"zone.home\" , ] forbidden_substrings = [ \"blink_kk_bedroom\" ] self . cache [ \"sensor\" ] = [] # Clean entities self . cache = clean_entities ( self , forbidden_prefixes , forbidden_substrings ) # Clean services self . cache [ \"services\" ] = [ service for service in self . cache [ \"services\" ] if service [ \"domain\" ] in self . cache [ \"allowed_domains\" ] ] # Retrieve entity and sensor IDs self . cache [ \"entity_ids\" ] = sorted ( self . cache [ \"entity_ids\" ]) self . cache [ \"sensor_ids\" ] = sorted ( self . cache [ \"sensor_ids\" ]) logging . info ( ( \"` {} ` modified cache to <(len) Entity IDs: {} ; (len) Entities: {} ; \" \"(len) Sensors: {} ; (len) Services: {} ;>\" ), func . __name__ , len ( self . cache [ \"entity_ids\" ]), len ( self . cache [ \"entities\" ]), len ( self . cache [ \"sensors\" ]), len ( self . cache [ \"services\" ]), ) return result return wrapper","title":"cache_monitor"},{"location":"reference/#meeseeks_tools.integration.mcp","text":"MCP tool runner for integrating MCP servers into Meeseeks.","title":"mcp"},{"location":"reference/#meeseeks_tools.integration.mcp.MCPToolRunner","text":"Wrapper to invoke MCP tools via langchain-mcp-adapters. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/mcp.py 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 class MCPToolRunner : \"\"\"Wrapper to invoke MCP tools via langchain-mcp-adapters.\"\"\" def __init__ ( self , server_name : str , tool_name : str ) -> None : \"\"\"Initialize the MCP tool runner for a specific server tool. Args: server_name: MCP server name from configuration. tool_name: Tool name to invoke on the server. \"\"\" self . server_name = server_name self . tool_name = tool_name async def _invoke_async ( self , input_payload : str | dict [ str , Any ]) -> str : \"\"\"Invoke an MCP tool asynchronously and return its output. Args: input_payload: Input payload to send to the MCP tool. Returns: Stringified tool response. Raises: RuntimeError: If MCP adapters are not installed. ValueError: If the server or tool is not configured. \"\"\" try : from langchain_mcp_adapters.client import MultiServerMCPClient except Exception as exc : # pragma: no cover - runtime dependency raise RuntimeError ( \"langchain-mcp-adapters is required for MCP tools.\" ) from exc config = _load_mcp_config () servers = config . get ( \"servers\" , {}) if not servers or self . server_name not in servers : raise ValueError ( f \"MCP server ' { self . server_name } ' not found in config.\" ) client = MultiServerMCPClient ({ self . server_name : servers [ self . server_name ]}) tools = await client . get_tools ( server_name = self . server_name ) tool_map = { tool . name : tool for tool in tools } tool = tool_map . get ( self . tool_name ) if tool is None : raise ValueError ( f \"Tool ' { self . tool_name } ' not found on MCP server ' { self . server_name } '.\" ) try : result = await tool . ainvoke ( _prepare_mcp_input ( tool , input_payload )) return str ( result ) except Exception as exc : _log_runtime_failure ( self . server_name , self . tool_name , exc ) raise def run ( self , action_step : ActionStep ) -> MockSpeaker : \"\"\"Execute the MCP tool using the action step argument. Args: action_step: Action step containing the prompt argument. Returns: MockSpeaker with the tool response content. Raises: ValueError: If action_step is None. \"\"\" if action_step is None : raise ValueError ( \"Action step cannot be None.\" ) MockSpeakerType = get_mock_speaker () result = asyncio . run ( self . _invoke_async ( action_step . tool_input )) return MockSpeakerType ( content = result )","title":"MCPToolRunner"},{"location":"reference/#meeseeks_tools.integration.mcp.MCPToolRunner.__init__","text":"Initialize the MCP tool runner for a specific server tool. Parameters: Name Type Description Default server_name str MCP server name from configuration. required tool_name str Tool name to invoke on the server. required Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/mcp.py 265 266 267 268 269 270 271 272 273 def __init__ ( self , server_name : str , tool_name : str ) -> None : \"\"\"Initialize the MCP tool runner for a specific server tool. Args: server_name: MCP server name from configuration. tool_name: Tool name to invoke on the server. \"\"\" self . server_name = server_name self . tool_name = tool_name","title":"__init__"},{"location":"reference/#meeseeks_tools.integration.mcp.MCPToolRunner.run","text":"Execute the MCP tool using the action step argument. Parameters: Name Type Description Default action_step ActionStep Action step containing the prompt argument. required Returns: Type Description MockSpeaker MockSpeaker with the tool response content. Raises: Type Description ValueError If action_step is None. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/mcp.py 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 def run ( self , action_step : ActionStep ) -> MockSpeaker : \"\"\"Execute the MCP tool using the action step argument. Args: action_step: Action step containing the prompt argument. Returns: MockSpeaker with the tool response content. Raises: ValueError: If action_step is None. \"\"\" if action_step is None : raise ValueError ( \"Action step cannot be None.\" ) MockSpeakerType = get_mock_speaker () result = asyncio . run ( self . _invoke_async ( action_step . tool_input )) return MockSpeakerType ( content = result )","title":"run"},{"location":"reference/#meeseeks_tools.integration.mcp.discover_mcp_tool_details","text":"Discover MCP tool names and schemas per server from configuration. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/mcp.py 206 207 208 def discover_mcp_tool_details ( config : dict [ str , Any ]) -> dict [ str , list [ dict [ str , Any ]]]: \"\"\"Discover MCP tool names and schemas per server from configuration.\"\"\" return _run_async ( _discover_mcp_tool_details_async ( _normalize_mcp_config ( config )))","title":"discover_mcp_tool_details"},{"location":"reference/#meeseeks_tools.integration.mcp.discover_mcp_tool_details_with_failures","text":"Discover MCP tool names, schemas, and per-server failures. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/mcp.py 211 212 213 214 215 216 217 218 219 def discover_mcp_tool_details_with_failures ( config : dict [ str , Any ], ) -> tuple [ dict [ str , list [ dict [ str , Any ]]], dict [ str , Exception ]]: \"\"\"Discover MCP tool names, schemas, and per-server failures.\"\"\" discovered , failures = _run_async ( _discover_mcp_tool_details_with_failures_async ( _normalize_mcp_config ( config )) ) _record_discovery_failures ( failures ) return discovered , failures","title":"discover_mcp_tool_details_with_failures"},{"location":"reference/#meeseeks_tools.integration.mcp.discover_mcp_tools","text":"Discover MCP tool names per server from configuration. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/mcp.py 197 198 199 200 201 202 203 def discover_mcp_tools ( config : dict [ str , Any ]) -> dict [ str , list [ str ]]: \"\"\"Discover MCP tool names per server from configuration.\"\"\" details = discover_mcp_tool_details ( config ) return { server_name : [ tool [ \"name\" ] for tool in tools if tool . get ( \"name\" )] for server_name , tools in details . items () }","title":"discover_mcp_tools"},{"location":"reference/#meeseeks_tools.integration.mcp.get_last_discovery_failures","text":"Return last MCP discovery failures per server (if any). Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/mcp.py 229 230 231 def get_last_discovery_failures () -> dict [ str , str ]: \"\"\"Return last MCP discovery failures per server (if any).\"\"\" return dict ( _LAST_DISCOVERY_FAILURES )","title":"get_last_discovery_failures"},{"location":"reference/#meeseeks_tools.integration.mcp.mark_tool_auto_approved","text":"Record a tool as auto-approved in the MCP config. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/mcp.py 247 248 249 250 251 252 253 254 255 256 257 258 259 def mark_tool_auto_approved ( config : dict [ str , Any ], server_name : str , tool_name : str , ) -> dict [ str , Any ]: \"\"\"Record a tool as auto-approved in the MCP config.\"\"\" servers = config . setdefault ( \"servers\" , {}) server_config = servers . setdefault ( server_name , {}) allowlist = server_config . setdefault ( \"auto_approve_tools\" , []) if tool_name not in allowlist : allowlist . append ( tool_name ) server_config [ \"auto_approve_tools\" ] = sorted ( set ( allowlist )) return config","title":"mark_tool_auto_approved"},{"location":"reference/#meeseeks_tools.integration.mcp.save_mcp_config","text":"Persist an MCP configuration payload to disk. Parameters: Name Type Description Default config dict [ str , Any ] MCP configuration payload to write. required path str | None Optional explicit file path (defaults to the configured MCP path). None Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/mcp.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 def save_mcp_config ( config : dict [ str , Any ], path : str | None = None ) -> None : \"\"\"Persist an MCP configuration payload to disk. Args: config: MCP configuration payload to write. path: Optional explicit file path (defaults to the configured MCP path). \"\"\" config_path = path or get_mcp_config_path () if not config_path : raise ValueError ( \"MCP config path is not set.\" ) config_path = os . path . abspath ( config_path ) with open ( config_path , \"w\" , encoding = \"utf-8\" ) as handle : json . dump ( config , handle , indent = 2 ) handle . write ( \" \\n \" )","title":"save_mcp_config"},{"location":"reference/#meeseeks_tools.integration.mcp.tool_auto_approved","text":"Return True when a tool is marked as auto-approved. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/mcp.py 234 235 236 237 238 239 240 241 242 243 244 def tool_auto_approved ( config : dict [ str , Any ], server_name : str , tool_name : str , ) -> bool : \"\"\"Return True when a tool is marked as auto-approved.\"\"\" server_config = config . get ( \"servers\" , {}) . get ( server_name , {}) if server_config . get ( \"auto_approve_all\" ): return True allowlist = server_config . get ( \"auto_approve_tools\" , []) return tool_name in allowlist","title":"tool_auto_approved"},{"location":"reference/#home-assistant-integration","text":"","title":"Home Assistant Integration"},{"location":"reference/#meeseeks_ha_conversation.api","text":"Meeseeks API client.","title":"api"},{"location":"reference/#meeseeks_ha_conversation.api.MeeseeksApiClient","text":"Meeseeks API Client. Source code in meeseeks_ha_conversation/api.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 class MeeseeksApiClient : \"\"\"Meeseeks API Client.\"\"\" def __init__ ( self , base_url : str , timeout : int , session : aiohttp . ClientSession , ) -> None : \"\"\"Initialize the API client. Args: base_url: Base URL for the Meeseeks API. timeout: Request timeout in seconds. session: Shared aiohttp client session. \"\"\" self . _base_url = base_url . rstrip ( \"/\" ) self . _api_key = \"msk-strong-password\" self . timeout = timeout self . _session = session async def async_get_heartbeat ( self ) -> bool : \"\"\"Get heartbeat from the API. Returns: True when the service is considered healthy. \"\"\" # TODO: Implement a heartbeat check return True async def async_get_models ( self ) -> str : \"\"\"Get models from the API. Returns: JSON-serialized model list. \"\"\" # TODO: This is monkey-patched for now response_data : ModelsResponse = { \"models\" : [ { \"name\" : \"meeseeks\" , \"modified_at\" : \"2023-11-01T00:00:00.000000000-04:00\" , \"size\" : 0 , \"digest\" : None , } ] } return json . dumps ( response_data ) async def async_generate ( self , data : dict [ str , Any ] | None = None ) -> MeeseeksQueryResponse : \"\"\"Generate a completion from the API. Args: data: Request payload including prompt and optional session ID. Returns: Parsed query response payload. Raises: ValueError: If prompt data is missing. ApiJsonError: If the API returns unexpected data. \"\"\" if not data or \"prompt\" not in data : raise ValueError ( \"Missing prompt in request data.\" ) url_query = f \" { self . _base_url } /api/query\" data_custom = { \"query\" : str ( data [ \"prompt\" ]) . strip (), } session_id = data . get ( \"session_id\" ) if isinstance ( data , dict ) else None if session_id : data_custom [ \"session_id\" ] = session_id # Pass headers as None to use the default headers result = await self . _meeseeks_api_wrapper ( method = \"post\" , url = url_query , data = data_custom , headers = None , ) if isinstance ( result , str ): raise ApiJsonError ( \"Unexpected text response from Meeseeks API.\" ) return result async def _meeseeks_api_wrapper ( self , method : str , url : str , data : dict [ str , Any ] | None = None , headers : dict [ str , str ] | None = None , decode_json : bool = True , ) -> MeeseeksQueryResponse | str : \"\"\"Perform an HTTP request to the Meeseeks API. Args: method: HTTP method to use. url: Fully qualified request URL. data: Optional JSON payload to send. headers: Optional HTTP headers override. decode_json: Whether to parse JSON responses. Returns: Parsed response payload or raw text depending on decode_json. Raises: ApiJsonError: If the API returns an error payload. aiohttp.ClientResponseError: For non-2xx responses. \"\"\" if headers is None : headers = { \"accept\" : \"application/json\" , \"X-API-KEY\" : self . _api_key , \"Content-Type\" : \"application/json\" , } async with async_timeout . timeout ( self . timeout ): response = await self . _session . request ( method = method , url = url , headers = headers , json = data , ) response . raise_for_status () if decode_json : raw_data : dict [ str , Any ] = await response . json () if response . status == 404 : raise ApiJsonError ( raw_data . get ( \"error\" , \"Unknown error\" )) task_result = str ( raw_data . get ( \"task_result\" , \"\" )) response_data : MeeseeksQueryResponse = { \"task_result\" : task_result , \"response\" : str ( raw_data . get ( \"response\" , task_result )), \"context\" : str ( raw_data . get ( \"context\" , task_result )), \"session_id\" : raw_data . get ( \"session_id\" ), } LOGGER . debug ( \"Response data: %s \" , response_data ) return response_data else : LOGGER . debug ( \"Fallback to text response\" ) return await response . text ()","title":"MeeseeksApiClient"},{"location":"reference/#meeseeks_ha_conversation.api.MeeseeksApiClient.__init__","text":"Initialize the API client. Parameters: Name Type Description Default base_url str Base URL for the Meeseeks API. required timeout int Request timeout in seconds. required session ClientSession Shared aiohttp client session. required Source code in meeseeks_ha_conversation/api.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def __init__ ( self , base_url : str , timeout : int , session : aiohttp . ClientSession , ) -> None : \"\"\"Initialize the API client. Args: base_url: Base URL for the Meeseeks API. timeout: Request timeout in seconds. session: Shared aiohttp client session. \"\"\" self . _base_url = base_url . rstrip ( \"/\" ) self . _api_key = \"msk-strong-password\" self . timeout = timeout self . _session = session","title":"__init__"},{"location":"reference/#meeseeks_ha_conversation.api.MeeseeksApiClient.async_generate","text":"Generate a completion from the API. Parameters: Name Type Description Default data dict [ str , Any ] | None Request payload including prompt and optional session ID. None Returns: Type Description MeeseeksQueryResponse Parsed query response payload. Raises: Type Description ValueError If prompt data is missing. ApiJsonError If the API returns unexpected data. Source code in meeseeks_ha_conversation/api.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 async def async_generate ( self , data : dict [ str , Any ] | None = None ) -> MeeseeksQueryResponse : \"\"\"Generate a completion from the API. Args: data: Request payload including prompt and optional session ID. Returns: Parsed query response payload. Raises: ValueError: If prompt data is missing. ApiJsonError: If the API returns unexpected data. \"\"\" if not data or \"prompt\" not in data : raise ValueError ( \"Missing prompt in request data.\" ) url_query = f \" { self . _base_url } /api/query\" data_custom = { \"query\" : str ( data [ \"prompt\" ]) . strip (), } session_id = data . get ( \"session_id\" ) if isinstance ( data , dict ) else None if session_id : data_custom [ \"session_id\" ] = session_id # Pass headers as None to use the default headers result = await self . _meeseeks_api_wrapper ( method = \"post\" , url = url_query , data = data_custom , headers = None , ) if isinstance ( result , str ): raise ApiJsonError ( \"Unexpected text response from Meeseeks API.\" ) return result","title":"async_generate"},{"location":"reference/#meeseeks_ha_conversation.api.MeeseeksApiClient.async_get_heartbeat","text":"Get heartbeat from the API. Returns: Type Description bool True when the service is considered healthy. Source code in meeseeks_ha_conversation/api.py 53 54 55 56 57 58 59 60 async def async_get_heartbeat ( self ) -> bool : \"\"\"Get heartbeat from the API. Returns: True when the service is considered healthy. \"\"\" # TODO: Implement a heartbeat check return True","title":"async_get_heartbeat"},{"location":"reference/#meeseeks_ha_conversation.api.MeeseeksApiClient.async_get_models","text":"Get models from the API. Returns: Type Description str JSON-serialized model list. Source code in meeseeks_ha_conversation/api.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 async def async_get_models ( self ) -> str : \"\"\"Get models from the API. Returns: JSON-serialized model list. \"\"\" # TODO: This is monkey-patched for now response_data : ModelsResponse = { \"models\" : [ { \"name\" : \"meeseeks\" , \"modified_at\" : \"2023-11-01T00:00:00.000000000-04:00\" , \"size\" : 0 , \"digest\" : None , } ] } return json . dumps ( response_data )","title":"async_get_models"},{"location":"reference/#meeseeks_ha_conversation.api.MeeseeksQueryResponse","text":"Bases: TypedDict Schema for the main query response. Source code in meeseeks_ha_conversation/api.py 23 24 25 26 27 28 29 class MeeseeksQueryResponse ( TypedDict ): \"\"\"Schema for the main query response.\"\"\" task_result : str response : str context : str session_id : str | None","title":"MeeseeksQueryResponse"},{"location":"reference/#meeseeks_ha_conversation.api.ModelsResponse","text":"Bases: TypedDict Schema for the models list endpoint response. Source code in meeseeks_ha_conversation/api.py 17 18 19 20 class ModelsResponse ( TypedDict ): \"\"\"Schema for the models list endpoint response.\"\"\" models : list [ dict [ str , Any ]]","title":"ModelsResponse"},{"location":"reference/#meeseeks_ha_conversation.config_flow","text":"Adds config flow for Meeseeks.","title":"config_flow"},{"location":"reference/#meeseeks_ha_conversation.config_flow.MeeseeksConfigFlow","text":"Bases: ConfigFlow Handle a config flow for Meeseeks Conversation. Handles UI wizard. Source code in meeseeks_ha_conversation/config_flow.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 class MeeseeksConfigFlow ( config_entries . ConfigFlow , domain = DOMAIN ): # type: ignore[call-arg] \"\"\"Handle a config flow for Meeseeks Conversation. Handles UI wizard.\"\"\" VERSION = 1 client : MeeseeksApiClient async def async_step_user ( self , user_input : dict [ str , Any ] | None = None ) -> FlowResult : \"\"\"Handle the initial config flow step. Args: user_input: Submitted form data, if available. Returns: FlowResult for the configuration step. \"\"\" if user_input is None : return self . async_show_form ( step_id = \"user\" , data_schema = STEP_USER_DATA_SCHEMA ) # Search for duplicates with the same CONF_BASE_URL value. for existing_entry in self . _async_current_entries ( include_ignore = False ): if existing_entry . data . get ( CONF_BASE_URL ) == user_input [ CONF_BASE_URL ]: return self . async_abort ( reason = \"already_configured\" ) errors : dict [ str , str ] = {} try : self . client = MeeseeksApiClient ( base_url = cv . url_no_path ( user_input [ CONF_BASE_URL ]), timeout = user_input [ CONF_TIMEOUT ], session = async_create_clientsession ( self . hass ), ) response = await self . client . async_get_heartbeat () if not response : raise vol . Invalid ( \"Invalid Meeseeks server\" ) # except vol.Invalid: # errors[\"base\"] = \"invalid_url\" # except ApiTimeoutError: # errors[\"base\"] = \"timeout_connect\" # except ApiCommError: # errors[\"base\"] = \"cannot_connect\" # except ApiClientError as exception: # LOGGER.exception(\"Unexpected exception: %s\", exception) # errors[\"base\"] = \"unknown\" except Exception as exception : LOGGER . exception ( \"Unexpected exception: %s \" , exception ) errors [ \"base\" ] = \"unknown\" else : return self . async_create_entry ( title = f \"Meeseeks - { user_input [ CONF_BASE_URL ] } \" , data = { CONF_BASE_URL : user_input [ CONF_BASE_URL ]}, options = { CONF_TIMEOUT : user_input [ CONF_TIMEOUT ]}, ) return self . async_show_form ( step_id = \"user\" , data_schema = STEP_USER_DATA_SCHEMA , errors = errors ) @staticmethod def async_get_options_flow ( config_entry : config_entries . ConfigEntry , ) -> config_entries . OptionsFlow : \"\"\"Create the options flow. Args: config_entry: Existing config entry to edit. Returns: Options flow handler. \"\"\" return MeeseeksOptionsFlow ( config_entry )","title":"MeeseeksConfigFlow"},{"location":"reference/#meeseeks_ha_conversation.config_flow.MeeseeksConfigFlow.async_get_options_flow","text":"Create the options flow. Parameters: Name Type Description Default config_entry ConfigEntry Existing config entry to edit. required Returns: Type Description OptionsFlow Options flow handler. Source code in meeseeks_ha_conversation/config_flow.py 108 109 110 111 112 113 114 115 116 117 118 119 120 @staticmethod def async_get_options_flow ( config_entry : config_entries . ConfigEntry , ) -> config_entries . OptionsFlow : \"\"\"Create the options flow. Args: config_entry: Existing config entry to edit. Returns: Options flow handler. \"\"\" return MeeseeksOptionsFlow ( config_entry )","title":"async_get_options_flow"},{"location":"reference/#meeseeks_ha_conversation.config_flow.MeeseeksConfigFlow.async_step_user","text":"Handle the initial config flow step. Parameters: Name Type Description Default user_input dict [ str , Any ] | None Submitted form data, if available. None Returns: Type Description FlowResult FlowResult for the configuration step. Source code in meeseeks_ha_conversation/config_flow.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 async def async_step_user ( self , user_input : dict [ str , Any ] | None = None ) -> FlowResult : \"\"\"Handle the initial config flow step. Args: user_input: Submitted form data, if available. Returns: FlowResult for the configuration step. \"\"\" if user_input is None : return self . async_show_form ( step_id = \"user\" , data_schema = STEP_USER_DATA_SCHEMA ) # Search for duplicates with the same CONF_BASE_URL value. for existing_entry in self . _async_current_entries ( include_ignore = False ): if existing_entry . data . get ( CONF_BASE_URL ) == user_input [ CONF_BASE_URL ]: return self . async_abort ( reason = \"already_configured\" ) errors : dict [ str , str ] = {} try : self . client = MeeseeksApiClient ( base_url = cv . url_no_path ( user_input [ CONF_BASE_URL ]), timeout = user_input [ CONF_TIMEOUT ], session = async_create_clientsession ( self . hass ), ) response = await self . client . async_get_heartbeat () if not response : raise vol . Invalid ( \"Invalid Meeseeks server\" ) # except vol.Invalid: # errors[\"base\"] = \"invalid_url\" # except ApiTimeoutError: # errors[\"base\"] = \"timeout_connect\" # except ApiCommError: # errors[\"base\"] = \"cannot_connect\" # except ApiClientError as exception: # LOGGER.exception(\"Unexpected exception: %s\", exception) # errors[\"base\"] = \"unknown\" except Exception as exception : LOGGER . exception ( \"Unexpected exception: %s \" , exception ) errors [ \"base\" ] = \"unknown\" else : return self . async_create_entry ( title = f \"Meeseeks - { user_input [ CONF_BASE_URL ] } \" , data = { CONF_BASE_URL : user_input [ CONF_BASE_URL ]}, options = { CONF_TIMEOUT : user_input [ CONF_TIMEOUT ]}, ) return self . async_show_form ( step_id = \"user\" , data_schema = STEP_USER_DATA_SCHEMA , errors = errors )","title":"async_step_user"},{"location":"reference/#meeseeks_ha_conversation.config_flow.MeeseeksOptionsFlow","text":"Bases: OptionsFlow Meeseeks config flow options handler. Source code in meeseeks_ha_conversation/config_flow.py 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 class MeeseeksOptionsFlow ( config_entries . OptionsFlow ): \"\"\"Meeseeks config flow options handler.\"\"\" def __init__ ( self , config_entry : config_entries . ConfigEntry ) -> None : \"\"\"Initialize options flow. Args: config_entry: Config entry to manage. \"\"\" self . config_entry = config_entry self . options = dict ( config_entry . options ) async def async_step_init ( self , user_input : dict [ str , Any ] | None = None ) -> FlowResult : \"\"\"Show the options menu. Args: user_input: Submitted form data, if available. Returns: FlowResult for the options menu. \"\"\" return self . async_show_menu ( step_id = \"init\" , menu_options = MENU_OPTIONS ) async def async_step_all_set ( self , user_input : dict [ str , Any ] | None = None ) -> FlowResult : \"\"\"Handle the \"all_set\" options step. Args: user_input: Submitted form data, if available. Returns: FlowResult for the options menu. \"\"\" return self . async_show_menu ( step_id = \"init\" , menu_options = MENU_OPTIONS ) async def async_step_general_config ( self , user_input : dict [ str , Any ] | None = None ) -> FlowResult : \"\"\"Handle the general configuration step. Args: user_input: Submitted form data, if available. Returns: FlowResult for the options menu. \"\"\" return self . async_show_menu ( step_id = \"init\" , menu_options = MENU_OPTIONS ) async def async_step_prompt_system ( self , user_input : dict [ str , Any ] | None = None ) -> FlowResult : \"\"\"Handle the prompt system configuration step. Args: user_input: Submitted form data, if available. Returns: FlowResult for the options menu. \"\"\" return self . async_show_menu ( step_id = \"init\" , menu_options = MENU_OPTIONS ) async def async_step_model_config ( self , user_input : dict [ str , Any ] | None = None ) -> FlowResult : \"\"\"Handle the model configuration step. Args: user_input: Submitted form data, if available. Returns: FlowResult for the options menu. \"\"\" return self . async_show_menu ( step_id = \"init\" , menu_options = MENU_OPTIONS )","title":"MeeseeksOptionsFlow"},{"location":"reference/#meeseeks_ha_conversation.config_flow.MeeseeksOptionsFlow.__init__","text":"Initialize options flow. Parameters: Name Type Description Default config_entry ConfigEntry Config entry to manage. required Source code in meeseeks_ha_conversation/config_flow.py 126 127 128 129 130 131 132 133 def __init__ ( self , config_entry : config_entries . ConfigEntry ) -> None : \"\"\"Initialize options flow. Args: config_entry: Config entry to manage. \"\"\" self . config_entry = config_entry self . options = dict ( config_entry . options )","title":"__init__"},{"location":"reference/#meeseeks_ha_conversation.config_flow.MeeseeksOptionsFlow.async_step_all_set","text":"Handle the \"all_set\" options step. Parameters: Name Type Description Default user_input dict [ str , Any ] | None Submitted form data, if available. None Returns: Type Description FlowResult FlowResult for the options menu. Source code in meeseeks_ha_conversation/config_flow.py 146 147 148 149 150 151 152 153 154 155 async def async_step_all_set ( self , user_input : dict [ str , Any ] | None = None ) -> FlowResult : \"\"\"Handle the \"all_set\" options step. Args: user_input: Submitted form data, if available. Returns: FlowResult for the options menu. \"\"\" return self . async_show_menu ( step_id = \"init\" , menu_options = MENU_OPTIONS )","title":"async_step_all_set"},{"location":"reference/#meeseeks_ha_conversation.config_flow.MeeseeksOptionsFlow.async_step_general_config","text":"Handle the general configuration step. Parameters: Name Type Description Default user_input dict [ str , Any ] | None Submitted form data, if available. None Returns: Type Description FlowResult FlowResult for the options menu. Source code in meeseeks_ha_conversation/config_flow.py 157 158 159 160 161 162 163 164 165 166 167 168 async def async_step_general_config ( self , user_input : dict [ str , Any ] | None = None ) -> FlowResult : \"\"\"Handle the general configuration step. Args: user_input: Submitted form data, if available. Returns: FlowResult for the options menu. \"\"\" return self . async_show_menu ( step_id = \"init\" , menu_options = MENU_OPTIONS )","title":"async_step_general_config"},{"location":"reference/#meeseeks_ha_conversation.config_flow.MeeseeksOptionsFlow.async_step_init","text":"Show the options menu. Parameters: Name Type Description Default user_input dict [ str , Any ] | None Submitted form data, if available. None Returns: Type Description FlowResult FlowResult for the options menu. Source code in meeseeks_ha_conversation/config_flow.py 135 136 137 138 139 140 141 142 143 144 async def async_step_init ( self , user_input : dict [ str , Any ] | None = None ) -> FlowResult : \"\"\"Show the options menu. Args: user_input: Submitted form data, if available. Returns: FlowResult for the options menu. \"\"\" return self . async_show_menu ( step_id = \"init\" , menu_options = MENU_OPTIONS )","title":"async_step_init"},{"location":"reference/#meeseeks_ha_conversation.config_flow.MeeseeksOptionsFlow.async_step_model_config","text":"Handle the model configuration step. Parameters: Name Type Description Default user_input dict [ str , Any ] | None Submitted form data, if available. None Returns: Type Description FlowResult FlowResult for the options menu. Source code in meeseeks_ha_conversation/config_flow.py 183 184 185 186 187 188 189 190 191 192 async def async_step_model_config ( self , user_input : dict [ str , Any ] | None = None ) -> FlowResult : \"\"\"Handle the model configuration step. Args: user_input: Submitted form data, if available. Returns: FlowResult for the options menu. \"\"\" return self . async_show_menu ( step_id = \"init\" , menu_options = MENU_OPTIONS )","title":"async_step_model_config"},{"location":"reference/#meeseeks_ha_conversation.config_flow.MeeseeksOptionsFlow.async_step_prompt_system","text":"Handle the prompt system configuration step. Parameters: Name Type Description Default user_input dict [ str , Any ] | None Submitted form data, if available. None Returns: Type Description FlowResult FlowResult for the options menu. Source code in meeseeks_ha_conversation/config_flow.py 170 171 172 173 174 175 176 177 178 179 180 181 async def async_step_prompt_system ( self , user_input : dict [ str , Any ] | None = None ) -> FlowResult : \"\"\"Handle the prompt system configuration step. Args: user_input: Submitted form data, if available. Returns: FlowResult for the options menu. \"\"\" return self . async_show_menu ( step_id = \"init\" , menu_options = MENU_OPTIONS )","title":"async_step_prompt_system"},{"location":"reference/#meeseeks_ha_conversation.const","text":"Constants for meeseeks_conversation.","title":"const"},{"location":"reference/#meeseeks_ha_conversation.coordinator","text":"DataUpdateCoordinator for meeseeks_conversation.","title":"coordinator"},{"location":"reference/#meeseeks_ha_conversation.coordinator.MeeseeksDataUpdateCoordinator","text":"Bases: DataUpdateCoordinator Class to manage fetching data from the API. Source code in meeseeks_ha_conversation/coordinator.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 class MeeseeksDataUpdateCoordinator ( DataUpdateCoordinator ): \"\"\"Class to manage fetching data from the API.\"\"\" config_entry : ConfigEntry def __init__ ( self , hass : HomeAssistant , client : MeeseeksApiClient , ) -> None : \"\"\"Initialize the coordinator. Args: hass: Home Assistant core instance. client: API client for Meeseeks. \"\"\" self . client = client super () . __init__ ( hass = hass , logger = LOGGER , name = DOMAIN , update_interval = timedelta ( minutes = 5 ), ) async def _async_update_data ( self ) -> bool : \"\"\"Update data via library. Returns: True when the heartbeat check succeeds. Raises: UpdateFailed: If the API heartbeat fails. \"\"\" try : return await self . client . async_get_heartbeat () except ApiClientError as exception : raise UpdateFailed ( exception ) from exception","title":"MeeseeksDataUpdateCoordinator"},{"location":"reference/#meeseeks_ha_conversation.coordinator.MeeseeksDataUpdateCoordinator.__init__","text":"Initialize the coordinator. Parameters: Name Type Description Default hass HomeAssistant Home Assistant core instance. required client MeeseeksApiClient API client for Meeseeks. required Source code in meeseeks_ha_conversation/coordinator.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def __init__ ( self , hass : HomeAssistant , client : MeeseeksApiClient , ) -> None : \"\"\"Initialize the coordinator. Args: hass: Home Assistant core instance. client: API client for Meeseeks. \"\"\" self . client = client super () . __init__ ( hass = hass , logger = LOGGER , name = DOMAIN , update_interval = timedelta ( minutes = 5 ), )","title":"__init__"},{"location":"reference/#meeseeks_ha_conversation.exceptions","text":"The exceptions used by Extended OpenAI Conversation.","title":"exceptions"},{"location":"reference/#meeseeks_ha_conversation.exceptions.ApiClientError","text":"Bases: HomeAssistantError Exception to indicate a general API error. Source code in meeseeks_ha_conversation/exceptions.py 6 7 class ApiClientError ( HomeAssistantError ): \"\"\"Exception to indicate a general API error.\"\"\"","title":"ApiClientError"},{"location":"reference/#meeseeks_ha_conversation.exceptions.ApiCommError","text":"Bases: ApiClientError Exception to indicate a communication error. Source code in meeseeks_ha_conversation/exceptions.py 10 11 class ApiCommError ( ApiClientError ): \"\"\"Exception to indicate a communication error.\"\"\"","title":"ApiCommError"},{"location":"reference/#meeseeks_ha_conversation.exceptions.ApiJsonError","text":"Bases: ApiClientError Exception to indicate an error with json response. Source code in meeseeks_ha_conversation/exceptions.py 14 15 class ApiJsonError ( ApiClientError ): \"\"\"Exception to indicate an error with json response.\"\"\"","title":"ApiJsonError"},{"location":"reference/#meeseeks_ha_conversation.exceptions.ApiTimeoutError","text":"Bases: ApiClientError Exception to indicate a timeout error. Source code in meeseeks_ha_conversation/exceptions.py 18 19 class ApiTimeoutError ( ApiClientError ): \"\"\"Exception to indicate a timeout error.\"\"\"","title":"ApiTimeoutError"},{"location":"reference/#meeseeks_ha_conversation.helpers","text":"Helper functions for Meeseeks.","title":"helpers"},{"location":"reference/#meeseeks_ha_conversation.helpers.ExposedEntity","text":"Bases: TypedDict Typed representation of a Home Assistant entity exposed to conversation. Source code in meeseeks_ha_conversation/helpers.py 13 14 15 16 17 18 19 class ExposedEntity ( TypedDict ): \"\"\"Typed representation of a Home Assistant entity exposed to conversation.\"\"\" entity_id : str name : str state : str aliases : list [ str ]","title":"ExposedEntity"},{"location":"reference/#meeseeks_ha_conversation.helpers.get_exposed_entities","text":"Return exposed entities. Parameters: Name Type Description Default hass HomeAssistant Home Assistant core instance. required Returns: Type Description list [ ExposedEntity ] List of exposed entities and their metadata. Source code in meeseeks_ha_conversation/helpers.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 def get_exposed_entities ( hass : HomeAssistant ) -> list [ ExposedEntity ]: \"\"\"Return exposed entities. Args: hass: Home Assistant core instance. Returns: List of exposed entities and their metadata. \"\"\" hass_entity = entity_registry . async_get ( hass ) exposed_entities : list [ ExposedEntity ] = [] for state in hass . states . async_all (): if async_should_expose ( hass , CONVERSATION_DOMAIN , state . entity_id ): entity = hass_entity . async_get ( state . entity_id ) exposed_entities . append ( { \"entity_id\" : state . entity_id , \"name\" : state . name , \"state\" : state . state , \"aliases\" : entity . aliases if entity else [], } ) return exposed_entities","title":"get_exposed_entities"},{"location":"session-runtime/","text":"The session runtime is a small shared facade that powers both the CLI and the REST API. It centralizes session lifecycle, async run tracking, and cancellation. Event polling is exposed via the API; the CLI reads events directly in-process when needed. What it does Resolves sessions by id, tag, or fork. Runs orchestration synchronously or in a background thread. Tracks active runs per session and supports cancellation. Filters session events for polling ( after timestamp). Summarizes a session (title, status, done reason, context, archived flag). Filters empty sessions from listings; archived sessions are hidden unless requested. Core commands These commands are supported across interfaces: - /compact : compact the session transcript and write a summary. - /terminate : request cancellation for the active run. - /status : return the current session summary. The runtime only recognizes these core commands. Interface-specific commands remain in each UI layer. Event polling model (API) Events are stored as JSONL records by SessionStore . The runtime exposes load_events(session_id, after) which filters by the ISO-8601 timestamp ( ts ) on each event. Typical polling flow: 1. Create a session. 2. Start an async run. 3. Poll /events with after to receive only new records. Event payload notes: - action_plan payloads include steps: [{title, description}] . - Tool activity uses tool_id , operation , and tool_input in tool_result and permission events. Minimal usage (Python) from meeseeks_core.session_runtime import SessionRuntime from meeseeks_core.session_store import SessionStore runtime = SessionRuntime ( session_store = SessionStore ()) session_id = runtime . resolve_session ( session_tag = \"primary\" ) # synchronous run result = runtime . run_sync ( user_query = \"Hello\" , session_id = session_id ) # async run + polling runtime . start_async ( session_id = session_id , user_query = \"Do the task\" ) events = runtime . load_events ( session_id , after = None ) Archiving behavior SessionStore.archive_session(session_id) marks a session archived. SessionStore.unarchive_session(session_id) removes the archive flag. SessionRuntime.list_sessions() hides archived sessions by default. Use list_sessions(include_archived=True) to include them. Design goals Keep the core orchestration engine centralized. Make interface layers thin and easy to extend. Avoid duplicate session lifecycle logic.","title":"Session Runtime"},{"location":"session-runtime/#what-it-does","text":"Resolves sessions by id, tag, or fork. Runs orchestration synchronously or in a background thread. Tracks active runs per session and supports cancellation. Filters session events for polling ( after timestamp). Summarizes a session (title, status, done reason, context, archived flag). Filters empty sessions from listings; archived sessions are hidden unless requested.","title":"What it does"},{"location":"session-runtime/#core-commands","text":"These commands are supported across interfaces: - /compact : compact the session transcript and write a summary. - /terminate : request cancellation for the active run. - /status : return the current session summary. The runtime only recognizes these core commands. Interface-specific commands remain in each UI layer.","title":"Core commands"},{"location":"session-runtime/#event-polling-model-api","text":"Events are stored as JSONL records by SessionStore . The runtime exposes load_events(session_id, after) which filters by the ISO-8601 timestamp ( ts ) on each event. Typical polling flow: 1. Create a session. 2. Start an async run. 3. Poll /events with after to receive only new records. Event payload notes: - action_plan payloads include steps: [{title, description}] . - Tool activity uses tool_id , operation , and tool_input in tool_result and permission events.","title":"Event polling model (API)"},{"location":"session-runtime/#minimal-usage-python","text":"from meeseeks_core.session_runtime import SessionRuntime from meeseeks_core.session_store import SessionStore runtime = SessionRuntime ( session_store = SessionStore ()) session_id = runtime . resolve_session ( session_tag = \"primary\" ) # synchronous run result = runtime . run_sync ( user_query = \"Hello\" , session_id = session_id ) # async run + polling runtime . start_async ( session_id = session_id , user_query = \"Do the task\" ) events = runtime . load_events ( session_id , after = None )","title":"Minimal usage (Python)"},{"location":"session-runtime/#archiving-behavior","text":"SessionStore.archive_session(session_id) marks a session archived. SessionStore.unarchive_session(session_id) removes the archive flag. SessionRuntime.list_sessions() hides archived sessions by default. Use list_sessions(include_archived=True) to include them.","title":"Archiving behavior"},{"location":"session-runtime/#design-goals","text":"Keep the core orchestration engine centralized. Make interface layers thin and easy to extend. Avoid duplicate session lifecycle logic.","title":"Design goals"}]}