{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"bearlike/Assistant (Meeseeks) is an AI task agent assistant that breaks a request into small actions, runs the right tools, and replies with a clean summary. This landing page mirrors the README feature highlights so the overview stays consistent. Update both when core positioning changes. Documentation map Overview - README - high-level product overview and feature highlights - Core orchestration - execution flow and core features Setup and configuration - Installation - environment setup and install paths - LLM setup - minimum LLM config and LiteLLM notes Clients - CLI - terminal interface - Web + API - Streamlit chat UI and REST API - Home Assistant voice - HA Assist integration Developer - Developer guide - core abstractions and new client walkthrough Reference - API reference - mkdocstrings reference for core modules - Session runtime - shared runtime used by CLI + API Feature highlights (quick view) Plan \u2192 tool selection \u2192 step execution loop to keep work grounded in tool results. Multiple interfaces (chat UI, REST API, Home Assistant, terminal CLI) backed by one core engine. Tool registry for local tools plus optional MCP tools. Built-in local file and shell tools (Aider adapters) for edit blocks, read, list, and shell execution. Session transcripts with auto-compact for long runs and token budget awareness. Context snapshots built from recent turns plus summaries of prior activity. Session listings filter empty sessions and support archiving via the API. Step-level reflection after tool execution to validate outcomes and adjust tool inputs. Permission gate with approval callbacks plus lightweight hooks around tool execution. Shared session runtime; API exposes polling endpoints while the CLI runs the runtime in-process for sync execution, cancellation, and summaries. Event payloads: action_plan steps are {title, description} , tool events use tool_id , operation , and tool_input . External MCP servers can be added via configs/mcp.json with schema-aware tool inputs. LiteLLM multi-provider support with per-role model selection (plan, tool, default). Optional components (Langfuse, Home Assistant) auto-disable when not configured. Langfuse tracing is session-scoped when enabled, grouping multi-turn runs. Repo map (short) packages/meeseeks_core/ : orchestration loop, schemas, session storage, compaction, tool registry. packages/meeseeks_tools/ : tool implementations and integrations. apps/meeseeks_api/ : Flask API that exposes the assistant over HTTP. apps/meeseeks_chat/ : Streamlit UI for interactive chat. apps/meeseeks_cli/ : terminal CLI for interactive sessions. meeseeks_ha_conversation/ : Home Assistant integration that routes voice requests to the API. Prompts are packaged under packages/meeseeks_core/src/meeseeks_core/prompts/ . Architecture in a glance The UI or API sends a user request into the core orchestrator. The orchestrator builds a short action plan, runs tools, and replans if needed. Tool results and summaries are stored in a session transcript for continuity. flowchart LR User --> CLI User --> Chat User --> API HA --> API CLI --> Runtime Chat --> Runtime API --> Runtime Runtime --> Core Runtime --> SessionStore Runtime --> Planner Planner --> ToolSelector ToolSelector --> StepExecutor StepExecutor --> Tools Tools --> LocalTools Tools --> MCP Tools --> HomeAssistant Runtime --> Events[\"Session events (JSONL)\"] Events --> Polling[\"Event polling (API only)\"] Core --> Langfuse Getting started See Installation for setup, and CLI for command reference. Deployment (Docker) See getting-started.md for Docker setup and environment requirements.","title":"Home"},{"location":"#documentation-map","text":"Overview - README - high-level product overview and feature highlights - Core orchestration - execution flow and core features Setup and configuration - Installation - environment setup and install paths - LLM setup - minimum LLM config and LiteLLM notes Clients - CLI - terminal interface - Web + API - Streamlit chat UI and REST API - Home Assistant voice - HA Assist integration Developer - Developer guide - core abstractions and new client walkthrough Reference - API reference - mkdocstrings reference for core modules - Session runtime - shared runtime used by CLI + API","title":"Documentation map"},{"location":"#feature-highlights-quick-view","text":"Plan \u2192 tool selection \u2192 step execution loop to keep work grounded in tool results. Multiple interfaces (chat UI, REST API, Home Assistant, terminal CLI) backed by one core engine. Tool registry for local tools plus optional MCP tools. Built-in local file and shell tools (Aider adapters) for edit blocks, read, list, and shell execution. Session transcripts with auto-compact for long runs and token budget awareness. Context snapshots built from recent turns plus summaries of prior activity. Session listings filter empty sessions and support archiving via the API. Step-level reflection after tool execution to validate outcomes and adjust tool inputs. Permission gate with approval callbacks plus lightweight hooks around tool execution. Shared session runtime; API exposes polling endpoints while the CLI runs the runtime in-process for sync execution, cancellation, and summaries. Event payloads: action_plan steps are {title, description} , tool events use tool_id , operation , and tool_input . External MCP servers can be added via configs/mcp.json with schema-aware tool inputs. LiteLLM multi-provider support with per-role model selection (plan, tool, default). Optional components (Langfuse, Home Assistant) auto-disable when not configured. Langfuse tracing is session-scoped when enabled, grouping multi-turn runs.","title":"Feature highlights (quick view)"},{"location":"#repo-map-short","text":"packages/meeseeks_core/ : orchestration loop, schemas, session storage, compaction, tool registry. packages/meeseeks_tools/ : tool implementations and integrations. apps/meeseeks_api/ : Flask API that exposes the assistant over HTTP. apps/meeseeks_chat/ : Streamlit UI for interactive chat. apps/meeseeks_cli/ : terminal CLI for interactive sessions. meeseeks_ha_conversation/ : Home Assistant integration that routes voice requests to the API. Prompts are packaged under packages/meeseeks_core/src/meeseeks_core/prompts/ .","title":"Repo map (short)"},{"location":"#architecture-in-a-glance","text":"The UI or API sends a user request into the core orchestrator. The orchestrator builds a short action plan, runs tools, and replans if needed. Tool results and summaries are stored in a session transcript for continuity. flowchart LR User --> CLI User --> Chat User --> API HA --> API CLI --> Runtime Chat --> Runtime API --> Runtime Runtime --> Core Runtime --> SessionStore Runtime --> Planner Planner --> ToolSelector ToolSelector --> StepExecutor StepExecutor --> Tools Tools --> LocalTools Tools --> MCP Tools --> HomeAssistant Runtime --> Events[\"Session events (JSONL)\"] Events --> Polling[\"Event polling (API only)\"] Core --> Langfuse","title":"Architecture in a glance"},{"location":"#getting-started","text":"See Installation for setup, and CLI for command reference.","title":"Getting started"},{"location":"#deployment-docker","text":"See getting-started.md for Docker setup and environment requirements.","title":"Deployment (Docker)"},{"location":"clients-cli/","text":"Your browser does not support the video tag. The CLI client lives in apps/meeseeks_cli/ . It is a terminal-native client for developers working in the local environment, running the core runtime in-process and executing tools directly against local files and shell commands. The key distinction from the Meeseeks Console (web client) is execution context and autonomy: the CLI operates directly on the local machine, while the web client delegates through the API. Both clients share the same core runtime and can run long-lived tasks. Setup (uv) uv sync --extra cli Before running, complete Installation and LLM setup . Run uv run meeseeks CLI flags Flag Purpose --query \"...\" Run a single query and exit. --model MODEL_NAME Override the configured model for this run. --max-iters N Maximum orchestration iterations (default: 3). --show-plan Show the action plan (default). --no-plan Hide the action plan. -v , --verbose Increase log verbosity ( -v = debug, -vv = trace). --debug Hidden debug flag for CLI logging. --session SESSION_ID Resume a session by id. --tag TAG Resume or create a tagged session. --fork SESSION_OR_TAG Fork from another session. --session-dir PATH Override transcript storage path. --history-file PATH Override CLI history file path. --no-color Disable ANSI color output. --auto-approve Auto-approve tool permissions for the session. Slash commands Command Description Notes /help Show help. /exit Exit the CLI. /quit Exit the CLI. Alias for /exit . /new Start a new session. /session Show current session id. /summary Show current session summary. /summarize Summarize and compact this session. Uses /compact under the hood. /compact Compact session transcript. Alias for /summarize . /status Show current session status. /terminate Cancel the active session run. /tag NAME Tag this session. /fork [TAG] Fork the current session. Optional tag for the forked session. /plan on\\|off Toggle plan display. /mode act\\|plan Set orchestration mode. /mcp List MCP tools and servers. Use /mcp select or /mcp init . /config Manage config files. Use /config init . /init Scaffold app + MCP example configs. /models Open the model selection wizard. Interactive mode only. /automatic [on\\|off] Auto-approve tool actions. Use --yes to confirm in non-interactive mode. /tokens Show token usage and remaining context. /budget Show token usage and remaining context. Alias for /tokens .","title":"CLI"},{"location":"clients-cli/#setup-uv","text":"uv sync --extra cli Before running, complete Installation and LLM setup .","title":"Setup (uv)"},{"location":"clients-cli/#run","text":"uv run meeseeks","title":"Run"},{"location":"clients-cli/#cli-flags","text":"Flag Purpose --query \"...\" Run a single query and exit. --model MODEL_NAME Override the configured model for this run. --max-iters N Maximum orchestration iterations (default: 3). --show-plan Show the action plan (default). --no-plan Hide the action plan. -v , --verbose Increase log verbosity ( -v = debug, -vv = trace). --debug Hidden debug flag for CLI logging. --session SESSION_ID Resume a session by id. --tag TAG Resume or create a tagged session. --fork SESSION_OR_TAG Fork from another session. --session-dir PATH Override transcript storage path. --history-file PATH Override CLI history file path. --no-color Disable ANSI color output. --auto-approve Auto-approve tool permissions for the session.","title":"CLI flags"},{"location":"clients-cli/#slash-commands","text":"Command Description Notes /help Show help. /exit Exit the CLI. /quit Exit the CLI. Alias for /exit . /new Start a new session. /session Show current session id. /summary Show current session summary. /summarize Summarize and compact this session. Uses /compact under the hood. /compact Compact session transcript. Alias for /summarize . /status Show current session status. /terminate Cancel the active session run. /tag NAME Tag this session. /fork [TAG] Fork the current session. Optional tag for the forked session. /plan on\\|off Toggle plan display. /mode act\\|plan Set orchestration mode. /mcp List MCP tools and servers. Use /mcp select or /mcp init . /config Manage config files. Use /config init . /init Scaffold app + MCP example configs. /models Open the model selection wizard. Interactive mode only. /automatic [on\\|off] Auto-approve tool actions. Use --yes to confirm in non-interactive mode. /tokens Show token usage and remaining context. /budget Show token usage and remaining context. Alias for /tokens .","title":"Slash commands"},{"location":"clients-home-assistant/","text":"The Home Assistant integration lives in meeseeks_ha_conversation/ and proxies voice requests to the API. It is designed for hands-free voice control: HA handles wake words and intent capture, then forwards the request to the API for orchestration and responses. Setup (uv) uv sync --extra api --extra ha Before running, complete Installation and LLM setup . Install the custom component Ensure the API is running (see Web + API ). Copy the contents of meeseeks_ha_conversation/ into Home Assistant under custom_components/meeseeks_conversation/ . In Home Assistant, add the \"Meeseeks\" conversation integration and set: Base URL: the API base URL (for example, http://host:5123 ). API key: the API master token ( api.master_token in configs/app.json ). Optional: enable the Home Assistant tool If bearlike/Assistant should control Home Assistant entities directly: - Set home_assistant.enabled to true in configs/app.json . - Provide the Home Assistant URL and token in home_assistant.* .","title":"Home Assistant Voice"},{"location":"clients-home-assistant/#setup-uv","text":"uv sync --extra api --extra ha Before running, complete Installation and LLM setup .","title":"Setup (uv)"},{"location":"clients-home-assistant/#install-the-custom-component","text":"Ensure the API is running (see Web + API ). Copy the contents of meeseeks_ha_conversation/ into Home Assistant under custom_components/meeseeks_conversation/ . In Home Assistant, add the \"Meeseeks\" conversation integration and set: Base URL: the API base URL (for example, http://host:5123 ). API key: the API master token ( api.master_token in configs/app.json ).","title":"Install the custom component"},{"location":"clients-home-assistant/#optional-enable-the-home-assistant-tool","text":"If bearlike/Assistant should control Home Assistant entities directly: - Set home_assistant.enabled to true in configs/app.json . - Provide the Home Assistant URL and token in home_assistant.* .","title":"Optional: enable the Home Assistant tool"},{"location":"clients-web-api/","text":"The REST API lives in apps/meeseeks_api/ and the Streamlit UI lives in apps/meeseeks_chat/ . The web client (Meeseeks Console) is built for asynchronous delegation: work runs through the API and the UI polls events for status and output. The distinction from the CLI is execution context and autonomy: the web client executes through the API service, while the CLI runs tools directly on the local machine. Both clients share the same core runtime and can handle long-running tasks. Setup (uv) uv sync --extra api --extra chat Before running, complete Installation and LLM setup . Run the REST API uv run meeseeks-api API notes: Protected routes require X-API-Key matching api.master_token in configs/app.json . Session runtime endpoints support async runs and event polling. Core endpoints: POST /api/sessions create a session POST /api/sessions/{session_id}/query enqueue a query or core command GET /api/sessions/{session_id}/events?after=... poll events GET /api/sessions list sessions (defaults to non-archived, non-empty) GET /api/sessions?include_archived=1 include archived sessions POST /api/sessions/{session_id}/archive archive a session DELETE /api/sessions/{session_id}/archive unarchive a session POST /api/query synchronous endpoint GET /api/tools list tool registry entries GET /api/notifications list notifications POST /api/notifications/dismiss dismiss notifications POST /api/notifications/clear clear notifications POST /api/sessions/{session_id}/attachments upload attachments POST /api/sessions/{session_id}/share create share link POST /api/sessions/{session_id}/export export session payload GET /api/share/{token} fetch shared session data Run the web UI (Streamlit) uv run meeseeks-chat UI notes: - Streamlit options live under chat.* in configs/app.json (address and port). - The chat UI runs the core engine in-process.","title":"Web + API"},{"location":"clients-web-api/#setup-uv","text":"uv sync --extra api --extra chat Before running, complete Installation and LLM setup .","title":"Setup (uv)"},{"location":"clients-web-api/#run-the-rest-api","text":"uv run meeseeks-api API notes: Protected routes require X-API-Key matching api.master_token in configs/app.json . Session runtime endpoints support async runs and event polling. Core endpoints: POST /api/sessions create a session POST /api/sessions/{session_id}/query enqueue a query or core command GET /api/sessions/{session_id}/events?after=... poll events GET /api/sessions list sessions (defaults to non-archived, non-empty) GET /api/sessions?include_archived=1 include archived sessions POST /api/sessions/{session_id}/archive archive a session DELETE /api/sessions/{session_id}/archive unarchive a session POST /api/query synchronous endpoint GET /api/tools list tool registry entries GET /api/notifications list notifications POST /api/notifications/dismiss dismiss notifications POST /api/notifications/clear clear notifications POST /api/sessions/{session_id}/attachments upload attachments POST /api/sessions/{session_id}/share create share link POST /api/sessions/{session_id}/export export session payload GET /api/share/{token} fetch shared session data","title":"Run the REST API"},{"location":"clients-web-api/#run-the-web-ui-streamlit","text":"uv run meeseeks-chat UI notes: - Streamlit options live under chat.* in configs/app.json (address and port). - The chat UI runs the core engine in-process.","title":"Run the web UI (Streamlit)"},{"location":"components/","text":"Component documentation has moved to the Developer guide .","title":"Components"},{"location":"core-orchestration/","text":"This page summarizes the orchestration loop, core components, and operational features for bearlike/Assistant. Execution flow Input arrives from a client (CLI, API, chat, or Home Assistant integration). The orchestrator builds a context snapshot (summary, recent events, and selected history). A planner produces a plan; tool selection narrows allowed tools when needed. Steps run through the action runner with permission checks and tool schemas applied. Results are synthesized into a response and written to the session transcript. Core components Orchestrator ( meeseeks_core.orchestrator.Orchestrator ): plan/act loop and session-scoped execution. Planner / ToolSelector / StepExecutor / PlanUpdater / ResponseSynthesizer ( meeseeks_core.planning ): plan generation, tool choice, step decisions, plan updates, and response output. ActionPlanRunner ( meeseeks_core.action_runner.ActionPlanRunner ): executes action steps and applies permission policies. SessionRuntime ( meeseeks_core.session_runtime.SessionRuntime ): shared facade for CLI and API. SessionStore ( meeseeks_core.session_store.SessionStore ): transcript + summary storage. ToolRegistry ( meeseeks_core.tool_registry.ToolRegistry ): local tools and external MCP tools. Feature highlights Auto-compact runs when token budget or event thresholds are reached; /compact forces a summary pass. Token thresholds are configured with token_budget.auto_compact_threshold . Step reflection validates tool outcomes before results are finalized. Langfuse tracing is session-scoped when enabled, keeping multi-turn work in one trace context. External MCP servers are supported via configs/mcp.json and auto-discovered at startup. LiteLLM-backed chat models support multiple providers and model aliases; different models can be used for planning and tool execution. Permission policies gate tool execution; approvals can be automatic, denied, or prompted. Extensibility points Add tools by implementing AbstractTool or by registering MCP servers with schemas. Add hooks through HookManager for pre/post events and compaction transforms. Add new interfaces by reusing SessionRuntime and the event transcript model.","title":"Core Orchestration"},{"location":"core-orchestration/#execution-flow","text":"Input arrives from a client (CLI, API, chat, or Home Assistant integration). The orchestrator builds a context snapshot (summary, recent events, and selected history). A planner produces a plan; tool selection narrows allowed tools when needed. Steps run through the action runner with permission checks and tool schemas applied. Results are synthesized into a response and written to the session transcript.","title":"Execution flow"},{"location":"core-orchestration/#core-components","text":"Orchestrator ( meeseeks_core.orchestrator.Orchestrator ): plan/act loop and session-scoped execution. Planner / ToolSelector / StepExecutor / PlanUpdater / ResponseSynthesizer ( meeseeks_core.planning ): plan generation, tool choice, step decisions, plan updates, and response output. ActionPlanRunner ( meeseeks_core.action_runner.ActionPlanRunner ): executes action steps and applies permission policies. SessionRuntime ( meeseeks_core.session_runtime.SessionRuntime ): shared facade for CLI and API. SessionStore ( meeseeks_core.session_store.SessionStore ): transcript + summary storage. ToolRegistry ( meeseeks_core.tool_registry.ToolRegistry ): local tools and external MCP tools.","title":"Core components"},{"location":"core-orchestration/#feature-highlights","text":"Auto-compact runs when token budget or event thresholds are reached; /compact forces a summary pass. Token thresholds are configured with token_budget.auto_compact_threshold . Step reflection validates tool outcomes before results are finalized. Langfuse tracing is session-scoped when enabled, keeping multi-turn work in one trace context. External MCP servers are supported via configs/mcp.json and auto-discovered at startup. LiteLLM-backed chat models support multiple providers and model aliases; different models can be used for planning and tool execution. Permission policies gate tool execution; approvals can be automatic, denied, or prompted.","title":"Feature highlights"},{"location":"core-orchestration/#extensibility-points","text":"Add tools by implementing AbstractTool or by registering MCP servers with schemas. Add hooks through HookManager for pre/post events and compaction transforms. Add new interfaces by reusing SessionRuntime and the event transcript model.","title":"Extensibility points"},{"location":"developer-guide/","text":"This page summarizes the code layout, core interfaces, and the minimal steps needed to build a new client. Monorepo layout packages/meeseeks_core/ : orchestration loop, session runtime, schemas, session storage, compaction, tool registry. packages/meeseeks_tools/ : tool implementations and integration glue. packages/meeseeks_tools/src/meeseeks_tools/vendor/aider : vendored Aider utilities used by local file + shell tools. apps/meeseeks_api/ : Flask API that exposes the assistant over HTTP. apps/meeseeks_chat/ : Streamlit UI for interactive chat. apps/meeseeks_cli/ : terminal CLI for interactive sessions. meeseeks_ha_conversation/ : Home Assistant integration that routes voice requests to the API. Core abstractions and interfaces AbstractTool ( meeseeks_core.classes ): base class for local tools; implement get_state and set_state and return a MockSpeaker . ToolRunner protocol ( meeseeks_core.tool_registry ): interface for tool runners with run(ActionStep) . ToolSpec / ToolRegistry ( meeseeks_core.tool_registry ): register tools with tool_id , metadata, and a factory. ActionStep , Plan , TaskQueue ( meeseeks_core.classes ): planning and tool-execution payloads. PermissionPolicy ( meeseeks_core.permissions ): allow/deny/ask rules for tool execution. HookManager ( meeseeks_core.hooks ): pre/post hooks and compaction transforms. SessionStore / SessionRuntime ( meeseeks_core.session_store , meeseeks_core.session_runtime ): transcripts and the shared runtime facade. ChatModel protocol ( meeseeks_core.llm ): interface for LLM backends via build_chat_model . New client walkthrough (concrete steps) Load config and initialize core services: load_registry() for tool registration. load_permission_policy() and approval_callback_from_config() for approvals. SessionStore() and SessionRuntime() for transcripts and runs. Resolve or create a session id using SessionRuntime.resolve_session() . Handle core slash commands ( /compact , /status , /terminate ) with parse_core_command() . Execute the request: run_sync() for synchronous use cases. start_async() + load_events(after=...) for polling flows. Emit and consume session events: action_plan when a plan is generated. permission decisions when approvals are requested or denied. tool_result for each tool execution (includes tool_id , operation , tool_input , and result ). step_reflection when the reflector requests a revision. assistant and completion for final output and status. Logging: Use get_logger() for module logging. Use session_log_context(session_id) to capture per-session logs. Minimal sync example from meeseeks_core.common import get_logger from meeseeks_core.permissions import approval_callback_from_config , load_permission_policy from meeseeks_core.session_runtime import SessionRuntime , parse_core_command from meeseeks_core.session_store import SessionStore from meeseeks_core.tool_registry import load_registry logger = get_logger ( \"client\" ) session_store = SessionStore () tool_registry = load_registry () runtime = SessionRuntime ( session_store = session_store ) session_id = runtime . resolve_session ( session_tag = \"client\" ) user_text = \"Hello from the client\" command = parse_core_command ( user_text ) if command : logger . info ( \"Handled command: {} \" , command ) else : result = runtime . run_sync ( session_id = session_id , user_query = user_text , tool_registry = tool_registry , permission_policy = load_permission_policy (), approval_callback = approval_callback_from_config (), ) logger . info ( \"Task result: {} \" , result . task_result ) Implementing a local tool Subclass AbstractTool and implement get_state / set_state . Register the tool with a ToolSpec factory in the registry. from meeseeks_core.classes import AbstractTool , ActionStep from meeseeks_core.common import get_mock_speaker from meeseeks_core.tool_registry import ToolRegistry , ToolSpec class ExampleTool ( AbstractTool ): def __init__ ( self ) -> None : super () . __init__ ( name = \"Example\" , description = \"Example tool\" ) def get_state ( self , action_step : ActionStep | None = None ): return get_mock_speaker ()( content = \"Example read\" ) def set_state ( self , action_step : ActionStep | None = None ): return get_mock_speaker ()( content = \"Example write\" ) registry = ToolRegistry () registry . register ( ToolSpec ( tool_id = \"example_tool\" , name = \"Example\" , description = \"Example local tool\" , factory = ExampleTool , ) )","title":"Developer Guide"},{"location":"developer-guide/#monorepo-layout","text":"packages/meeseeks_core/ : orchestration loop, session runtime, schemas, session storage, compaction, tool registry. packages/meeseeks_tools/ : tool implementations and integration glue. packages/meeseeks_tools/src/meeseeks_tools/vendor/aider : vendored Aider utilities used by local file + shell tools. apps/meeseeks_api/ : Flask API that exposes the assistant over HTTP. apps/meeseeks_chat/ : Streamlit UI for interactive chat. apps/meeseeks_cli/ : terminal CLI for interactive sessions. meeseeks_ha_conversation/ : Home Assistant integration that routes voice requests to the API.","title":"Monorepo layout"},{"location":"developer-guide/#core-abstractions-and-interfaces","text":"AbstractTool ( meeseeks_core.classes ): base class for local tools; implement get_state and set_state and return a MockSpeaker . ToolRunner protocol ( meeseeks_core.tool_registry ): interface for tool runners with run(ActionStep) . ToolSpec / ToolRegistry ( meeseeks_core.tool_registry ): register tools with tool_id , metadata, and a factory. ActionStep , Plan , TaskQueue ( meeseeks_core.classes ): planning and tool-execution payloads. PermissionPolicy ( meeseeks_core.permissions ): allow/deny/ask rules for tool execution. HookManager ( meeseeks_core.hooks ): pre/post hooks and compaction transforms. SessionStore / SessionRuntime ( meeseeks_core.session_store , meeseeks_core.session_runtime ): transcripts and the shared runtime facade. ChatModel protocol ( meeseeks_core.llm ): interface for LLM backends via build_chat_model .","title":"Core abstractions and interfaces"},{"location":"developer-guide/#new-client-walkthrough-concrete-steps","text":"Load config and initialize core services: load_registry() for tool registration. load_permission_policy() and approval_callback_from_config() for approvals. SessionStore() and SessionRuntime() for transcripts and runs. Resolve or create a session id using SessionRuntime.resolve_session() . Handle core slash commands ( /compact , /status , /terminate ) with parse_core_command() . Execute the request: run_sync() for synchronous use cases. start_async() + load_events(after=...) for polling flows. Emit and consume session events: action_plan when a plan is generated. permission decisions when approvals are requested or denied. tool_result for each tool execution (includes tool_id , operation , tool_input , and result ). step_reflection when the reflector requests a revision. assistant and completion for final output and status. Logging: Use get_logger() for module logging. Use session_log_context(session_id) to capture per-session logs.","title":"New client walkthrough (concrete steps)"},{"location":"developer-guide/#minimal-sync-example","text":"from meeseeks_core.common import get_logger from meeseeks_core.permissions import approval_callback_from_config , load_permission_policy from meeseeks_core.session_runtime import SessionRuntime , parse_core_command from meeseeks_core.session_store import SessionStore from meeseeks_core.tool_registry import load_registry logger = get_logger ( \"client\" ) session_store = SessionStore () tool_registry = load_registry () runtime = SessionRuntime ( session_store = session_store ) session_id = runtime . resolve_session ( session_tag = \"client\" ) user_text = \"Hello from the client\" command = parse_core_command ( user_text ) if command : logger . info ( \"Handled command: {} \" , command ) else : result = runtime . run_sync ( session_id = session_id , user_query = user_text , tool_registry = tool_registry , permission_policy = load_permission_policy (), approval_callback = approval_callback_from_config (), ) logger . info ( \"Task result: {} \" , result . task_result )","title":"Minimal sync example"},{"location":"developer-guide/#implementing-a-local-tool","text":"Subclass AbstractTool and implement get_state / set_state . Register the tool with a ToolSpec factory in the registry. from meeseeks_core.classes import AbstractTool , ActionStep from meeseeks_core.common import get_mock_speaker from meeseeks_core.tool_registry import ToolRegistry , ToolSpec class ExampleTool ( AbstractTool ): def __init__ ( self ) -> None : super () . __init__ ( name = \"Example\" , description = \"Example tool\" ) def get_state ( self , action_step : ActionStep | None = None ): return get_mock_speaker ()( content = \"Example read\" ) def set_state ( self , action_step : ActionStep | None = None ): return get_mock_speaker ()( content = \"Example write\" ) registry = ToolRegistry () registry . register ( ToolSpec ( tool_id = \"example_tool\" , name = \"Example\" , description = \"Example local tool\" , factory = ExampleTool , ) )","title":"Implementing a local tool"},{"location":"getting-started/","text":"This guide covers local installation and environment setup for bearlike/Assistant. Prerequisites Python 3.10+ uv Docker (optional, for container runs) Install dependencies User installation (core only) uv sync Optional components (from project root) CLI: uv sync --extra cli API: uv sync --extra api Chat UI: uv sync --extra chat Home Assistant integration: uv sync --extra ha Tools bundle: uv sync --extra tools Everything optional: uv sync --all-extras Developer installation (all components + dev/test/docs) uv sync --all-extras --all-groups Git hooks (recommended) Use the repo hook set to enforce commit message format and block pushes that fail linting/tests. Install the repo-managed hooks: git config core.hooksPath scripts/githooks Optional: enable pre-commit hooks if you use pre-commit locally: make precommit-install Commit message format: <emoji> <verb>(<scope>): <message> Pre-push runs: - scripts/ci/check.sh (ruff format/check, mypy, pytest) Configuration setup If configs are missing, run /config init , /mcp init , or /init from the CLI to scaffold examples. Use only JSON configs under configs/ : configs/app.json (runtime + LLM + integrations) configs/mcp.json (MCP servers) configs/*.example.json are templates for new installs Update configs/app.json with your runtime settings. For required LLM keys and a walkthrough, see LLM setup . MCP setup See LLM setup for MCP configuration and auto-discovery details. Optional components Langfuse: set langfuse.enabled + keys in configs/app.json . Home Assistant: set home_assistant.enabled + credentials in configs/app.json . CLI approval UI Default approval prompts render as a Rich panel with padded, dotted borders. Use /automatic or --auto-approve to bypass prompts when appropriate. Run interfaces (local) CLI: uv run meeseeks (details in CLI client ) API + Web: uv run meeseeks-api and uv run meeseeks-chat (details in Web + API ) Home Assistant: see Home Assistant voice Aider edit blocks (local tool) The edit-block tool expects strict SEARCH/REPLACE blocks and returns format guidance on mismatches. <path> ```text <<<<<<< SEARCH <exact text to match> ======= <replacement text> >>>>>>> REPLACE ``` Rules: - Filename line immediately before the opening fence. - SEARCH must match exactly (including whitespace/newlines). - Use a line with ... in both SEARCH and REPLACE to skip unchanged sections. Docker (optional) Build images using docker/Dockerfile.api and docker/Dockerfile.chat . Mount configs/app.json (and configs/mcp.json if you use MCP). Persist data/sessions if you want transcripts across restarts. Docs (optional) If you want to build the docs locally: uv sync --all-extras --group docs uv run mkdocs serve","title":"Installation"},{"location":"getting-started/#prerequisites","text":"Python 3.10+ uv Docker (optional, for container runs)","title":"Prerequisites"},{"location":"getting-started/#install-dependencies","text":"","title":"Install dependencies"},{"location":"getting-started/#user-installation-core-only","text":"uv sync","title":"User installation (core only)"},{"location":"getting-started/#optional-components-from-project-root","text":"CLI: uv sync --extra cli API: uv sync --extra api Chat UI: uv sync --extra chat Home Assistant integration: uv sync --extra ha Tools bundle: uv sync --extra tools Everything optional: uv sync --all-extras","title":"Optional components (from project root)"},{"location":"getting-started/#developer-installation-all-components-devtestdocs","text":"uv sync --all-extras --all-groups","title":"Developer installation (all components + dev/test/docs)"},{"location":"getting-started/#git-hooks-recommended","text":"Use the repo hook set to enforce commit message format and block pushes that fail linting/tests. Install the repo-managed hooks: git config core.hooksPath scripts/githooks Optional: enable pre-commit hooks if you use pre-commit locally: make precommit-install Commit message format: <emoji> <verb>(<scope>): <message> Pre-push runs: - scripts/ci/check.sh (ruff format/check, mypy, pytest)","title":"Git hooks (recommended)"},{"location":"getting-started/#configuration-setup","text":"If configs are missing, run /config init , /mcp init , or /init from the CLI to scaffold examples. Use only JSON configs under configs/ : configs/app.json (runtime + LLM + integrations) configs/mcp.json (MCP servers) configs/*.example.json are templates for new installs Update configs/app.json with your runtime settings. For required LLM keys and a walkthrough, see LLM setup .","title":"Configuration setup"},{"location":"getting-started/#mcp-setup","text":"See LLM setup for MCP configuration and auto-discovery details.","title":"MCP setup"},{"location":"getting-started/#optional-components","text":"Langfuse: set langfuse.enabled + keys in configs/app.json . Home Assistant: set home_assistant.enabled + credentials in configs/app.json .","title":"Optional components"},{"location":"getting-started/#cli-approval-ui","text":"Default approval prompts render as a Rich panel with padded, dotted borders. Use /automatic or --auto-approve to bypass prompts when appropriate.","title":"CLI approval UI"},{"location":"getting-started/#run-interfaces-local","text":"CLI: uv run meeseeks (details in CLI client ) API + Web: uv run meeseeks-api and uv run meeseeks-chat (details in Web + API ) Home Assistant: see Home Assistant voice","title":"Run interfaces (local)"},{"location":"getting-started/#aider-edit-blocks-local-tool","text":"The edit-block tool expects strict SEARCH/REPLACE blocks and returns format guidance on mismatches. <path> ```text <<<<<<< SEARCH <exact text to match> ======= <replacement text> >>>>>>> REPLACE ``` Rules: - Filename line immediately before the opening fence. - SEARCH must match exactly (including whitespace/newlines). - Use a line with ... in both SEARCH and REPLACE to skip unchanged sections.","title":"Aider edit blocks (local tool)"},{"location":"getting-started/#docker-optional","text":"Build images using docker/Dockerfile.api and docker/Dockerfile.chat . Mount configs/app.json (and configs/mcp.json if you use MCP). Persist data/sessions if you want transcripts across restarts.","title":"Docker (optional)"},{"location":"getting-started/#docs-optional","text":"If you want to build the docs locally: uv sync --all-extras --group docs uv run mkdocs serve","title":"Docs (optional)"},{"location":"llm-setup/","text":"This page covers the minimum LLM configuration required to run bearlike/Assistant. Minimum configuration Set these keys in configs/app.json : { \"llm\" : { \"api_base\" : \"https://your-llm-endpoint/v1\" , \"api_key\" : \"sk-your-key\" , \"default_model\" : \"gpt-5.2\" } } See the optional configuration table below. Optional LLM configuration Key Purpose Notes llm.action_plan_model Model for plan generation. Falls back to llm.default_model if unset. llm.tool_model Model for tool execution. Falls back to llm.action_plan_model , then llm.default_model . llm.reasoning_effort Default reasoning effort level. Values: low , medium , high , none . llm.reasoning_effort_models Allowlist for reasoning effort. Supports exact matches and * suffix wildcards. Short walkthrough Copy the example config: cp configs/app.example.json configs/app.json Edit the llm block with the API base, API key, and model names. Start a client (CLI, API, or chat). See the client pages for run commands. MCP setup MCP servers are optional. When enabled, they add external tools to the registry. Create configs/mcp.json (or run /mcp init in the CLI). Add MCP server URLs and headers. Start a client once to auto-discover tools and cache the manifest under ~/.meeseeks/ . For more details, see Installation . LiteLLM provider support The LLM layer is backed by LiteLLM via langchain-litellm . Model names can include provider prefixes (for example, openai/gpt-4-turbo , anthropic/claude-3-sonnet , or mistral/mistral-small ). If llm.api_base is set and a model has no provider prefix, the system defaults to openai/<model> to match OpenAI-style endpoints.","title":"LLM Setup"},{"location":"llm-setup/#minimum-configuration","text":"Set these keys in configs/app.json : { \"llm\" : { \"api_base\" : \"https://your-llm-endpoint/v1\" , \"api_key\" : \"sk-your-key\" , \"default_model\" : \"gpt-5.2\" } } See the optional configuration table below.","title":"Minimum configuration"},{"location":"llm-setup/#optional-llm-configuration","text":"Key Purpose Notes llm.action_plan_model Model for plan generation. Falls back to llm.default_model if unset. llm.tool_model Model for tool execution. Falls back to llm.action_plan_model , then llm.default_model . llm.reasoning_effort Default reasoning effort level. Values: low , medium , high , none . llm.reasoning_effort_models Allowlist for reasoning effort. Supports exact matches and * suffix wildcards.","title":"Optional LLM configuration"},{"location":"llm-setup/#short-walkthrough","text":"Copy the example config: cp configs/app.example.json configs/app.json Edit the llm block with the API base, API key, and model names. Start a client (CLI, API, or chat). See the client pages for run commands.","title":"Short walkthrough"},{"location":"llm-setup/#mcp-setup","text":"MCP servers are optional. When enabled, they add external tools to the registry. Create configs/mcp.json (or run /mcp init in the CLI). Add MCP server URLs and headers. Start a client once to auto-discover tools and cache the manifest under ~/.meeseeks/ . For more details, see Installation .","title":"MCP setup"},{"location":"llm-setup/#litellm-provider-support","text":"The LLM layer is backed by LiteLLM via langchain-litellm . Model names can include provider prefixes (for example, openai/gpt-4-turbo , anthropic/claude-3-sonnet , or mistral/mistral-small ). If llm.api_base is set and a model has no provider prefix, the system defaults to openai/<model> to match OpenAI-style endpoints.","title":"LiteLLM provider support"},{"location":"reference/","text":"This page is generated from inline docstrings via mkdocstrings. The sections below are grouped by package or client. packages/meeseeks_core (core runtime) meeseeks_core.orchestrator Session orchestration entrypoint. Orchestrator Plan-act-observe orchestration loop. Source code in packages/meeseeks_core/src/meeseeks_core/orchestrator.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 class Orchestrator : \"\"\"Plan-act-observe orchestration loop.\"\"\" def __init__ ( self , * , model_name : str | None = None , session_store : SessionStore | None = None , tool_registry : ToolRegistry | None = None , permission_policy : PermissionPolicy | None = None , approval_callback : Callable [[ ActionStep ], bool ] | None = None , hook_manager : HookManager | None = None , ) -> None : \"\"\"Initialize orchestration dependencies.\"\"\" self . _model_name = ( model_name or get_config_value ( \"llm\" , \"action_plan_model\" ) or get_config_value ( \"llm\" , \"default_model\" , default = \"gpt-5.2\" ) ) self . _session_store = session_store or SessionStore () self . _tool_registry = tool_registry or load_registry () self . _permission_policy = permission_policy or load_permission_policy () self . _approval_callback = approval_callback or approval_callback_from_config () self . _hook_manager = hook_manager or default_hook_manager () self . _context_builder = ContextBuilder ( self . _session_store ) self . _planner = Planner ( self . _tool_registry ) self . _tool_selector = ToolSelector ( self . _tool_registry ) self . _step_executor = StepExecutor ( self . _tool_registry ) self . _plan_updater = PlanUpdater ( self . _tool_registry ) self . _synthesizer = ResponseSynthesizer ( self . _tool_registry ) def run ( self , user_query : str , * , max_iters : int = 3 , initial_plan : Plan | None = None , return_state : bool = False , session_id : str | None = None , mode : str | None = None , should_cancel : Callable [[], bool ] | None = None , ) -> TaskQueue | tuple [ TaskQueue , OrchestrationState ]: \"\"\"Run a plan-act-observe loop for a session.\"\"\" if session_id is None : session_id = self . _session_store . create_session () with session_log_context ( session_id ): with langfuse_session_context ( session_id ): return self . _run_with_session_context ( user_query , max_iters = max_iters , initial_plan = initial_plan , return_state = return_state , session_id = session_id , mode = mode , should_cancel = should_cancel , ) def _run_with_session_context ( self , user_query : str , * , max_iters : int , initial_plan : Plan | None , return_state : bool , session_id : str , mode : str | None , should_cancel : Callable [[], bool ] | None , ) -> TaskQueue | tuple [ TaskQueue , OrchestrationState ]: \"\"\"Run orchestration with Langfuse session context set.\"\"\" state = OrchestrationState ( goal = user_query , session_id = session_id ) resolved_mode = self . _resolve_mode ( user_query , mode ) state . summary = self . _session_store . load_summary ( session_id ) state . tool_results = state . tool_results or [] state . open_questions = state . open_questions or [] task_queue : TaskQueue | None = None try : self . _session_store . append_event ( session_id , { \"type\" : \"user\" , \"payload\" : { \"text\" : user_query }} ) if self . _should_update_summary ( user_query ): state . summary = self . _update_summary_with_memory ( session_id , user_query . strip (), ) updated_summary = self . _maybe_auto_compact ( session_id ) if updated_summary : state . summary = updated_summary if user_query . strip () == \"/compact\" : summary = summarize_events ( self . _session_store . load_transcript ( session_id )) self . _session_store . save_summary ( session_id , summary ) state . summary = summary state . done = True state . done_reason = \"compacted\" task_queue = self . _build_direct_response ( f \"Compaction complete. Summary: { summary } \" ) return ( task_queue , state ) if return_state else task_queue context = self . _context_builder . build ( session_id = session_id , user_query = user_query , model_name = self . _model_name , ) plan = initial_plan tool_specs = ( self . _tool_registry . list_specs () if resolved_mode == \"plan\" else self . _tool_registry . list_specs_for_mode ( \"act\" ) ) if plan is None : if resolved_mode != \"plan\" : selection = self . _tool_selector . select ( user_query , self . _model_name , tool_specs = tool_specs , context = context , ) if selection . tool_required and selection . tool_ids : selected_ids = self . _expand_tool_ids ( set ( selection . tool_ids ), tool_specs ) tool_specs = [ spec for spec in tool_specs if spec . tool_id in selected_ids ] plan = self . _planner . generate ( user_query , self . _model_name , context = context , tool_specs = tool_specs , mode = resolved_mode , ) if resolved_mode != \"plan\" and plan and self . _plan_needs_verification ( plan ): tool_specs = self . _ensure_web_verification_tools ( tool_specs , self . _tool_registry . list_specs_for_mode ( \"act\" ), ) state . plan = plan . steps self . _append_action_plan ( session_id , plan . steps ) task_queue = TaskQueue ( plan_steps = plan . steps , action_steps = []) tool_outputs : list [ str ] = [] executed_steps : list [ ActionStep ] = [] completed_steps : list [ PlanStep ] = [] remaining_steps : list [ PlanStep ] = list ( plan . steps ) last_error : str | None = None direct_response : str | None = None if resolved_mode == \"plan\" : state . done = True state . done_reason = \"planned\" else : max_steps = max ( 0 , max_iters ) * 5 steps_run = 0 allowed_tool_ids = { spec . tool_id for spec in tool_specs } while remaining_steps and steps_run < max_steps : if should_cancel is not None and should_cancel (): state . done = True state . done_reason = \"canceled\" break current_step = remaining_steps . pop ( 0 ) decision = self . _step_executor . decide ( user_query , current_step , self . _model_name , allowed_tools = tool_specs , context = context , ) decision_type = ( decision . decision or \"\" ) . strip () . lower () if decision_type == \"respond\" : if decision . response : direct_response = decision . response tool_outputs . append ( decision . response ) else : last_error = \"Step executor returned an empty response.\" tool_outputs . append ( f \"ERROR: { last_error } \" ) completed_steps . append ( current_step ) steps_run += 1 state . done = True state . done_reason = \"completed\" if direct_response else \"incomplete\" break elif decision_type == \"tool\" : tool_id = str ( decision . tool_id or \"\" ) . strip () if not tool_id or tool_id not in allowed_tool_ids : last_error = f \"Tool ' { tool_id or 'unknown' } ' not allowed for this step.\" tool_outputs . append ( f \"ERROR: { last_error } \" ) else : args = decision . args if args is None : args = \"\" elif not isinstance ( args , ( dict , str )): args = str ( args ) action_step = self . _build_action_step ( current_step , tool_id , args , ) run_queue = TaskQueue ( plan_steps = plan . steps , action_steps = [ action_step ]) run_queue = self . _run_action_plan ( session_id , run_queue , mode = resolved_mode , should_cancel = should_cancel , ) executed_steps . extend ( run_queue . action_steps ) if run_queue . task_result : tool_outputs . append ( run_queue . task_result ) if run_queue . last_error : last_error = run_queue . last_error else : last_error = f \"Invalid step decision: { decision . decision } \" tool_outputs . append ( f \"ERROR: { last_error } \" ) completed_steps . append ( current_step ) steps_run += 1 if should_cancel is not None and should_cancel (): state . done = True state . done_reason = \"canceled\" break if remaining_steps : remaining_steps = self . _plan_updater . update ( user_query , self . _model_name , completed_step = current_step , last_result = tool_outputs [ - 1 ] if tool_outputs else None , remaining_steps = remaining_steps , context = context , ) state . plan = completed_steps + remaining_steps self . _append_action_plan ( session_id , state . plan ) if not state . done : if remaining_steps and steps_run >= max_steps : state . done_reason = \"max_steps_reached\" elif last_error : state . done_reason = ( \"blocked\" if \"permission denied\" in last_error . lower () else \"incomplete\" ) else : state . done_reason = \"completed\" state . done = True task_queue . plan_steps = completed_steps + remaining_steps task_queue . action_steps = executed_steps task_queue . task_result = \" \\n \" . join ( item for item in tool_outputs if item ) . strip () task_queue . last_error = last_error state . tool_results . extend ( tool_outputs ) if direct_response is not None and resolved_mode != \"plan\" and state . done : task_queue . task_result = direct_response self . _session_store . append_event ( session_id , { \"type\" : \"assistant\" , \"payload\" : { \"text\" : direct_response }} ) elif ( state . done and resolved_mode != \"plan\" and self . _should_synthesize_response ( task_queue ) ): tool_outputs = tool_outputs or self . _collect_tool_outputs ( task_queue ) response = self . _synthesizer . synthesize ( user_query = user_query , tool_outputs = tool_outputs , model_name = self . _model_name , context = context , ) task_queue . task_result = response self . _session_store . append_event ( session_id , { \"type\" : \"assistant\" , \"payload\" : { \"text\" : response }} ) if not state . done : # pragma: no cover - defensive guard state . done_reason = \"max_iterations_reached\" completion_payload = { \"done\" : state . done , \"done_reason\" : state . done_reason , \"task_result\" : task_queue . task_result , } if task_queue . last_error : completion_payload [ \"error\" ] = task_queue . last_error completion_payload [ \"last_error\" ] = task_queue . last_error self . _session_store . append_event ( session_id , { \"type\" : \"completion\" , \"payload\" : completion_payload }, ) updated_summary = self . _maybe_auto_compact ( session_id ) if updated_summary : state . summary = updated_summary return ( task_queue , state ) if return_state else task_queue except Exception as exc : logging . exception ( \"Orchestration failed for session {} \" , session_id ) if task_queue is None : task_queue = TaskQueue ( _human_message = user_query , action_steps = []) task_queue . last_error = str ( exc ) state . done = True state . done_reason = \"error\" self . _session_store . append_event ( session_id , { \"type\" : \"completion\" , \"payload\" : { \"done\" : True , \"done_reason\" : state . done_reason , \"task_result\" : task_queue . task_result , \"error\" : str ( exc ), \"last_error\" : str ( exc ), }, }, ) return ( task_queue , state ) if return_state else task_queue def _run_action_plan ( self , session_id : str , task_queue : TaskQueue , * , mode : str , should_cancel : Callable [[], bool ] | None = None , ) -> TaskQueue : reflector = StepReflector ( self . _model_name ) allowed_tools = None if mode == \"plan\" : allowed_tools = { spec . tool_id for spec in self . _tool_registry . list_specs_for_mode ( \"plan\" ) } runner = ActionPlanRunner ( tool_registry = self . _tool_registry , permission_policy = self . _permission_policy , approval_callback = self . _approval_callback , hook_manager = self . _hook_manager , reflector = reflector , event_logger = lambda event : self . _session_store . append_event ( session_id , event ), allowed_tool_ids = allowed_tools , mode = mode , should_cancel = should_cancel , ) return runner . run ( task_queue ) def _maybe_auto_compact ( self , session_id : str ) -> str | None : events = self . _session_store . load_transcript ( session_id ) events = self . _hook_manager . run_pre_compact ( events ) summary = self . _session_store . load_summary ( session_id ) budget = get_token_budget ( events , summary , self . _model_name ) if budget . needs_compact or should_compact ( events ): summary = summarize_events ( events ) self . _session_store . save_summary ( session_id , summary ) return summary return None def _append_action_plan ( self , session_id : str , steps : list [ PlanStep ]) -> None : payload_steps = [ self . _serialize_plan_step ( step ) for step in steps ] self . _session_store . append_event ( session_id , { \"type\" : \"action_plan\" , \"payload\" : { \"steps\" : payload_steps }} ) @staticmethod def _serialize_plan_step ( step : PlanStep ) -> dict [ str , str ]: return { \"title\" : step . title , \"description\" : step . description } def _build_action_step ( self , plan_step : PlanStep , tool_id : str , args : object | None , ) -> ActionStep : operation = self . _infer_operation ( tool_id ) return ActionStep ( title = plan_step . title , objective = plan_step . description , tool_id = tool_id , operation = operation , tool_input = args if args is not None else \"\" , ) @staticmethod def _infer_operation ( tool_id : str ) -> str : lowered = tool_id . lower () write_keywords = [ \"set\" , \"edit\" , \"write\" , \"update\" , \"delete\" , \"create\" , \"apply\" , \"add\" , \"remove\" , \"patch\" , \"insert\" , \"append\" , \"replace\" , \"upload\" , \"post\" , \"put\" , ] if any ( keyword in lowered for keyword in write_keywords ): return \"set\" read_keywords = [ \"read\" , \"list\" , \"search\" , \"get\" , \"fetch\" , \"query\" , \"lookup\" , \"web_search\" , \"web_url_read\" , ] if any ( keyword in lowered for keyword in read_keywords ): return \"get\" return \"get\" @staticmethod def _expand_tool_ids ( selected_ids : set [ str ], tool_specs : list [ ToolSpec ]) -> set [ str ]: if not selected_ids : return selected_ids lowered_selected = { tool_id . lower () for tool_id in selected_ids } has_web_search = any ( key in tool_id for tool_id in lowered_selected for key in ( \"internet_search\" , \"web_search\" , \"searxng\" ) ) if has_web_search : for spec in tool_specs : tool_id = spec . tool_id . lower () if \"web_url_read\" in tool_id or \"web_url\" in tool_id or \"web_read\" in tool_id : selected_ids . add ( spec . tool_id ) return selected_ids @staticmethod def _plan_needs_verification ( plan : Plan ) -> bool : keywords = ( \"open\" , \"verify\" , \"read\" , \"source\" , \"citation\" , \"citations\" ) for step in plan . steps : combined = f \" { step . title } { step . description } \" . lower () if any ( keyword in combined for keyword in keywords ): return True return False @staticmethod def _ensure_web_verification_tools ( selected : list [ ToolSpec ], all_specs : list [ ToolSpec ], ) -> list [ ToolSpec ]: existing = { spec . tool_id for spec in selected } needed = [] for spec in all_specs : if spec . tool_id in existing : continue tool_id = spec . tool_id . lower () if ( \"internet_search\" in tool_id or \"web_search\" in tool_id or \"searxng\" in tool_id or \"web_url_read\" in tool_id or \"web_url\" in tool_id or \"web_read\" in tool_id ): needed . append ( spec ) return selected + needed @staticmethod def _should_update_summary ( text : str ) -> bool : lowered = text . lower () keywords = [ \"remember\" , \"note this\" , \"save this\" , \"pin this\" , \"keep this\" , \"magic number\" , \"magic numbers\" , ] return any ( keyword in lowered for keyword in keywords ) def _update_summary_with_memory ( self , session_id : str , text : str ) -> str : summary = self . _session_store . load_summary ( session_id ) or \"\" new_line = f \"Memory: { text } \" lines = [ line for line in summary . splitlines () if line . strip ()] if summary else [] if new_line not in lines : lines . append ( new_line ) updated = \" \\n \" . join ( lines [ - 10 :]) . strip () self . _session_store . save_summary ( session_id , updated ) return updated @staticmethod def _build_direct_response ( message : str ) -> TaskQueue : task_queue = TaskQueue ( action_steps = []) task_queue . task_result = message return task_queue @staticmethod def _collect_tool_outputs ( task_queue : TaskQueue ) -> list [ str ]: outputs : list [ str ] = [] for step in task_queue . action_steps : if step . result is None : continue content = getattr ( step . result , \"content\" , step . result ) outputs . append ( str ( content )) if outputs or not task_queue . last_error : return outputs return [ f \"ERROR: { task_queue . last_error } \" ] @staticmethod def _should_synthesize_response ( task_queue : TaskQueue ) -> bool : if not task_queue . action_steps : return True return bool ( Orchestrator . _collect_tool_outputs ( task_queue )) @staticmethod def _build_revised_query ( user_query : str , task_queue : TaskQueue ) -> str : failure_note = ( f \"Last tool failure: { task_queue . last_error } \\n \" if task_queue . last_error else \"\" ) return ( f \" { user_query } \\n\\n Previous tool results: \\n { task_queue . task_result or '' } \\n \" f \" { failure_note } \" \"Please revise the action plan to resolve remaining tasks.\" ) @staticmethod def _resolve_mode ( user_query : str , mode : str | None ) -> str : if mode in { \"plan\" , \"act\" }: return mode lowered = user_query . strip () . lower () plan_triggers = [ \"make a plan\" , \"create a plan\" , \"draft a plan\" , \"plan the\" , \"plan for\" , \"planning\" , ] if any ( trigger in lowered for trigger in plan_triggers ): return \"plan\" return \"act\" @staticmethod def _should_replan ( task_queue : TaskQueue , iteration : int , max_iters : int , * , mode : str ) -> bool : if iteration >= max_iters - 1 : return False if mode == \"plan\" : return False if task_queue . last_error : lowered = task_queue . last_error . lower () if \"permission denied\" in lowered or \"tool not allowed\" in lowered : return False return True __init__ ( * , model_name : str | None = None , session_store : SessionStore | None = None , tool_registry : ToolRegistry | None = None , permission_policy : PermissionPolicy | None = None , approval_callback : Callable [[ ActionStep ], bool ] | None = None , hook_manager : HookManager | None = None ) -> None Initialize orchestration dependencies. Source code in packages/meeseeks_core/src/meeseeks_core/orchestrator.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 def __init__ ( self , * , model_name : str | None = None , session_store : SessionStore | None = None , tool_registry : ToolRegistry | None = None , permission_policy : PermissionPolicy | None = None , approval_callback : Callable [[ ActionStep ], bool ] | None = None , hook_manager : HookManager | None = None , ) -> None : \"\"\"Initialize orchestration dependencies.\"\"\" self . _model_name = ( model_name or get_config_value ( \"llm\" , \"action_plan_model\" ) or get_config_value ( \"llm\" , \"default_model\" , default = \"gpt-5.2\" ) ) self . _session_store = session_store or SessionStore () self . _tool_registry = tool_registry or load_registry () self . _permission_policy = permission_policy or load_permission_policy () self . _approval_callback = approval_callback or approval_callback_from_config () self . _hook_manager = hook_manager or default_hook_manager () self . _context_builder = ContextBuilder ( self . _session_store ) self . _planner = Planner ( self . _tool_registry ) self . _tool_selector = ToolSelector ( self . _tool_registry ) self . _step_executor = StepExecutor ( self . _tool_registry ) self . _plan_updater = PlanUpdater ( self . _tool_registry ) self . _synthesizer = ResponseSynthesizer ( self . _tool_registry ) run ( user_query : str , * , max_iters : int = 3 , initial_plan : Plan | None = None , return_state : bool = False , session_id : str | None = None , mode : str | None = None , should_cancel : Callable [[], bool ] | None = None ) -> TaskQueue | tuple [ TaskQueue , OrchestrationState ] Run a plan-act-observe loop for a session. Source code in packages/meeseeks_core/src/meeseeks_core/orchestrator.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 def run ( self , user_query : str , * , max_iters : int = 3 , initial_plan : Plan | None = None , return_state : bool = False , session_id : str | None = None , mode : str | None = None , should_cancel : Callable [[], bool ] | None = None , ) -> TaskQueue | tuple [ TaskQueue , OrchestrationState ]: \"\"\"Run a plan-act-observe loop for a session.\"\"\" if session_id is None : session_id = self . _session_store . create_session () with session_log_context ( session_id ): with langfuse_session_context ( session_id ): return self . _run_with_session_context ( user_query , max_iters = max_iters , initial_plan = initial_plan , return_state = return_state , session_id = session_id , mode = mode , should_cancel = should_cancel , ) meeseeks_core.task_master Task planning and orchestration loop for Meeseeks. generate_action_plan ( user_query : str , model_name : str | None = None , tool_registry : ToolRegistry | None = None , session_summary : str | None = None , recent_events : list [ EventRecord ] | None = None , selected_events : list [ EventRecord ] | None = None , * , mode : str = 'act' ) -> Plan Generate a plan for a user query. Source code in packages/meeseeks_core/src/meeseeks_core/task_master.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 def generate_action_plan ( user_query : str , model_name : str | None = None , tool_registry : ToolRegistry | None = None , session_summary : str | None = None , recent_events : list [ EventRecord ] | None = None , selected_events : list [ EventRecord ] | None = None , * , mode : str = \"act\" , ) -> Plan : \"\"\"Generate a plan for a user query.\"\"\" tool_registry = tool_registry or load_registry () resolved_model = cast ( str , model_name or get_config_value ( \"llm\" , \"action_plan_model\" ) or get_config_value ( \"llm\" , \"default_model\" , default = \"gpt-5.2\" ), ) context = _build_context_snapshot ( session_summary , recent_events , selected_events , resolved_model , ) return Planner ( tool_registry ) . generate ( user_query , resolved_model , context = context , mode = mode ) orchestrate_session ( user_query : str , model_name : str | None = None , max_iters : int = 3 , initial_plan : Plan | None = None , return_state : bool = False , session_id : str | None = None , session_store : SessionStore | None = None , tool_registry : ToolRegistry | None = None , permission_policy : PermissionPolicy | None = None , approval_callback : Callable [[ ActionStep ], bool ] | None = None , hook_manager : HookManager | None = None , mode : str | None = None , should_cancel : Callable [[], bool ] | None = None ) -> TaskQueue | tuple [ TaskQueue , OrchestrationState ] Run the plan-act-observe orchestration loop. Source code in packages/meeseeks_core/src/meeseeks_core/task_master.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 def orchestrate_session ( user_query : str , model_name : str | None = None , max_iters : int = 3 , initial_plan : Plan | None = None , return_state : bool = False , session_id : str | None = None , session_store : SessionStore | None = None , tool_registry : ToolRegistry | None = None , permission_policy : PermissionPolicy | None = None , approval_callback : Callable [[ ActionStep ], bool ] | None = None , hook_manager : HookManager | None = None , mode : str | None = None , should_cancel : Callable [[], bool ] | None = None , ) -> TaskQueue | tuple [ TaskQueue , OrchestrationState ]: \"\"\"Run the plan-act-observe orchestration loop.\"\"\" return Orchestrator ( model_name = model_name , session_store = session_store , tool_registry = tool_registry , permission_policy = permission_policy , approval_callback = approval_callback , hook_manager = hook_manager , ) . run ( user_query , max_iters = max_iters , initial_plan = initial_plan , return_state = return_state , session_id = session_id , mode = mode , should_cancel = should_cancel , ) run_action_plan ( task_queue : TaskQueue , tool_registry : ToolRegistry | None = None , event_logger : Callable [[ Event ], None ] | None = None , permission_policy : PermissionPolicy | None = None , approval_callback : Callable [[ ActionStep ], bool ] | None = None , hook_manager : HookManager | None = None , model_name : str | None = None , * , mode : str = 'act' ) -> TaskQueue Execute a task queue with permissions and hooks. Source code in packages/meeseeks_core/src/meeseeks_core/task_master.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 def run_action_plan ( task_queue : TaskQueue , tool_registry : ToolRegistry | None = None , event_logger : Callable [[ Event ], None ] | None = None , permission_policy : PermissionPolicy | None = None , approval_callback : Callable [[ ActionStep ], bool ] | None = None , hook_manager : HookManager | None = None , model_name : str | None = None , * , mode : str = \"act\" , ) -> TaskQueue : \"\"\"Execute a task queue with permissions and hooks.\"\"\" tool_registry = tool_registry or load_registry () permission_policy = permission_policy or load_permission_policy () approval_callback = approval_callback or approval_callback_from_config () hook_manager = hook_manager or default_hook_manager () runner = ActionPlanRunner ( tool_registry = tool_registry , permission_policy = permission_policy , approval_callback = approval_callback , hook_manager = hook_manager , event_logger = event_logger , reflector = StepReflector ( model_name ), mode = mode , ) return runner . run ( task_queue ) meeseeks_core.action_runner Execute action plans with permissions, hooks, and reflection. ActionPlanRunner Execute TaskQueue steps with lifecycle hooks. Source code in packages/meeseeks_core/src/meeseeks_core/action_runner.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 class ActionPlanRunner : \"\"\"Execute TaskQueue steps with lifecycle hooks.\"\"\" def __init__ ( self , tool_registry : ToolRegistry | None = None , permission_policy : PermissionPolicy | None = None , approval_callback : Callable [[ ActionStep ], bool ] | None = None , hook_manager : HookManager | None = None , reflector : StepReflector | None = None , event_logger : EventLogger | None = None , allowed_tool_ids : set [ str ] | None = None , should_cancel : Callable [[], bool ] | None = None , mode : str = \"act\" , ) -> None : \"\"\"Initialize the action plan runner.\"\"\" self . _tool_registry = tool_registry or load_registry () self . _permission_policy = permission_policy or load_permission_policy () self . _approval_callback = approval_callback or approval_callback_from_config () self . _hook_manager = hook_manager or default_hook_manager () self . _reflector = reflector self . _event_logger = event_logger self . _allowed_tool_ids = allowed_tool_ids self . _should_cancel = should_cancel self . _mode = mode def run ( self , task_queue : TaskQueue ) -> TaskQueue : \"\"\"Run all steps in the task queue.\"\"\" task_queue . last_error = None for idx , action_step in enumerate ( task_queue . action_steps ): if self . _should_cancel is not None and self . _should_cancel (): self . _record_failure ( action_step , \"canceled\" , task_queue ) break logging . debug ( \"Processing ActionStep: {} \" , action_step ) if ( self . _allowed_tool_ids is not None and action_step . tool_id not in self . _allowed_tool_ids ): reason = \"tool not allowed in plan mode\" self . _record_failure ( action_step , reason , task_queue ) self . _emit_tool_result ( action_step , None , error = reason ) break if not self . _ensure_permission ( action_step ): self . _record_failure ( action_step , \"permission denied\" , task_queue ) self . _emit_tool_result ( action_step , None , error = \"Permission denied\" ) continue action_step = self . _hook_manager . run_pre_tool_use ( action_step ) task_queue . action_steps [ idx ] = action_step tool = self . _tool_registry . get ( action_step . tool_id ) if tool is None : self . _record_failure ( action_step , \"tool not available\" , task_queue ) continue spec = self . _tool_registry . get_spec ( action_step . tool_id ) if spec is not None : schema_error = self . _coerce_mcp_tool_input ( action_step , spec ) if schema_error : self . _record_failure ( action_step , schema_error , task_queue ) self . _emit_tool_result ( action_step , None , error = schema_error ) continue try : outcome = self . _execute_step ( action_step ) except Exception as exc : self . _handle_tool_error ( action_step , exc , task_queue ) continue if outcome . reflection is not None and outcome . reflection . status != \"ok\" : status = outcome . reflection . status reason = f \"step reflection requested { status } \" if outcome . reflection . notes : reason = f \" { reason } : { outcome . reflection . notes } \" self . _record_reflection_failure ( action_step , reason , task_queue ) self . _emit_tool_result ( action_step , outcome . content , error = reason ) if outcome . reflection . revised_argument : action_step . tool_input = outcome . reflection . revised_argument self . _emit_event ( { \"type\" : \"step_reflection\" , \"payload\" : { \"tool_id\" : action_step . tool_id , \"operation\" : action_step . operation , \"tool_input\" : action_step . tool_input , \"status\" : outcome . reflection . status , \"notes\" : outcome . reflection . notes , }, } ) task_queue . action_steps [ idx ] = action_step break self . _emit_tool_result ( action_step , outcome . content ) summaries = [ summary for step in task_queue . action_steps if ( summary := self . _format_step_summary ( step )) ] task_queue . task_result = \" \\n \" . join ( summaries ) . strip () return task_queue def _ensure_permission ( self , action_step : ActionStep ) -> bool : decision = self . _permission_policy . decide ( action_step ) decision = self . _hook_manager . run_permission_request ( action_step , decision ) decision_logged = False logging . debug ( \"Permission check: tool= {} action= {} decision= {} callback_present= {} \" , action_step . tool_id , action_step . operation , decision . value if isinstance ( decision , PermissionDecision ) else decision , self . _approval_callback is not None , ) if decision == PermissionDecision . ASK : approved = self . _approval_callback ( action_step ) if self . _approval_callback else False logging . debug ( \"Permission prompt result: tool= {} action= {} approved= {} \" , action_step . tool_id , action_step . operation , approved , ) decision = PermissionDecision . ALLOW if approved else PermissionDecision . DENY self . _emit_event ( { \"type\" : \"permission\" , \"payload\" : { \"tool_id\" : action_step . tool_id , \"operation\" : action_step . operation , \"tool_input\" : action_step . tool_input , \"decision\" : decision . value , }, } ) decision_logged = True if decision == PermissionDecision . DENY : mock = get_mock_speaker () message = f \"Permission denied for { action_step . tool_id } : { action_step . operation } .\" action_step . result = mock ( content = message ) if not decision_logged : self . _emit_event ( { \"type\" : \"permission\" , \"payload\" : { \"tool_id\" : action_step . tool_id , \"operation\" : action_step . operation , \"tool_input\" : action_step . tool_input , \"decision\" : decision . value , }, } ) return False return True def _execute_step ( self , action_step : ActionStep ) -> StepOutcome : tool = self . _tool_registry . get ( action_step . tool_id ) if tool is None : raise RuntimeError ( \"Tool unavailable during execution\" ) action_result = tool . run ( action_step ) action_result = self . _hook_manager . run_post_tool_use ( action_step , action_result ) action_step . result = action_result content = getattr ( action_result , \"content\" , None ) if content is None : content = \"\" if action_result is None else str ( action_result ) reflection = None if self . _reflector is not None : reflection = self . _reflector . reflect ( action_step , content ) return StepOutcome ( content = str ( content ), reflection = reflection ) def _handle_tool_error ( self , action_step : ActionStep , exc : Exception , task_queue : TaskQueue ) -> None : logging . error ( \"Error processing action step: {} \" , exc ) self . _record_failure ( action_step , str ( exc ), task_queue ) spec = self . _tool_registry . get_spec ( action_step . tool_id ) is_mcp = spec is not None and spec . kind == \"mcp\" if not isinstance ( exc , ToolInputError ) and not is_mcp : self . _tool_registry . disable ( action_step . tool_id , f \"Runtime error: { exc } \" ) self . _emit_tool_result ( action_step , None , error = str ( exc )) mock = get_mock_speaker () self . _hook_manager . run_post_tool_use ( action_step , mock ( content = f \"Tool error: { exc } \" )) def _record_failure ( self , step : ActionStep , reason : str , task_queue : TaskQueue ) -> None : note = f \" { step . tool_id } ( { step . operation } ) failed\" if reason : note = f \" { note } : { reason } \" task_queue . last_error = note if step . result is None and reason : mock = get_mock_speaker () step . result = mock ( content = f \"ERROR: { reason } \" ) def _record_reflection_failure ( self , step : ActionStep , reason : str , task_queue : TaskQueue ) -> None : note = f \" { step . tool_id } ( { step . operation } ) needs revision\" if reason : note = f \" { note } : { reason } \" task_queue . last_error = note def _emit_tool_result ( self , action_step : ActionStep , result : str | None , * , error : str | None = None ) -> None : summary = self . _summarize_result ( result , error ) payload : ToolResultPayload = { \"tool_id\" : action_step . tool_id , \"operation\" : action_step . operation , \"tool_input\" : action_step . tool_input , \"result\" : result , \"success\" : error is None , \"summary\" : summary , } if error : payload [ \"error\" ] = error self . _emit_event ({ \"type\" : \"tool_result\" , \"payload\" : payload }) def _emit_event ( self , event : Event ) -> None : if self . _event_logger is not None : self . _event_logger ( event ) @staticmethod def _coerce_mcp_tool_input ( action_step : ActionStep , spec : ToolSpec ) -> str | None : if spec . kind != \"mcp\" : return None schema = spec . metadata . get ( \"schema\" ) if spec . metadata else None if not isinstance ( schema , dict ): return None required = schema . get ( \"required\" ) or [] properties = schema . get ( \"properties\" ) or {} if not isinstance ( properties , dict ): properties = {} expected_fields = list ( required ) or list ( properties . keys ()) argument = action_step . tool_input if isinstance ( argument , str ): stripped = argument . strip () if stripped . startswith ( \"{\" ) and stripped . endswith ( \"}\" ): try : parsed = json . loads ( stripped ) except json . JSONDecodeError : parsed = None if isinstance ( parsed , dict ): action_step . tool_input = parsed argument = parsed if isinstance ( argument , str ): if expected_fields : preferred_fields = [ \"query\" , \"question\" , \"input\" , \"text\" , \"q\" ] target_field = None if len ( expected_fields ) == 1 : target_field = expected_fields [ 0 ] else : for preferred in preferred_fields : if preferred in expected_fields : target_field = preferred break if target_field : action_step . tool_input = { target_field : argument } return None fields = \", \" . join ( expected_fields ) if expected_fields else \"schema-defined fields\" return f \"Expected JSON object with fields: { fields } .\" if isinstance ( argument , dict ): if required : missing = [ name for name in required if name not in argument ] if missing : if len ( required ) == 1 and len ( argument ) == 1 : required_field = required [ 0 ] value = next ( iter ( argument . values ())) prop = properties . get ( required_field , {}) if ( isinstance ( prop , dict ) and prop . get ( \"type\" ) == \"array\" and isinstance ( value , str ) ): items = prop . get ( \"items\" ) if isinstance ( items , dict ) and items . get ( \"type\" ) == \"string\" : value = [ value ] if ( isinstance ( prop , dict ) and prop . get ( \"type\" ) == \"string\" and isinstance ( value , list ) and len ( value ) == 1 ): value = value [ 0 ] action_step . tool_input = { required_field : value } return None return f \"Missing required fields: { ', ' . join ( missing ) } .\" return None return \"Unsupported tool_input type for MCP tool.\" @staticmethod def _summarize_result ( result : str | None , error : str | None ) -> str : if error : return f \"ERROR: { error } \" if result is None : return \"\" text = str ( result ) . strip () if len ( text ) <= 500 : return text return text [: 497 ] + \"...\" @classmethod def _format_step_summary ( cls , step : ActionStep ) -> str : if step . result is None : return \"\" content = getattr ( step . result , \"content\" , step . result ) summary = cls . _summarize_result ( str ( content ), None ) if not summary : return \"\" return f \" { step . tool_id } : { step . operation } -> { summary } \" __init__ ( tool_registry : ToolRegistry | None = None , permission_policy : PermissionPolicy | None = None , approval_callback : Callable [[ ActionStep ], bool ] | None = None , hook_manager : HookManager | None = None , reflector : StepReflector | None = None , event_logger : EventLogger | None = None , allowed_tool_ids : set [ str ] | None = None , should_cancel : Callable [[], bool ] | None = None , mode : str = 'act' ) -> None Initialize the action plan runner. Source code in packages/meeseeks_core/src/meeseeks_core/action_runner.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def __init__ ( self , tool_registry : ToolRegistry | None = None , permission_policy : PermissionPolicy | None = None , approval_callback : Callable [[ ActionStep ], bool ] | None = None , hook_manager : HookManager | None = None , reflector : StepReflector | None = None , event_logger : EventLogger | None = None , allowed_tool_ids : set [ str ] | None = None , should_cancel : Callable [[], bool ] | None = None , mode : str = \"act\" , ) -> None : \"\"\"Initialize the action plan runner.\"\"\" self . _tool_registry = tool_registry or load_registry () self . _permission_policy = permission_policy or load_permission_policy () self . _approval_callback = approval_callback or approval_callback_from_config () self . _hook_manager = hook_manager or default_hook_manager () self . _reflector = reflector self . _event_logger = event_logger self . _allowed_tool_ids = allowed_tool_ids self . _should_cancel = should_cancel self . _mode = mode run ( task_queue : TaskQueue ) -> TaskQueue Run all steps in the task queue. Source code in packages/meeseeks_core/src/meeseeks_core/action_runner.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 def run ( self , task_queue : TaskQueue ) -> TaskQueue : \"\"\"Run all steps in the task queue.\"\"\" task_queue . last_error = None for idx , action_step in enumerate ( task_queue . action_steps ): if self . _should_cancel is not None and self . _should_cancel (): self . _record_failure ( action_step , \"canceled\" , task_queue ) break logging . debug ( \"Processing ActionStep: {} \" , action_step ) if ( self . _allowed_tool_ids is not None and action_step . tool_id not in self . _allowed_tool_ids ): reason = \"tool not allowed in plan mode\" self . _record_failure ( action_step , reason , task_queue ) self . _emit_tool_result ( action_step , None , error = reason ) break if not self . _ensure_permission ( action_step ): self . _record_failure ( action_step , \"permission denied\" , task_queue ) self . _emit_tool_result ( action_step , None , error = \"Permission denied\" ) continue action_step = self . _hook_manager . run_pre_tool_use ( action_step ) task_queue . action_steps [ idx ] = action_step tool = self . _tool_registry . get ( action_step . tool_id ) if tool is None : self . _record_failure ( action_step , \"tool not available\" , task_queue ) continue spec = self . _tool_registry . get_spec ( action_step . tool_id ) if spec is not None : schema_error = self . _coerce_mcp_tool_input ( action_step , spec ) if schema_error : self . _record_failure ( action_step , schema_error , task_queue ) self . _emit_tool_result ( action_step , None , error = schema_error ) continue try : outcome = self . _execute_step ( action_step ) except Exception as exc : self . _handle_tool_error ( action_step , exc , task_queue ) continue if outcome . reflection is not None and outcome . reflection . status != \"ok\" : status = outcome . reflection . status reason = f \"step reflection requested { status } \" if outcome . reflection . notes : reason = f \" { reason } : { outcome . reflection . notes } \" self . _record_reflection_failure ( action_step , reason , task_queue ) self . _emit_tool_result ( action_step , outcome . content , error = reason ) if outcome . reflection . revised_argument : action_step . tool_input = outcome . reflection . revised_argument self . _emit_event ( { \"type\" : \"step_reflection\" , \"payload\" : { \"tool_id\" : action_step . tool_id , \"operation\" : action_step . operation , \"tool_input\" : action_step . tool_input , \"status\" : outcome . reflection . status , \"notes\" : outcome . reflection . notes , }, } ) task_queue . action_steps [ idx ] = action_step break self . _emit_tool_result ( action_step , outcome . content ) summaries = [ summary for step in task_queue . action_steps if ( summary := self . _format_step_summary ( step )) ] task_queue . task_result = \" \\n \" . join ( summaries ) . strip () return task_queue StepOutcome dataclass Result of executing a tool step. Source code in packages/meeseeks_core/src/meeseeks_core/action_runner.py 29 30 31 32 33 34 @dataclass class StepOutcome : \"\"\"Result of executing a tool step.\"\"\" content : str reflection : StepReflection | None meeseeks_core.planning Prompt construction and planning helpers. PlanUpdate Bases: BaseModel Updated remaining plan steps. Source code in packages/meeseeks_core/src/meeseeks_core/planning.py 106 107 108 109 class PlanUpdate ( BaseModel ): \"\"\"Updated remaining plan steps.\"\"\" steps : list [ PlanStep ] = Field ( default_factory = list ) PlanUpdater Update remaining plan steps after executing a step. Source code in packages/meeseeks_core/src/meeseeks_core/planning.py 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 class PlanUpdater : \"\"\"Update remaining plan steps after executing a step.\"\"\" def __init__ ( self , tool_registry : ToolRegistry | None ) -> None : \"\"\"Initialize the plan updater.\"\"\" self . _tool_registry = tool_registry def update ( self , user_query : str , model_name : str , * , completed_step : PlanStep , last_result : str | None , remaining_steps : list [ PlanStep ], context : ContextSnapshot | None = None , ) -> list [ PlanStep ]: \"\"\"Return updated remaining steps.\"\"\" parser = PydanticOutputParser ( pydantic_object = PlanUpdate ) # type: ignore[type-var] system_prompt = get_system_prompt ( \"plan-updater\" ) remaining_lines = [ f \"- { step . title } : { step . description } \" for step in remaining_steps ] remaining_text = \" \\n \" . join ( remaining_lines ) or \"(none)\" prompt = ChatPromptTemplate ( messages = [ SystemMessage ( content = system_prompt ), HumanMessagePromptTemplate . from_template ( \"User request: \\n {user_query} \\n\\n \" \"Completed step: \\n - {title} \\n - {description} \\n\\n \" \"Latest result: \\n {result} \\n\\n \" \"Remaining steps: \\n {remaining} \\n\\n \" \" {format_instructions} \" ), ], partial_variables = { \"format_instructions\" : parser . get_format_instructions ()}, input_variables = [ \"user_query\" , \"title\" , \"description\" , \"result\" , \"remaining\" ], ) model = build_chat_model ( model_name = model_name , openai_api_base = get_config_value ( \"llm\" , \"api_base\" ), api_key = get_config_value ( \"llm\" , \"api_key\" ), ) update = ( prompt | model | parser ) . invoke ( { \"user_query\" : user_query . strip (), \"title\" : completed_step . title , \"description\" : completed_step . description , \"result\" : last_result or \"\" , \"remaining\" : remaining_text , } ) return update . steps __init__ ( tool_registry : ToolRegistry | None ) -> None Initialize the plan updater. Source code in packages/meeseeks_core/src/meeseeks_core/planning.py 516 517 518 def __init__ ( self , tool_registry : ToolRegistry | None ) -> None : \"\"\"Initialize the plan updater.\"\"\" self . _tool_registry = tool_registry update ( user_query : str , model_name : str , * , completed_step : PlanStep , last_result : str | None , remaining_steps : list [ PlanStep ], context : ContextSnapshot | None = None ) -> list [ PlanStep ] Return updated remaining steps. Source code in packages/meeseeks_core/src/meeseeks_core/planning.py 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 def update ( self , user_query : str , model_name : str , * , completed_step : PlanStep , last_result : str | None , remaining_steps : list [ PlanStep ], context : ContextSnapshot | None = None , ) -> list [ PlanStep ]: \"\"\"Return updated remaining steps.\"\"\" parser = PydanticOutputParser ( pydantic_object = PlanUpdate ) # type: ignore[type-var] system_prompt = get_system_prompt ( \"plan-updater\" ) remaining_lines = [ f \"- { step . title } : { step . description } \" for step in remaining_steps ] remaining_text = \" \\n \" . join ( remaining_lines ) or \"(none)\" prompt = ChatPromptTemplate ( messages = [ SystemMessage ( content = system_prompt ), HumanMessagePromptTemplate . from_template ( \"User request: \\n {user_query} \\n\\n \" \"Completed step: \\n - {title} \\n - {description} \\n\\n \" \"Latest result: \\n {result} \\n\\n \" \"Remaining steps: \\n {remaining} \\n\\n \" \" {format_instructions} \" ), ], partial_variables = { \"format_instructions\" : parser . get_format_instructions ()}, input_variables = [ \"user_query\" , \"title\" , \"description\" , \"result\" , \"remaining\" ], ) model = build_chat_model ( model_name = model_name , openai_api_base = get_config_value ( \"llm\" , \"api_base\" ), api_key = get_config_value ( \"llm\" , \"api_key\" ), ) update = ( prompt | model | parser ) . invoke ( { \"user_query\" : user_query . strip (), \"title\" : completed_step . title , \"description\" : completed_step . description , \"result\" : last_result or \"\" , \"remaining\" : remaining_text , } ) return update . steps Planner Generate action plans via LLM. Source code in packages/meeseeks_core/src/meeseeks_core/planning.py 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 class Planner : \"\"\"Generate action plans via LLM.\"\"\" def __init__ ( self , tool_registry : ToolRegistry | None ) -> None : \"\"\"Initialize the planner.\"\"\" self . _tool_registry = tool_registry self . _prompt_builder = PromptBuilder ( tool_registry ) @staticmethod def _build_example_messages ( available_tool_ids : list [ str ], * , mode : str ) -> list [ BaseMessage ]: if mode != \"plan\" : return [] def wrap ( text : str ) -> str : return f \" { EXAMPLE_TAG_OPEN }{ text }{ EXAMPLE_TAG_CLOSE } \" return [ HumanMessage ( content = wrap ( \"Turn on strip lights and heater.\" )), AIMessage ( content = wrap ( get_task_master_examples ( example_id = 0 , available_tools = available_tool_ids ) ) ), HumanMessage ( content = wrap ( \"What is the weather today?\" )), AIMessage ( content = wrap ( get_task_master_examples ( example_id = 1 , available_tools = available_tool_ids ) ) ), ] def generate ( self , user_query : str , model_name : str , context : ContextSnapshot | None = None , * , tool_specs : list [ ToolSpec ] | None = None , mode : str = \"act\" , ) -> Plan : \"\"\"Generate a plan from the user query.\"\"\" if self . _tool_registry is None : raise ValueError ( \"Tool registry is required for planning.\" ) user_id = \"meeseeks-task-master\" session_id = f \"action-queue-id- { os . getpid () } - { os . urandom ( 4 ) . hex () } \" langfuse_handler = build_langfuse_handler ( user_id = user_id , session_id = session_id , trace_name = user_id , version = get_config_value ( \"runtime\" , \"version\" , default = \"Not Specified\" ), release = get_config_value ( \"runtime\" , \"envmode\" , default = \"Not Specified\" ), ) model = build_chat_model ( model_name = model_name , openai_api_base = get_config_value ( \"llm\" , \"api_base\" ), api_key = get_config_value ( \"llm\" , \"api_key\" ), ) parser = PydanticOutputParser ( pydantic_object = Plan ) component_status = self . _resolve_component_status () if tool_specs is not None : specs = tool_specs elif mode == \"plan\" : specs = self . _tool_registry . list_specs () else : specs = self . _tool_registry . list_specs_for_mode ( mode ) if mode == \"act\" and tool_specs is None : specs = self . _filter_specs_by_intent ( specs , user_query ) available_tool_ids = [ spec . tool_id for spec in specs ] system_prompt = self . _prompt_builder . build ( get_system_prompt (), context , component_status = component_status if mode == \"act\" else None , mode = mode , tool_specs = specs , include_tool_schemas = False , include_tool_guidance = False , ) example_messages = self . _build_example_messages ( available_tool_ids , mode = mode ) if mode == \"act\" : instruction = \"## Generate the minimal plan for the user query\" else : instruction = \"## Generate a plan for the user query\" prompt = ChatPromptTemplate ( messages = [ SystemMessage ( content = system_prompt ), * example_messages , HumanMessagePromptTemplate . from_template ( \"## Format Instructions \\n {format_instructions} \\n \" f \" { instruction } \\n{{ user_query }} \" ), ], partial_variables = { \"format_instructions\" : parser . get_format_instructions ()}, input_variables = [ \"user_query\" ], ) logging . info ( \"Generating action plan <model=' {} '; user_query=' {} '>\" , model_name , user_query , ) logging . info ( \"Input prompt token length is ` {} `.\" , num_tokens_from_string ( str ( prompt ))) config : dict [ str , object ] = {} if langfuse_handler is not None : config [ \"callbacks\" ] = [ langfuse_handler ] metadata = getattr ( langfuse_handler , \"langfuse_metadata\" , None ) if isinstance ( metadata , dict ) and metadata : config [ \"metadata\" ] = metadata with langfuse_trace_span ( \"action-plan\" ) as span : if span is not None : try : span . update_trace ( input = { \"user_query\" : user_query . strip ()}) except Exception : pass action_plan = ( prompt | model | parser ) . invoke ( { \"user_query\" : user_query . strip ()}, config = config or None , ) if span is not None : try : span . update_trace ( output = { \"step_count\" : len ( action_plan . steps or [])}) except Exception : pass action_plan . human_message = user_query return action_plan @staticmethod def _infer_intent_capabilities ( user_query : str ) -> set [ str ]: lowered = user_query . lower () requested : set [ str ] = set () for intent , keywords in INTENT_KEYWORDS . items (): if any ( keyword in lowered for keyword in keywords ): requested |= INTENT_CAPABILITIES [ intent ] return requested @staticmethod def _spec_capabilities ( spec ) -> set [ str ]: metadata = spec . metadata or {} capabilities = metadata . get ( \"capabilities\" ) if isinstance ( capabilities , list ): return { str ( item ) for item in capabilities if isinstance ( item , str )} tool_id = spec . tool_id . lower () inferred : set [ str ] = set () if \"internet_search\" in tool_id or \"web_search\" in tool_id or \"searxng\" in tool_id : inferred . add ( \"web_search\" ) if \"web_url_read\" in tool_id or \"web_url\" in tool_id : inferred . add ( \"web_read\" ) if \"aider_read_file\" in tool_id or \"aider_list_dir\" in tool_id : inferred . add ( \"file_read\" ) if \"aider_edit_block\" in tool_id : inferred . add ( \"file_write\" ) if \"shell\" in tool_id : inferred . add ( \"shell_exec\" ) if \"home_assistant\" in tool_id : inferred . add ( \"home_assistant\" ) return inferred def _filter_specs_by_intent ( self , specs , user_query : str ): requested = self . _infer_intent_capabilities ( user_query ) if not requested : return specs filtered = [ spec for spec in specs if self . _spec_capabilities ( spec ) . intersection ( requested )] return filtered or specs def _resolve_component_status ( self ) -> list [ ComponentStatus ]: return [ resolve_langfuse_status ()] __init__ ( tool_registry : ToolRegistry | None ) -> None Initialize the planner. Source code in packages/meeseeks_core/src/meeseeks_core/planning.py 216 217 218 219 def __init__ ( self , tool_registry : ToolRegistry | None ) -> None : \"\"\"Initialize the planner.\"\"\" self . _tool_registry = tool_registry self . _prompt_builder = PromptBuilder ( tool_registry ) generate ( user_query : str , model_name : str , context : ContextSnapshot | None = None , * , tool_specs : list [ ToolSpec ] | None = None , mode : str = 'act' ) -> Plan Generate a plan from the user query. Source code in packages/meeseeks_core/src/meeseeks_core/planning.py 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 def generate ( self , user_query : str , model_name : str , context : ContextSnapshot | None = None , * , tool_specs : list [ ToolSpec ] | None = None , mode : str = \"act\" , ) -> Plan : \"\"\"Generate a plan from the user query.\"\"\" if self . _tool_registry is None : raise ValueError ( \"Tool registry is required for planning.\" ) user_id = \"meeseeks-task-master\" session_id = f \"action-queue-id- { os . getpid () } - { os . urandom ( 4 ) . hex () } \" langfuse_handler = build_langfuse_handler ( user_id = user_id , session_id = session_id , trace_name = user_id , version = get_config_value ( \"runtime\" , \"version\" , default = \"Not Specified\" ), release = get_config_value ( \"runtime\" , \"envmode\" , default = \"Not Specified\" ), ) model = build_chat_model ( model_name = model_name , openai_api_base = get_config_value ( \"llm\" , \"api_base\" ), api_key = get_config_value ( \"llm\" , \"api_key\" ), ) parser = PydanticOutputParser ( pydantic_object = Plan ) component_status = self . _resolve_component_status () if tool_specs is not None : specs = tool_specs elif mode == \"plan\" : specs = self . _tool_registry . list_specs () else : specs = self . _tool_registry . list_specs_for_mode ( mode ) if mode == \"act\" and tool_specs is None : specs = self . _filter_specs_by_intent ( specs , user_query ) available_tool_ids = [ spec . tool_id for spec in specs ] system_prompt = self . _prompt_builder . build ( get_system_prompt (), context , component_status = component_status if mode == \"act\" else None , mode = mode , tool_specs = specs , include_tool_schemas = False , include_tool_guidance = False , ) example_messages = self . _build_example_messages ( available_tool_ids , mode = mode ) if mode == \"act\" : instruction = \"## Generate the minimal plan for the user query\" else : instruction = \"## Generate a plan for the user query\" prompt = ChatPromptTemplate ( messages = [ SystemMessage ( content = system_prompt ), * example_messages , HumanMessagePromptTemplate . from_template ( \"## Format Instructions \\n {format_instructions} \\n \" f \" { instruction } \\n{{ user_query }} \" ), ], partial_variables = { \"format_instructions\" : parser . get_format_instructions ()}, input_variables = [ \"user_query\" ], ) logging . info ( \"Generating action plan <model=' {} '; user_query=' {} '>\" , model_name , user_query , ) logging . info ( \"Input prompt token length is ` {} `.\" , num_tokens_from_string ( str ( prompt ))) config : dict [ str , object ] = {} if langfuse_handler is not None : config [ \"callbacks\" ] = [ langfuse_handler ] metadata = getattr ( langfuse_handler , \"langfuse_metadata\" , None ) if isinstance ( metadata , dict ) and metadata : config [ \"metadata\" ] = metadata with langfuse_trace_span ( \"action-plan\" ) as span : if span is not None : try : span . update_trace ( input = { \"user_query\" : user_query . strip ()}) except Exception : pass action_plan = ( prompt | model | parser ) . invoke ( { \"user_query\" : user_query . strip ()}, config = config or None , ) if span is not None : try : span . update_trace ( output = { \"step_count\" : len ( action_plan . steps or [])}) except Exception : pass action_plan . human_message = user_query return action_plan PromptBuilder Build system prompts with contextual sections. Source code in packages/meeseeks_core/src/meeseeks_core/planning.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 class PromptBuilder : \"\"\"Build system prompts with contextual sections.\"\"\" def __init__ ( self , tool_registry : ToolRegistry | None ) -> None : \"\"\"Initialize prompt builder dependencies.\"\"\" self . _tool_registry = tool_registry def build ( self , base_prompt : str , context : ContextSnapshot | None , component_status : Iterable [ ComponentStatus ] | None = None , * , mode : str = \"act\" , tool_specs = None , include_tool_schemas : bool = True , include_tool_guidance : bool = True , ) -> str : \"\"\"Build an augmented system prompt string.\"\"\" sections = [ base_prompt ] if context and context . summary : sections . append ( f \"Session summary: \\n { context . summary } \" ) if context and context . selected_events : rendered = render_event_lines ( context . selected_events ) if rendered : sections . append ( \"Relevant earlier context: \\n \" + rendered ) if context and context . recent_events : rendered = render_event_lines ( context . recent_events ) if rendered : sections . append ( \"Recent conversation: \\n \" + rendered ) if self . _tool_registry is not None : specs = tool_specs or self . _tool_registry . list_specs () if specs : tool_lines = \" \\n \" . join ( f \"- { spec . tool_id } : { spec . description } \" for spec in specs ) sections . append ( f \"Available tools: \\n { tool_lines } \" ) if mode == \"act\" : if include_tool_schemas : schema_lines = self . _render_schema_lines ( specs ) if schema_lines : sections . append ( \"Tool input schemas: \\n \" + \" \\n \" . join ( schema_lines )) if include_tool_guidance : tool_prompts = self . _render_tool_prompts ( specs , local_only = True ) if tool_prompts : sections . append ( \"Tool guidance: \\n \" + \" \\n\\n \" . join ( tool_prompts )) if component_status : sections . append ( \"Component status: \\n \" + format_component_status ( component_status )) return \" \\n\\n \" . join ( sections ) @staticmethod def _render_schema_lines ( specs ) -> list [ str ]: lines : list [ str ] = [] for spec in specs : if spec . kind != \"mcp\" : continue schema = spec . metadata . get ( \"schema\" ) if spec . metadata else None if not isinstance ( schema , dict ): continue required = schema . get ( \"required\" ) or [] properties = schema . get ( \"properties\" ) or {} if not isinstance ( properties , dict ): properties = {} field_names = list ( required ) or list ( properties . keys ()) if not field_names : continue parts : list [ str ] = [] for name in field_names : if not isinstance ( name , str ): continue prop = properties . get ( name , {}) if not isinstance ( prop , dict ): prop = {} piece = name prop_type = prop . get ( \"type\" ) if isinstance ( prop_type , str ): piece += f \": { prop_type } \" description = prop . get ( \"description\" ) if isinstance ( description , str ) and description : piece += f \" - { description } \" parts . append ( piece ) if parts : lines . append ( f \"- { spec . tool_id } : \" + \"; \" . join ( parts )) return lines @staticmethod def _render_tool_prompts ( specs , * , local_only : bool = False ) -> list [ str ]: prompts : list [ str ] = [] for spec in specs : if not spec . prompt_path : continue if local_only and spec . kind != \"local\" : continue try : tool_prompt = get_system_prompt ( spec . prompt_path ) except OSError as exc : logging . warning ( \"Failed to load tool prompt for {} : {} \" , spec . tool_id , exc ) continue if tool_prompt : prompts . append ( tool_prompt ) return prompts __init__ ( tool_registry : ToolRegistry | None ) -> None Initialize prompt builder dependencies. Source code in packages/meeseeks_core/src/meeseeks_core/planning.py 115 116 117 def __init__ ( self , tool_registry : ToolRegistry | None ) -> None : \"\"\"Initialize prompt builder dependencies.\"\"\" self . _tool_registry = tool_registry build ( base_prompt : str , context : ContextSnapshot | None , component_status : Iterable [ ComponentStatus ] | None = None , * , mode : str = 'act' , tool_specs = None , include_tool_schemas : bool = True , include_tool_guidance : bool = True ) -> str Build an augmented system prompt string. Source code in packages/meeseeks_core/src/meeseeks_core/planning.py 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 def build ( self , base_prompt : str , context : ContextSnapshot | None , component_status : Iterable [ ComponentStatus ] | None = None , * , mode : str = \"act\" , tool_specs = None , include_tool_schemas : bool = True , include_tool_guidance : bool = True , ) -> str : \"\"\"Build an augmented system prompt string.\"\"\" sections = [ base_prompt ] if context and context . summary : sections . append ( f \"Session summary: \\n { context . summary } \" ) if context and context . selected_events : rendered = render_event_lines ( context . selected_events ) if rendered : sections . append ( \"Relevant earlier context: \\n \" + rendered ) if context and context . recent_events : rendered = render_event_lines ( context . recent_events ) if rendered : sections . append ( \"Recent conversation: \\n \" + rendered ) if self . _tool_registry is not None : specs = tool_specs or self . _tool_registry . list_specs () if specs : tool_lines = \" \\n \" . join ( f \"- { spec . tool_id } : { spec . description } \" for spec in specs ) sections . append ( f \"Available tools: \\n { tool_lines } \" ) if mode == \"act\" : if include_tool_schemas : schema_lines = self . _render_schema_lines ( specs ) if schema_lines : sections . append ( \"Tool input schemas: \\n \" + \" \\n \" . join ( schema_lines )) if include_tool_guidance : tool_prompts = self . _render_tool_prompts ( specs , local_only = True ) if tool_prompts : sections . append ( \"Tool guidance: \\n \" + \" \\n\\n \" . join ( tool_prompts )) if component_status : sections . append ( \"Component status: \\n \" + format_component_status ( component_status )) return \" \\n\\n \" . join ( sections ) ResponseSynthesizer Synthesize a response from tool outputs. Source code in packages/meeseeks_core/src/meeseeks_core/planning.py 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 class ResponseSynthesizer : \"\"\"Synthesize a response from tool outputs.\"\"\" def __init__ ( self , tool_registry : ToolRegistry | None ) -> None : \"\"\"Initialize the response synthesizer.\"\"\" self . _prompt_builder = PromptBuilder ( tool_registry ) def synthesize ( self , user_query : str , tool_outputs : list [ str ], model_name : str | None , context : ContextSnapshot | None , ) -> str : \"\"\"Synthesize a response from tool outputs.\"\"\" model_name = model_name or get_config_value ( \"llm\" , \"default_model\" , default = \"gpt-5.2\" ) system_prompt = self . _prompt_builder . build ( get_system_prompt ( \"response-synthesizer\" ), context , mode = \"synthesize\" , ) prompt = ChatPromptTemplate ( messages = [ SystemMessage ( content = system_prompt ), HumanMessagePromptTemplate . from_template ( \"User request: {user_query} \\n\\n Tool outputs: \\n {tool_outputs} \\n\\n \" \"Respond to the user using the tool outputs.\" ), ], input_variables = [ \"user_query\" , \"tool_outputs\" ], ) model = build_chat_model ( model_name = model_name , openai_api_base = get_config_value ( \"llm\" , \"api_base\" ), api_key = get_config_value ( \"llm\" , \"api_key\" ), ) handler = build_langfuse_handler ( user_id = \"meeseeks-response\" , session_id = f \"response- { os . getpid () } - { os . urandom ( 4 ) . hex () } \" , trace_name = \"meeseeks-response\" , version = get_config_value ( \"runtime\" , \"version\" , default = \"Not Specified\" ), release = get_config_value ( \"runtime\" , \"envmode\" , default = \"Not Specified\" ), ) config : dict [ str , object ] = {} if handler is not None : config [ \"callbacks\" ] = [ handler ] metadata = getattr ( handler , \"langfuse_metadata\" , None ) if isinstance ( metadata , dict ) and metadata : config [ \"metadata\" ] = metadata with langfuse_trace_span ( \"response-synthesize\" ) as span : if span is not None : try : span . update_trace ( input = { \"user_query\" : user_query . strip (), \"tool_output_count\" : len ( tool_outputs ), } ) except Exception : pass output = ( prompt | model ) . invoke ( { \"user_query\" : user_query . strip (), \"tool_outputs\" : \" \\n \" . join ( f \"- { item } \" for item in tool_outputs ), }, config = config or None , ) if span is not None : try : span . update_trace ( output = { \"response\" : str ( getattr ( output , \"content\" , output ))}) except Exception : pass content = getattr ( output , \"content\" , output ) return str ( content ) . strip () __init__ ( tool_registry : ToolRegistry | None ) -> None Initialize the response synthesizer. Source code in packages/meeseeks_core/src/meeseeks_core/planning.py 569 570 571 def __init__ ( self , tool_registry : ToolRegistry | None ) -> None : \"\"\"Initialize the response synthesizer.\"\"\" self . _prompt_builder = PromptBuilder ( tool_registry ) synthesize ( user_query : str , tool_outputs : list [ str ], model_name : str | None , context : ContextSnapshot | None ) -> str Synthesize a response from tool outputs. Source code in packages/meeseeks_core/src/meeseeks_core/planning.py 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 def synthesize ( self , user_query : str , tool_outputs : list [ str ], model_name : str | None , context : ContextSnapshot | None , ) -> str : \"\"\"Synthesize a response from tool outputs.\"\"\" model_name = model_name or get_config_value ( \"llm\" , \"default_model\" , default = \"gpt-5.2\" ) system_prompt = self . _prompt_builder . build ( get_system_prompt ( \"response-synthesizer\" ), context , mode = \"synthesize\" , ) prompt = ChatPromptTemplate ( messages = [ SystemMessage ( content = system_prompt ), HumanMessagePromptTemplate . from_template ( \"User request: {user_query} \\n\\n Tool outputs: \\n {tool_outputs} \\n\\n \" \"Respond to the user using the tool outputs.\" ), ], input_variables = [ \"user_query\" , \"tool_outputs\" ], ) model = build_chat_model ( model_name = model_name , openai_api_base = get_config_value ( \"llm\" , \"api_base\" ), api_key = get_config_value ( \"llm\" , \"api_key\" ), ) handler = build_langfuse_handler ( user_id = \"meeseeks-response\" , session_id = f \"response- { os . getpid () } - { os . urandom ( 4 ) . hex () } \" , trace_name = \"meeseeks-response\" , version = get_config_value ( \"runtime\" , \"version\" , default = \"Not Specified\" ), release = get_config_value ( \"runtime\" , \"envmode\" , default = \"Not Specified\" ), ) config : dict [ str , object ] = {} if handler is not None : config [ \"callbacks\" ] = [ handler ] metadata = getattr ( handler , \"langfuse_metadata\" , None ) if isinstance ( metadata , dict ) and metadata : config [ \"metadata\" ] = metadata with langfuse_trace_span ( \"response-synthesize\" ) as span : if span is not None : try : span . update_trace ( input = { \"user_query\" : user_query . strip (), \"tool_output_count\" : len ( tool_outputs ), } ) except Exception : pass output = ( prompt | model ) . invoke ( { \"user_query\" : user_query . strip (), \"tool_outputs\" : \" \\n \" . join ( f \"- { item } \" for item in tool_outputs ), }, config = config or None , ) if span is not None : try : span . update_trace ( output = { \"response\" : str ( getattr ( output , \"content\" , output ))}) except Exception : pass content = getattr ( output , \"content\" , output ) return str ( content ) . strip () StepDecision Bases: BaseModel Decision on how to execute a single plan step. Source code in packages/meeseeks_core/src/meeseeks_core/planning.py 97 98 99 100 101 102 103 class StepDecision ( BaseModel ): \"\"\"Decision on how to execute a single plan step.\"\"\" decision : str = Field ( description = \"tool or respond\" ) tool_id : str | None = None args : object | None = None response : str | None = None StepExecutor Decide how to execute a single plan step. Source code in packages/meeseeks_core/src/meeseeks_core/planning.py 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 class StepExecutor : \"\"\"Decide how to execute a single plan step.\"\"\" def __init__ ( self , tool_registry : ToolRegistry | None ) -> None : \"\"\"Initialize the step executor.\"\"\" self . _tool_registry = tool_registry def decide ( self , user_query : str , step : PlanStep , model_name : str , * , allowed_tools : list [ ToolSpec ], context : ContextSnapshot | None = None , ) -> StepDecision : \"\"\"Return a decision for executing the step.\"\"\" if self . _tool_registry is None : raise ValueError ( \"Tool registry is required for step execution.\" ) parser = PydanticOutputParser ( pydantic_object = StepDecision ) # type: ignore[type-var] system_prompt = get_system_prompt ( \"step-executor\" ) tools_text = _render_tool_catalog ( allowed_tools , include_schema = True ) prompt = ChatPromptTemplate ( messages = [ SystemMessage ( content = ( f \" { system_prompt } \\n\\n Allowed tools: \\n { tools_text } \" if tools_text else system_prompt ) ), HumanMessagePromptTemplate . from_template ( \"User request: \\n {user_query} \\n\\n \" \"Plan step: \\n - {title} \\n - {description} \\n\\n \" \" {format_instructions} \" ), ], partial_variables = { \"format_instructions\" : parser . get_format_instructions ()}, input_variables = [ \"user_query\" , \"title\" , \"description\" ], ) model = build_chat_model ( model_name = model_name , openai_api_base = get_config_value ( \"llm\" , \"api_base\" ), api_key = get_config_value ( \"llm\" , \"api_key\" ), ) decision = ( prompt | model | parser ) . invoke ( { \"user_query\" : user_query . strip (), \"title\" : step . title , \"description\" : step . description , } ) return decision __init__ ( tool_registry : ToolRegistry | None ) -> None Initialize the step executor. Source code in packages/meeseeks_core/src/meeseeks_core/planning.py 461 462 463 def __init__ ( self , tool_registry : ToolRegistry | None ) -> None : \"\"\"Initialize the step executor.\"\"\" self . _tool_registry = tool_registry decide ( user_query : str , step : PlanStep , model_name : str , * , allowed_tools : list [ ToolSpec ], context : ContextSnapshot | None = None ) -> StepDecision Return a decision for executing the step. Source code in packages/meeseeks_core/src/meeseeks_core/planning.py 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 def decide ( self , user_query : str , step : PlanStep , model_name : str , * , allowed_tools : list [ ToolSpec ], context : ContextSnapshot | None = None , ) -> StepDecision : \"\"\"Return a decision for executing the step.\"\"\" if self . _tool_registry is None : raise ValueError ( \"Tool registry is required for step execution.\" ) parser = PydanticOutputParser ( pydantic_object = StepDecision ) # type: ignore[type-var] system_prompt = get_system_prompt ( \"step-executor\" ) tools_text = _render_tool_catalog ( allowed_tools , include_schema = True ) prompt = ChatPromptTemplate ( messages = [ SystemMessage ( content = ( f \" { system_prompt } \\n\\n Allowed tools: \\n { tools_text } \" if tools_text else system_prompt ) ), HumanMessagePromptTemplate . from_template ( \"User request: \\n {user_query} \\n\\n \" \"Plan step: \\n - {title} \\n - {description} \\n\\n \" \" {format_instructions} \" ), ], partial_variables = { \"format_instructions\" : parser . get_format_instructions ()}, input_variables = [ \"user_query\" , \"title\" , \"description\" ], ) model = build_chat_model ( model_name = model_name , openai_api_base = get_config_value ( \"llm\" , \"api_base\" ), api_key = get_config_value ( \"llm\" , \"api_key\" ), ) decision = ( prompt | model | parser ) . invoke ( { \"user_query\" : user_query . strip (), \"title\" : step . title , \"description\" : step . description , } ) return decision ToolSelection Bases: BaseModel Tool selection decision for a user query. Source code in packages/meeseeks_core/src/meeseeks_core/planning.py 89 90 91 92 93 94 class ToolSelection ( BaseModel ): \"\"\"Tool selection decision for a user query.\"\"\" tool_required : bool = Field ( default = False ) tool_ids : list [ str ] = Field ( default_factory = list ) rationale : str | None = None ToolSelector Select tools needed to satisfy a request. Source code in packages/meeseeks_core/src/meeseeks_core/planning.py 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 class ToolSelector : \"\"\"Select tools needed to satisfy a request.\"\"\" def __init__ ( self , tool_registry : ToolRegistry | None ) -> None : \"\"\"Initialize the tool selector.\"\"\" self . _tool_registry = tool_registry def select ( self , user_query : str , model_name : str , * , tool_specs : list [ ToolSpec ], context : ContextSnapshot | None = None , ) -> ToolSelection : \"\"\"Return a tool selection decision.\"\"\" if self . _tool_registry is None : raise ValueError ( \"Tool registry is required for tool selection.\" ) parser = PydanticOutputParser ( pydantic_object = ToolSelection ) # type: ignore[type-var] system_prompt = get_system_prompt ( \"tool-selector\" ) tools_text = _render_tool_catalog ( tool_specs , include_schema = False ) prompt = ChatPromptTemplate ( messages = [ SystemMessage ( content = ( f \" { system_prompt } \\n\\n Available tools: \\n { tools_text } \" if tools_text else system_prompt ) ), HumanMessagePromptTemplate . from_template ( \"User request: \\n {user_query} \\n\\n {format_instructions} \" ), ], partial_variables = { \"format_instructions\" : parser . get_format_instructions ()}, input_variables = [ \"user_query\" ], ) try : model = build_chat_model ( model_name = model_name , openai_api_base = get_config_value ( \"llm\" , \"api_base\" ), api_key = get_config_value ( \"llm\" , \"api_key\" ), ) selection = ( prompt | model | parser ) . invoke ({ \"user_query\" : user_query . strip ()}) if selection . tool_required and selection . tool_ids : specs_by_id = { spec . tool_id : spec for spec in tool_specs } selected_caps : set [ str ] = set () for tool_id in selection . tool_ids : spec = specs_by_id . get ( tool_id ) if spec is not None : selected_caps |= Planner . _spec_capabilities ( spec ) if \"web_search\" in selected_caps : for spec in tool_specs : if \"web_read\" in Planner . _spec_capabilities ( spec ): if spec . tool_id not in selection . tool_ids : selection . tool_ids . append ( spec . tool_id ) return selection except Exception as exc : # pragma: no cover - defensive fallback logging . warning ( \"Tool selector unavailable, falling back to all tools: {} \" , exc ) return ToolSelection ( tool_required = bool ( tool_specs ), tool_ids = [ spec . tool_id for spec in tool_specs ], rationale = \"fallback\" , ) __init__ ( tool_registry : ToolRegistry | None ) -> None Initialize the tool selector. Source code in packages/meeseeks_core/src/meeseeks_core/planning.py 395 396 397 def __init__ ( self , tool_registry : ToolRegistry | None ) -> None : \"\"\"Initialize the tool selector.\"\"\" self . _tool_registry = tool_registry select ( user_query : str , model_name : str , * , tool_specs : list [ ToolSpec ], context : ContextSnapshot | None = None ) -> ToolSelection Return a tool selection decision. Source code in packages/meeseeks_core/src/meeseeks_core/planning.py 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 def select ( self , user_query : str , model_name : str , * , tool_specs : list [ ToolSpec ], context : ContextSnapshot | None = None , ) -> ToolSelection : \"\"\"Return a tool selection decision.\"\"\" if self . _tool_registry is None : raise ValueError ( \"Tool registry is required for tool selection.\" ) parser = PydanticOutputParser ( pydantic_object = ToolSelection ) # type: ignore[type-var] system_prompt = get_system_prompt ( \"tool-selector\" ) tools_text = _render_tool_catalog ( tool_specs , include_schema = False ) prompt = ChatPromptTemplate ( messages = [ SystemMessage ( content = ( f \" { system_prompt } \\n\\n Available tools: \\n { tools_text } \" if tools_text else system_prompt ) ), HumanMessagePromptTemplate . from_template ( \"User request: \\n {user_query} \\n\\n {format_instructions} \" ), ], partial_variables = { \"format_instructions\" : parser . get_format_instructions ()}, input_variables = [ \"user_query\" ], ) try : model = build_chat_model ( model_name = model_name , openai_api_base = get_config_value ( \"llm\" , \"api_base\" ), api_key = get_config_value ( \"llm\" , \"api_key\" ), ) selection = ( prompt | model | parser ) . invoke ({ \"user_query\" : user_query . strip ()}) if selection . tool_required and selection . tool_ids : specs_by_id = { spec . tool_id : spec for spec in tool_specs } selected_caps : set [ str ] = set () for tool_id in selection . tool_ids : spec = specs_by_id . get ( tool_id ) if spec is not None : selected_caps |= Planner . _spec_capabilities ( spec ) if \"web_search\" in selected_caps : for spec in tool_specs : if \"web_read\" in Planner . _spec_capabilities ( spec ): if spec . tool_id not in selection . tool_ids : selection . tool_ids . append ( spec . tool_id ) return selection except Exception as exc : # pragma: no cover - defensive fallback logging . warning ( \"Tool selector unavailable, falling back to all tools: {} \" , exc ) return ToolSelection ( tool_required = bool ( tool_specs ), tool_ids = [ spec . tool_id for spec in tool_specs ], rationale = \"fallback\" , ) meeseeks_core.reflection Step reflection helpers. StepReflection Bases: BaseModel Model output for step-level reflection. Source code in packages/meeseeks_core/src/meeseeks_core/reflection.py 23 24 25 26 27 28 class StepReflection ( BaseModel ): \"\"\"Model output for step-level reflection.\"\"\" status : Literal [ \"ok\" , \"retry\" , \"revise\" ] = Field ( default = \"ok\" ) notes : str | None = None revised_argument : str | None = None StepReflector Reflect on tool results when objectives are provided. Source code in packages/meeseeks_core/src/meeseeks_core/reflection.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 class StepReflector : \"\"\"Reflect on tool results when objectives are provided.\"\"\" def __init__ ( self , model_name : str | None ) -> None : \"\"\"Initialize the step reflector.\"\"\" self . _model_name = model_name def reflect ( self , action_step : ActionStep , result_text : str ) -> StepReflection | None : \"\"\"Return a reflection decision for a step.\"\"\" if not ( action_step . objective or action_step . expected_output or action_step . execution_checklist ): return None if not get_config_value ( \"reflection\" , \"enabled\" , default = True ): return None reflection_model = ( get_config_value ( \"reflection\" , \"model\" ) or self . _model_name or get_config_value ( \"llm\" , \"action_plan_model\" ) or get_config_value ( \"llm\" , \"default_model\" ) ) if not reflection_model : return None parser = PydanticOutputParser ( pydantic_object = StepReflection ) # type: ignore[type-var] prompt = ChatPromptTemplate ( messages = [ SystemMessage ( content = ( \"Reflect on whether the tool result satisfies the step objective. \" \"Return status 'ok' if complete, 'retry' if the step should be \" \"re-executed, or 'revise' if the tool input needs adjustment.\" ) ), HumanMessagePromptTemplate . from_template ( \"Step title: {title} \\n \" \"Objective: {objective} \\n \" \"Checklist: {checklist} \\n \" \"Expected output: {expected} \\n \" \"Tool result: {result} \\n\\n \" \" {format_instructions} \" ), ], partial_variables = { \"format_instructions\" : parser . get_format_instructions ()}, input_variables = [ \"title\" , \"objective\" , \"checklist\" , \"expected\" , \"result\" ], ) try : model = build_chat_model ( model_name = reflection_model , openai_api_base = get_config_value ( \"llm\" , \"api_base\" ), api_key = get_config_value ( \"llm\" , \"api_key\" ), ) except Exception as exc : logging . warning ( \"Step reflection unavailable: {} \" , exc ) return None handler = build_langfuse_handler ( user_id = \"meeseeks-reflection\" , session_id = f \"reflection- { os . getpid () } - { os . urandom ( 4 ) . hex () } \" , trace_name = \"meeseeks-reflection\" , version = get_config_value ( \"runtime\" , \"version\" , default = \"Not Specified\" ), release = get_config_value ( \"runtime\" , \"envmode\" , default = \"Not Specified\" ), ) config : dict [ str , object ] = {} if handler is not None : config [ \"callbacks\" ] = [ handler ] metadata = getattr ( handler , \"langfuse_metadata\" , None ) if isinstance ( metadata , dict ) and metadata : config [ \"metadata\" ] = metadata try : with langfuse_trace_span ( \"step-reflection\" ) as span : if span is not None : try : span . update_trace ( input = { \"title\" : action_step . title or action_step . tool_id , \"objective\" : action_step . objective or format_tool_input ( action_step . tool_input ), } ) except Exception : pass reflection = ( prompt | model | parser ) . invoke ( { \"title\" : action_step . title or action_step . tool_id , \"objective\" : action_step . objective or format_tool_input ( action_step . tool_input ), \"checklist\" : \"; \" . join ( action_step . execution_checklist or []), \"expected\" : action_step . expected_output or \"Not specified\" , \"result\" : result_text , }, config = config or None , ) if span is not None : try : span . update_trace ( output = { \"status\" : getattr ( reflection , \"status\" , None ), \"notes\" : getattr ( reflection , \"notes\" , None ), } ) except Exception : pass return reflection except Exception as exc : # pragma: no cover - defensive logging . warning ( \"Step reflection failed: {} \" , exc ) return None __init__ ( model_name : str | None ) -> None Initialize the step reflector. Source code in packages/meeseeks_core/src/meeseeks_core/reflection.py 34 35 36 def __init__ ( self , model_name : str | None ) -> None : \"\"\"Initialize the step reflector.\"\"\" self . _model_name = model_name reflect ( action_step : ActionStep , result_text : str ) -> StepReflection | None Return a reflection decision for a step. Source code in packages/meeseeks_core/src/meeseeks_core/reflection.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 def reflect ( self , action_step : ActionStep , result_text : str ) -> StepReflection | None : \"\"\"Return a reflection decision for a step.\"\"\" if not ( action_step . objective or action_step . expected_output or action_step . execution_checklist ): return None if not get_config_value ( \"reflection\" , \"enabled\" , default = True ): return None reflection_model = ( get_config_value ( \"reflection\" , \"model\" ) or self . _model_name or get_config_value ( \"llm\" , \"action_plan_model\" ) or get_config_value ( \"llm\" , \"default_model\" ) ) if not reflection_model : return None parser = PydanticOutputParser ( pydantic_object = StepReflection ) # type: ignore[type-var] prompt = ChatPromptTemplate ( messages = [ SystemMessage ( content = ( \"Reflect on whether the tool result satisfies the step objective. \" \"Return status 'ok' if complete, 'retry' if the step should be \" \"re-executed, or 'revise' if the tool input needs adjustment.\" ) ), HumanMessagePromptTemplate . from_template ( \"Step title: {title} \\n \" \"Objective: {objective} \\n \" \"Checklist: {checklist} \\n \" \"Expected output: {expected} \\n \" \"Tool result: {result} \\n\\n \" \" {format_instructions} \" ), ], partial_variables = { \"format_instructions\" : parser . get_format_instructions ()}, input_variables = [ \"title\" , \"objective\" , \"checklist\" , \"expected\" , \"result\" ], ) try : model = build_chat_model ( model_name = reflection_model , openai_api_base = get_config_value ( \"llm\" , \"api_base\" ), api_key = get_config_value ( \"llm\" , \"api_key\" ), ) except Exception as exc : logging . warning ( \"Step reflection unavailable: {} \" , exc ) return None handler = build_langfuse_handler ( user_id = \"meeseeks-reflection\" , session_id = f \"reflection- { os . getpid () } - { os . urandom ( 4 ) . hex () } \" , trace_name = \"meeseeks-reflection\" , version = get_config_value ( \"runtime\" , \"version\" , default = \"Not Specified\" ), release = get_config_value ( \"runtime\" , \"envmode\" , default = \"Not Specified\" ), ) config : dict [ str , object ] = {} if handler is not None : config [ \"callbacks\" ] = [ handler ] metadata = getattr ( handler , \"langfuse_metadata\" , None ) if isinstance ( metadata , dict ) and metadata : config [ \"metadata\" ] = metadata try : with langfuse_trace_span ( \"step-reflection\" ) as span : if span is not None : try : span . update_trace ( input = { \"title\" : action_step . title or action_step . tool_id , \"objective\" : action_step . objective or format_tool_input ( action_step . tool_input ), } ) except Exception : pass reflection = ( prompt | model | parser ) . invoke ( { \"title\" : action_step . title or action_step . tool_id , \"objective\" : action_step . objective or format_tool_input ( action_step . tool_input ), \"checklist\" : \"; \" . join ( action_step . execution_checklist or []), \"expected\" : action_step . expected_output or \"Not specified\" , \"result\" : result_text , }, config = config or None , ) if span is not None : try : span . update_trace ( output = { \"status\" : getattr ( reflection , \"status\" , None ), \"notes\" : getattr ( reflection , \"notes\" , None ), } ) except Exception : pass return reflection except Exception as exc : # pragma: no cover - defensive logging . warning ( \"Step reflection failed: {} \" , exc ) return None meeseeks_core.session_runtime Shared session runtime utilities for CLI and API. RunHandle dataclass Active orchestration thread tracking. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 41 42 43 44 45 46 47 @dataclass ( frozen = True ) class RunHandle : \"\"\"Active orchestration thread tracking.\"\"\" thread : threading . Thread cancel_event : threading . Event started_at : str RunRegistry Track active orchestration threads per session. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 class RunRegistry : \"\"\"Track active orchestration threads per session.\"\"\" def __init__ ( self ) -> None : \"\"\"Initialize the run registry.\"\"\" self . _lock = threading . Lock () self . _runs : dict [ str , RunHandle ] = {} def start ( self , session_id : str , target : Callable [[ threading . Event ], None ], ) -> bool : \"\"\"Start a new run for the session if one is not already active.\"\"\" with self . _lock : existing = self . _runs . get ( session_id ) if existing and existing . thread . is_alive (): return False cancel_event = threading . Event () thread = threading . Thread ( target = self . _wrap_run , args = ( session_id , cancel_event , target ), daemon = True , ) self . _runs [ session_id ] = RunHandle ( thread = thread , cancel_event = cancel_event , started_at = _utc_now (), ) thread . start () return True def _wrap_run ( self , session_id : str , cancel_event : threading . Event , target : Callable [[ threading . Event ], None ], ) -> None : try : target ( cancel_event ) finally : with self . _lock : handle = self . _runs . get ( session_id ) if handle and handle . thread . ident == threading . current_thread () . ident : self . _runs . pop ( session_id , None ) def cancel ( self , session_id : str ) -> bool : \"\"\"Request cancellation for an active session run.\"\"\" with self . _lock : handle = self . _runs . get ( session_id ) if not handle : return False handle . cancel_event . set () return True def is_running ( self , session_id : str ) -> bool : \"\"\"Return True if the session has an active run.\"\"\" with self . _lock : handle = self . _runs . get ( session_id ) return bool ( handle and handle . thread . is_alive ()) def get_cancel_event ( self , session_id : str ) -> threading . Event | None : \"\"\"Return the cancel event for a session, if present.\"\"\" with self . _lock : handle = self . _runs . get ( session_id ) return handle . cancel_event if handle else None __init__ () -> None Initialize the run registry. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 53 54 55 56 def __init__ ( self ) -> None : \"\"\"Initialize the run registry.\"\"\" self . _lock = threading . Lock () self . _runs : dict [ str , RunHandle ] = {} cancel ( session_id : str ) -> bool Request cancellation for an active session run. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 96 97 98 99 100 101 102 103 def cancel ( self , session_id : str ) -> bool : \"\"\"Request cancellation for an active session run.\"\"\" with self . _lock : handle = self . _runs . get ( session_id ) if not handle : return False handle . cancel_event . set () return True get_cancel_event ( session_id : str ) -> threading . Event | None Return the cancel event for a session, if present. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 111 112 113 114 115 def get_cancel_event ( self , session_id : str ) -> threading . Event | None : \"\"\"Return the cancel event for a session, if present.\"\"\" with self . _lock : handle = self . _runs . get ( session_id ) return handle . cancel_event if handle else None is_running ( session_id : str ) -> bool Return True if the session has an active run. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 105 106 107 108 109 def is_running ( self , session_id : str ) -> bool : \"\"\"Return True if the session has an active run.\"\"\" with self . _lock : handle = self . _runs . get ( session_id ) return bool ( handle and handle . thread . is_alive ()) start ( session_id : str , target : Callable [[ threading . Event ], None ]) -> bool Start a new run for the session if one is not already active. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def start ( self , session_id : str , target : Callable [[ threading . Event ], None ], ) -> bool : \"\"\"Start a new run for the session if one is not already active.\"\"\" with self . _lock : existing = self . _runs . get ( session_id ) if existing and existing . thread . is_alive (): return False cancel_event = threading . Event () thread = threading . Thread ( target = self . _wrap_run , args = ( session_id , cancel_event , target ), daemon = True , ) self . _runs [ session_id ] = RunHandle ( thread = thread , cancel_event = cancel_event , started_at = _utc_now (), ) thread . start () return True SessionRuntime Shared orchestration runtime surface for CLI and API. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 class SessionRuntime : \"\"\"Shared orchestration runtime surface for CLI and API.\"\"\" def __init__ ( self , * , session_store : SessionStore | None = None , run_registry : RunRegistry | None = None , ) -> None : \"\"\"Initialize the runtime with session storage and optional run registry.\"\"\" self . _session_store = session_store or SessionStore () self . _run_registry = run_registry or RunRegistry () @property def session_store ( self ) -> SessionStore : \"\"\"Expose the underlying session store.\"\"\" return self . _session_store def resolve_session ( self , * , session_id : str | None = None , session_tag : str | None = None , fork_from : str | None = None , ) -> str : \"\"\"Resolve session identifiers, tags, and forks to a session id.\"\"\" if fork_from : source_session_id = self . _session_store . resolve_tag ( fork_from ) or fork_from session_id = self . _session_store . fork_session ( source_session_id ) if session_tag and not session_id : resolved = self . _session_store . resolve_tag ( session_tag ) session_id = resolved if resolved else None if not session_id : session_id = self . _session_store . create_session () if session_tag : self . _session_store . tag_session ( session_id , session_tag ) assert session_id is not None return session_id def append_context_event ( self , session_id : str , context : dict [ str , object ]) -> None : \"\"\"Append a context event to the session transcript.\"\"\" if not context : return self . _session_store . append_event ( session_id , { \"type\" : \"context\" , \"payload\" : context }) def summarize_session ( self , session_id : str , * , events : list [ EventRecord ] | None = None , ) -> dict [ str , object ]: \"\"\"Return a summarized view of a session.\"\"\" if events is None : events = self . _session_store . load_transcript ( session_id ) created_at = events [ 0 ][ \"ts\" ] if events else None title = None status = \"idle\" done_reason = None context : dict [ str , object ] | None = None has_user_event = False for event in events : if event . get ( \"type\" ) == \"context\" : payload = event . get ( \"payload\" ) if isinstance ( payload , dict ): context = payload if title is None and event . get ( \"type\" ) == \"user\" : has_user_event = True payload = event . get ( \"payload\" , {}) if isinstance ( payload , dict ): title = payload . get ( \"text\" ) if event . get ( \"type\" ) == \"completion\" : payload = event . get ( \"payload\" , {}) if isinstance ( payload , dict ): done_reason = payload . get ( \"done_reason\" ) status = \"completed\" if payload . get ( \"done\" ) else \"incomplete\" running = self . is_running ( session_id ) if running : status = \"running\" if not has_user_event and not running : created_at = None if not title : title = f \"Session { session_id [: 8 ] } \" return { \"session_id\" : session_id , \"title\" : title , \"created_at\" : created_at , \"status\" : status , \"done_reason\" : done_reason , \"running\" : running , \"context\" : context or {}, \"archived\" : self . _session_store . is_archived ( session_id ), } def list_sessions ( self , * , include_archived : bool = False ) -> list [ dict [ str , object ]]: \"\"\"List sessions with summary metadata.\"\"\" summaries : list [ dict [ str , object ]] = [] for session_id in self . _session_store . list_sessions (): events = self . _session_store . load_transcript ( session_id ) summary = self . summarize_session ( session_id , events = events ) has_visible_event = any ( event . get ( \"type\" ) not in { \"session\" , \"context\" } for event in events ) if not has_visible_event and not summary . get ( \"running\" ): continue if summary . get ( \"created_at\" ) is None and not summary . get ( \"running\" ): continue if not include_archived and summary . get ( \"archived\" ): continue summaries . append ( summary ) return summaries def load_events ( self , session_id : str , after : str | None = None ) -> list [ EventRecord ]: \"\"\"Load events for a session with optional timestamp filtering.\"\"\" events = self . _session_store . load_transcript ( session_id ) return _filter_events ( events , after ) def start_async ( self , * , session_id : str , user_query : str , model_name : str | None = None , max_iters : int = 3 , initial_plan : Plan | None = None , tool_registry = None , permission_policy = None , approval_callback = None , hook_manager = None , mode : str | None = None , ) -> bool : \"\"\"Start an asynchronous orchestration run for the session.\"\"\" def _run ( cancel_event : threading . Event ) -> None : self . run_sync ( user_query = user_query , session_id = session_id , model_name = model_name , max_iters = max_iters , initial_plan = initial_plan , tool_registry = tool_registry , permission_policy = permission_policy , approval_callback = approval_callback , hook_manager = hook_manager , mode = mode , should_cancel = cancel_event . is_set , ) return self . _run_registry . start ( session_id , target = _run ) def run_sync ( self , * , user_query : str , session_id : str , model_name : str | None = None , max_iters : int = 3 , initial_plan : Plan | None = None , tool_registry = None , permission_policy = None , approval_callback = None , hook_manager = None , mode : str | None = None , should_cancel : Callable [[], bool ] | None = None , ) -> TaskQueue : \"\"\"Run an orchestration request synchronously.\"\"\" return orchestrate_session ( user_query = user_query , model_name = model_name , max_iters = max_iters , initial_plan = initial_plan , session_id = session_id , session_store = self . _session_store , tool_registry = tool_registry , permission_policy = permission_policy , approval_callback = approval_callback , hook_manager = hook_manager , mode = mode , should_cancel = should_cancel , ) def cancel ( self , session_id : str ) -> bool : \"\"\"Cancel an active run if present.\"\"\" return self . _run_registry . cancel ( session_id ) def is_running ( self , session_id : str ) -> bool : \"\"\"Return True if session has an active run.\"\"\" return self . _run_registry . is_running ( session_id ) session_store : SessionStore property Expose the underlying session store. __init__ ( * , session_store : SessionStore | None = None , run_registry : RunRegistry | None = None ) -> None Initialize the runtime with session storage and optional run registry. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 135 136 137 138 139 140 141 142 143 def __init__ ( self , * , session_store : SessionStore | None = None , run_registry : RunRegistry | None = None , ) -> None : \"\"\"Initialize the runtime with session storage and optional run registry.\"\"\" self . _session_store = session_store or SessionStore () self . _run_registry = run_registry or RunRegistry () append_context_event ( session_id : str , context : dict [ str , object ]) -> None Append a context event to the session transcript. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 171 172 173 174 175 def append_context_event ( self , session_id : str , context : dict [ str , object ]) -> None : \"\"\"Append a context event to the session transcript.\"\"\" if not context : return self . _session_store . append_event ( session_id , { \"type\" : \"context\" , \"payload\" : context }) cancel ( session_id : str ) -> bool Cancel an active run if present. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 312 313 314 def cancel ( self , session_id : str ) -> bool : \"\"\"Cancel an active run if present.\"\"\" return self . _run_registry . cancel ( session_id ) is_running ( session_id : str ) -> bool Return True if session has an active run. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 316 317 318 def is_running ( self , session_id : str ) -> bool : \"\"\"Return True if session has an active run.\"\"\" return self . _run_registry . is_running ( session_id ) list_sessions ( * , include_archived : bool = False ) -> list [ dict [ str , object ]] List sessions with summary metadata. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 def list_sessions ( self , * , include_archived : bool = False ) -> list [ dict [ str , object ]]: \"\"\"List sessions with summary metadata.\"\"\" summaries : list [ dict [ str , object ]] = [] for session_id in self . _session_store . list_sessions (): events = self . _session_store . load_transcript ( session_id ) summary = self . summarize_session ( session_id , events = events ) has_visible_event = any ( event . get ( \"type\" ) not in { \"session\" , \"context\" } for event in events ) if not has_visible_event and not summary . get ( \"running\" ): continue if summary . get ( \"created_at\" ) is None and not summary . get ( \"running\" ): continue if not include_archived and summary . get ( \"archived\" ): continue summaries . append ( summary ) return summaries load_events ( session_id : str , after : str | None = None ) -> list [ EventRecord ] Load events for a session with optional timestamp filtering. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 243 244 245 246 def load_events ( self , session_id : str , after : str | None = None ) -> list [ EventRecord ]: \"\"\"Load events for a session with optional timestamp filtering.\"\"\" events = self . _session_store . load_transcript ( session_id ) return _filter_events ( events , after ) resolve_session ( * , session_id : str | None = None , session_tag : str | None = None , fork_from : str | None = None ) -> str Resolve session identifiers, tags, and forks to a session id. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 def resolve_session ( self , * , session_id : str | None = None , session_tag : str | None = None , fork_from : str | None = None , ) -> str : \"\"\"Resolve session identifiers, tags, and forks to a session id.\"\"\" if fork_from : source_session_id = self . _session_store . resolve_tag ( fork_from ) or fork_from session_id = self . _session_store . fork_session ( source_session_id ) if session_tag and not session_id : resolved = self . _session_store . resolve_tag ( session_tag ) session_id = resolved if resolved else None if not session_id : session_id = self . _session_store . create_session () if session_tag : self . _session_store . tag_session ( session_id , session_tag ) assert session_id is not None return session_id run_sync ( * , user_query : str , session_id : str , model_name : str | None = None , max_iters : int = 3 , initial_plan : Plan | None = None , tool_registry = None , permission_policy = None , approval_callback = None , hook_manager = None , mode : str | None = None , should_cancel : Callable [[], bool ] | None = None ) -> TaskQueue Run an orchestration request synchronously. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 def run_sync ( self , * , user_query : str , session_id : str , model_name : str | None = None , max_iters : int = 3 , initial_plan : Plan | None = None , tool_registry = None , permission_policy = None , approval_callback = None , hook_manager = None , mode : str | None = None , should_cancel : Callable [[], bool ] | None = None , ) -> TaskQueue : \"\"\"Run an orchestration request synchronously.\"\"\" return orchestrate_session ( user_query = user_query , model_name = model_name , max_iters = max_iters , initial_plan = initial_plan , session_id = session_id , session_store = self . _session_store , tool_registry = tool_registry , permission_policy = permission_policy , approval_callback = approval_callback , hook_manager = hook_manager , mode = mode , should_cancel = should_cancel , ) start_async ( * , session_id : str , user_query : str , model_name : str | None = None , max_iters : int = 3 , initial_plan : Plan | None = None , tool_registry = None , permission_policy = None , approval_callback = None , hook_manager = None , mode : str | None = None ) -> bool Start an asynchronous orchestration run for the session. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 def start_async ( self , * , session_id : str , user_query : str , model_name : str | None = None , max_iters : int = 3 , initial_plan : Plan | None = None , tool_registry = None , permission_policy = None , approval_callback = None , hook_manager = None , mode : str | None = None , ) -> bool : \"\"\"Start an asynchronous orchestration run for the session.\"\"\" def _run ( cancel_event : threading . Event ) -> None : self . run_sync ( user_query = user_query , session_id = session_id , model_name = model_name , max_iters = max_iters , initial_plan = initial_plan , tool_registry = tool_registry , permission_policy = permission_policy , approval_callback = approval_callback , hook_manager = hook_manager , mode = mode , should_cancel = cancel_event . is_set , ) return self . _run_registry . start ( session_id , target = _run ) summarize_session ( session_id : str , * , events : list [ EventRecord ] | None = None ) -> dict [ str , object ] Return a summarized view of a session. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 def summarize_session ( self , session_id : str , * , events : list [ EventRecord ] | None = None , ) -> dict [ str , object ]: \"\"\"Return a summarized view of a session.\"\"\" if events is None : events = self . _session_store . load_transcript ( session_id ) created_at = events [ 0 ][ \"ts\" ] if events else None title = None status = \"idle\" done_reason = None context : dict [ str , object ] | None = None has_user_event = False for event in events : if event . get ( \"type\" ) == \"context\" : payload = event . get ( \"payload\" ) if isinstance ( payload , dict ): context = payload if title is None and event . get ( \"type\" ) == \"user\" : has_user_event = True payload = event . get ( \"payload\" , {}) if isinstance ( payload , dict ): title = payload . get ( \"text\" ) if event . get ( \"type\" ) == \"completion\" : payload = event . get ( \"payload\" , {}) if isinstance ( payload , dict ): done_reason = payload . get ( \"done_reason\" ) status = \"completed\" if payload . get ( \"done\" ) else \"incomplete\" running = self . is_running ( session_id ) if running : status = \"running\" if not has_user_event and not running : created_at = None if not title : title = f \"Session { session_id [: 8 ] } \" return { \"session_id\" : session_id , \"title\" : title , \"created_at\" : created_at , \"status\" : status , \"done_reason\" : done_reason , \"running\" : running , \"context\" : context or {}, \"archived\" : self . _session_store . is_archived ( session_id ), } parse_core_command ( text : str ) -> str | None Return the core command token if present. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 33 34 35 36 37 38 def parse_core_command ( text : str ) -> str | None : \"\"\"Return the core command token if present.\"\"\" if not text : return None command = text . strip () . lower () . split ()[ 0 ] return command if command in CORE_COMMANDS else None meeseeks_core.session_store Session transcript storage and management. SessionPaths dataclass Resolved filesystem paths for a session. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 @dataclass ( frozen = True ) class SessionPaths : \"\"\"Resolved filesystem paths for a session.\"\"\" root : str session_id : str @property def session_dir ( self ) -> str : \"\"\"Directory for session artifacts.\"\"\" return os . path . join ( self . root , self . session_id ) @property def transcript_path ( self ) -> str : \"\"\"Path to the JSONL transcript file.\"\"\" return os . path . join ( self . session_dir , \"transcript.jsonl\" ) @property def summary_path ( self ) -> str : \"\"\"Path to the summary JSON file.\"\"\" return os . path . join ( self . session_dir , \"summary.json\" ) session_dir : str property Directory for session artifacts. summary_path : str property Path to the summary JSON file. transcript_path : str property Path to the JSONL transcript file. SessionStore Filesystem-backed storage for session transcripts and summaries. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 class SessionStore : \"\"\"Filesystem-backed storage for session transcripts and summaries.\"\"\" def __init__ ( self , root_dir : str | None = None ) -> None : \"\"\"Initialize the store and ensure the root directory exists.\"\"\" if root_dir is None : root_dir = get_config_value ( \"runtime\" , \"session_dir\" , default = \"./data/sessions\" ) self . root_dir = os . path . abspath ( root_dir ) os . makedirs ( self . root_dir , exist_ok = True ) def _index_path ( self ) -> str : \"\"\"Return the path for the session index file.\"\"\" return os . path . join ( self . root_dir , \"index.json\" ) def _load_index ( self ) -> dict [ str , dict [ str , str ]]: \"\"\"Load the session index from disk or return defaults.\"\"\" index_path = self . _index_path () if not os . path . exists ( index_path ): return { \"tags\" : {}, \"archived\" : {}} with open ( index_path , encoding = \"utf-8\" ) as handle : return json . load ( handle ) def _save_index ( self , data : dict [ str , dict [ str , str ]]) -> None : \"\"\"Persist the session index to disk.\"\"\" with open ( self . _index_path (), \"w\" , encoding = \"utf-8\" ) as handle : json . dump ( data , handle , indent = 2 ) def create_session ( self ) -> str : \"\"\"Create a new session directory and return its identifier.\"\"\" session_id = uuid . uuid4 () . hex paths = self . _paths ( session_id ) os . makedirs ( paths . session_dir , exist_ok = True ) return session_id def _paths ( self , session_id : str ) -> SessionPaths : \"\"\"Build filesystem paths for a session.\"\"\" return SessionPaths ( root = self . root_dir , session_id = session_id ) def append_event ( self , session_id : str , event : Event ) -> None : \"\"\"Append a single event record to the session transcript.\"\"\" paths = self . _paths ( session_id ) os . makedirs ( paths . session_dir , exist_ok = True ) payload : EventRecord = { \"ts\" : _utc_now (), ** event } with open ( paths . transcript_path , \"a\" , encoding = \"utf-8\" ) as handle : handle . write ( json . dumps ( payload ) + \" \\n \" ) def load_transcript ( self , session_id : str ) -> list [ EventRecord ]: \"\"\"Load all transcript events for a session.\"\"\" paths = self . _paths ( session_id ) if not os . path . exists ( paths . transcript_path ): return [] events : list [ EventRecord ] = [] with open ( paths . transcript_path , encoding = \"utf-8\" ) as handle : for line in handle : line = line . strip () if not line : continue try : events . append ( json . loads ( line )) except json . JSONDecodeError : logging . warning ( \"Skipping malformed transcript line.\" ) return events def load_recent_events ( self , session_id : str , limit : int = 8 , include_types : set [ str ] | None = None , ) -> list [ EventRecord ]: \"\"\"Load the most recent events, optionally filtered by type.\"\"\" events = self . load_transcript ( session_id ) if include_types : events = [ event for event in events if event . get ( \"type\" ) in include_types ] if limit <= 0 : return [] return events [ - limit :] def save_summary ( self , session_id : str , summary : str ) -> None : \"\"\"Persist a summary for a session.\"\"\" paths = self . _paths ( session_id ) os . makedirs ( paths . session_dir , exist_ok = True ) with open ( paths . summary_path , \"w\" , encoding = \"utf-8\" ) as handle : json . dump ({ \"summary\" : summary , \"updated_at\" : _utc_now ()}, handle , indent = 2 ) def load_summary ( self , session_id : str ) -> str | None : \"\"\"Load a previously saved summary, if present.\"\"\" paths = self . _paths ( session_id ) if not os . path . exists ( paths . summary_path ): return None with open ( paths . summary_path , encoding = \"utf-8\" ) as handle : data = json . load ( handle ) return data . get ( \"summary\" ) def list_sessions ( self ) -> list [ str ]: \"\"\"List all session IDs present in the root directory.\"\"\" if not os . path . exists ( self . root_dir ): return [] return sorted ( name for name in os . listdir ( self . root_dir ) if os . path . isdir ( os . path . join ( self . root_dir , name )) ) def fork_session ( self , source_session_id : str ) -> str : \"\"\"Create a new session by copying events and summary from another.\"\"\" events = self . load_transcript ( source_session_id ) summary = self . load_summary ( source_session_id ) new_session_id = self . create_session () for event in events : self . append_event ( new_session_id , event ) if summary : self . save_summary ( new_session_id , summary ) return new_session_id def tag_session ( self , session_id : str , tag : str ) -> None : \"\"\"Associate a tag with a session ID for quick lookup.\"\"\" index = self . _load_index () index . setdefault ( \"tags\" , {})[ tag ] = session_id self . _save_index ( index ) def resolve_tag ( self , tag : str ) -> str | None : \"\"\"Resolve a tag to a session ID, if present.\"\"\" index = self . _load_index () return index . get ( \"tags\" , {}) . get ( tag ) def list_tags ( self ) -> dict [ str , str ]: \"\"\"Return a mapping of tags to session IDs.\"\"\" index = self . _load_index () return dict ( index . get ( \"tags\" , {})) def archive_session ( self , session_id : str ) -> None : \"\"\"Mark a session as archived.\"\"\" index = self . _load_index () archived = index . setdefault ( \"archived\" , {}) archived [ session_id ] = _utc_now () self . _save_index ( index ) def unarchive_session ( self , session_id : str ) -> None : \"\"\"Remove archived status from a session.\"\"\" index = self . _load_index () archived = index . get ( \"archived\" , {}) if session_id in archived : archived . pop ( session_id , None ) index [ \"archived\" ] = archived self . _save_index ( index ) def is_archived ( self , session_id : str ) -> bool : \"\"\"Return True if a session is archived.\"\"\" index = self . _load_index () archived = index . get ( \"archived\" , {}) return session_id in archived __init__ ( root_dir : str | None = None ) -> None Initialize the store and ensure the root directory exists. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 50 51 52 53 54 55 def __init__ ( self , root_dir : str | None = None ) -> None : \"\"\"Initialize the store and ensure the root directory exists.\"\"\" if root_dir is None : root_dir = get_config_value ( \"runtime\" , \"session_dir\" , default = \"./data/sessions\" ) self . root_dir = os . path . abspath ( root_dir ) os . makedirs ( self . root_dir , exist_ok = True ) append_event ( session_id : str , event : Event ) -> None Append a single event record to the session transcript. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 85 86 87 88 89 90 91 def append_event ( self , session_id : str , event : Event ) -> None : \"\"\"Append a single event record to the session transcript.\"\"\" paths = self . _paths ( session_id ) os . makedirs ( paths . session_dir , exist_ok = True ) payload : EventRecord = { \"ts\" : _utc_now (), ** event } with open ( paths . transcript_path , \"a\" , encoding = \"utf-8\" ) as handle : handle . write ( json . dumps ( payload ) + \" \\n \" ) archive_session ( session_id : str ) -> None Mark a session as archived. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 177 178 179 180 181 182 def archive_session ( self , session_id : str ) -> None : \"\"\"Mark a session as archived.\"\"\" index = self . _load_index () archived = index . setdefault ( \"archived\" , {}) archived [ session_id ] = _utc_now () self . _save_index ( index ) create_session () -> str Create a new session directory and return its identifier. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 74 75 76 77 78 79 def create_session ( self ) -> str : \"\"\"Create a new session directory and return its identifier.\"\"\" session_id = uuid . uuid4 () . hex paths = self . _paths ( session_id ) os . makedirs ( paths . session_dir , exist_ok = True ) return session_id fork_session ( source_session_id : str ) -> str Create a new session by copying events and summary from another. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 150 151 152 153 154 155 156 157 158 159 def fork_session ( self , source_session_id : str ) -> str : \"\"\"Create a new session by copying events and summary from another.\"\"\" events = self . load_transcript ( source_session_id ) summary = self . load_summary ( source_session_id ) new_session_id = self . create_session () for event in events : self . append_event ( new_session_id , event ) if summary : self . save_summary ( new_session_id , summary ) return new_session_id is_archived ( session_id : str ) -> bool Return True if a session is archived. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 193 194 195 196 197 def is_archived ( self , session_id : str ) -> bool : \"\"\"Return True if a session is archived.\"\"\" index = self . _load_index () archived = index . get ( \"archived\" , {}) return session_id in archived list_sessions () -> list [ str ] List all session IDs present in the root directory. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 140 141 142 143 144 145 146 147 148 def list_sessions ( self ) -> list [ str ]: \"\"\"List all session IDs present in the root directory.\"\"\" if not os . path . exists ( self . root_dir ): return [] return sorted ( name for name in os . listdir ( self . root_dir ) if os . path . isdir ( os . path . join ( self . root_dir , name )) ) list_tags () -> dict [ str , str ] Return a mapping of tags to session IDs. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 172 173 174 175 def list_tags ( self ) -> dict [ str , str ]: \"\"\"Return a mapping of tags to session IDs.\"\"\" index = self . _load_index () return dict ( index . get ( \"tags\" , {})) load_recent_events ( session_id : str , limit : int = 8 , include_types : set [ str ] | None = None ) -> list [ EventRecord ] Load the most recent events, optionally filtered by type. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 110 111 112 113 114 115 116 117 118 119 120 121 122 def load_recent_events ( self , session_id : str , limit : int = 8 , include_types : set [ str ] | None = None , ) -> list [ EventRecord ]: \"\"\"Load the most recent events, optionally filtered by type.\"\"\" events = self . load_transcript ( session_id ) if include_types : events = [ event for event in events if event . get ( \"type\" ) in include_types ] if limit <= 0 : return [] return events [ - limit :] load_summary ( session_id : str ) -> str | None Load a previously saved summary, if present. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 131 132 133 134 135 136 137 138 def load_summary ( self , session_id : str ) -> str | None : \"\"\"Load a previously saved summary, if present.\"\"\" paths = self . _paths ( session_id ) if not os . path . exists ( paths . summary_path ): return None with open ( paths . summary_path , encoding = \"utf-8\" ) as handle : data = json . load ( handle ) return data . get ( \"summary\" ) load_transcript ( session_id : str ) -> list [ EventRecord ] Load all transcript events for a session. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 def load_transcript ( self , session_id : str ) -> list [ EventRecord ]: \"\"\"Load all transcript events for a session.\"\"\" paths = self . _paths ( session_id ) if not os . path . exists ( paths . transcript_path ): return [] events : list [ EventRecord ] = [] with open ( paths . transcript_path , encoding = \"utf-8\" ) as handle : for line in handle : line = line . strip () if not line : continue try : events . append ( json . loads ( line )) except json . JSONDecodeError : logging . warning ( \"Skipping malformed transcript line.\" ) return events resolve_tag ( tag : str ) -> str | None Resolve a tag to a session ID, if present. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 167 168 169 170 def resolve_tag ( self , tag : str ) -> str | None : \"\"\"Resolve a tag to a session ID, if present.\"\"\" index = self . _load_index () return index . get ( \"tags\" , {}) . get ( tag ) save_summary ( session_id : str , summary : str ) -> None Persist a summary for a session. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 124 125 126 127 128 129 def save_summary ( self , session_id : str , summary : str ) -> None : \"\"\"Persist a summary for a session.\"\"\" paths = self . _paths ( session_id ) os . makedirs ( paths . session_dir , exist_ok = True ) with open ( paths . summary_path , \"w\" , encoding = \"utf-8\" ) as handle : json . dump ({ \"summary\" : summary , \"updated_at\" : _utc_now ()}, handle , indent = 2 ) tag_session ( session_id : str , tag : str ) -> None Associate a tag with a session ID for quick lookup. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 161 162 163 164 165 def tag_session ( self , session_id : str , tag : str ) -> None : \"\"\"Associate a tag with a session ID for quick lookup.\"\"\" index = self . _load_index () index . setdefault ( \"tags\" , {})[ tag ] = session_id self . _save_index ( index ) unarchive_session ( session_id : str ) -> None Remove archived status from a session. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 184 185 186 187 188 189 190 191 def unarchive_session ( self , session_id : str ) -> None : \"\"\"Remove archived status from a session.\"\"\" index = self . _load_index () archived = index . get ( \"archived\" , {}) if session_id in archived : archived . pop ( session_id , None ) index [ \"archived\" ] = archived self . _save_index ( index ) meeseeks_core.context Context selection and rendering helpers. ContextBuilder Build short-term and selected context for a session. Source code in packages/meeseeks_core/src/meeseeks_core/context.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 class ContextBuilder : \"\"\"Build short-term and selected context for a session.\"\"\" def __init__ ( self , session_store : SessionStore ) -> None : \"\"\"Initialize the context builder.\"\"\" self . _session_store = session_store def build ( self , session_id : str , user_query : str , model_name : str | None , ) -> ContextSnapshot : \"\"\"Build a context snapshot for planning and synthesis.\"\"\" events = self . _session_store . load_transcript ( session_id ) summary = self . _session_store . load_summary ( session_id ) context_events = [ event for event in events if event . get ( \"type\" ) in { \"user\" , \"assistant\" , \"tool_result\" , \"step_reflection\" , } ] recent_limit = int ( get_config_value ( \"context\" , \"recent_event_limit\" , default = 8 )) recent_events = context_events [ - recent_limit :] if recent_limit > 0 else [] candidate_events = context_events [: - recent_limit ] if recent_limit > 0 else context_events budget = get_token_budget ( events , summary , model_name ) selected_events : list [ EventRecord ] | None = None selection_threshold = float ( get_config_value ( \"context\" , \"selection_threshold\" , default = 0.8 )) if ( bool ( get_config_value ( \"context\" , \"selection_enabled\" , default = True )) and candidate_events and budget . utilization >= selection_threshold ): selected_events = self . _select_context_events ( candidate_events , user_query = user_query , model_name = model_name , ) return ContextSnapshot ( summary = summary , recent_events = recent_events , selected_events = selected_events , events = events , budget = budget , ) def _select_context_events ( self , events : list [ EventRecord ], user_query : str , model_name : str | None , ) -> list [ EventRecord ]: if not events : return [] selector_model = ( get_config_value ( \"context\" , \"context_selector_model\" ) or model_name or get_config_value ( \"llm\" , \"action_plan_model\" ) or get_config_value ( \"llm\" , \"default_model\" ) ) if not selector_model : return events parser = PydanticOutputParser ( pydantic_object = ContextSelection ) # type: ignore[type-var] prompt = ChatPromptTemplate ( messages = [ SystemMessage ( content = ( \"You select which prior events are still relevant to the user's \" \"current request. Keep only events that directly help answer the \" \"current query. If unsure, keep the event.\" ) ), HumanMessagePromptTemplate . from_template ( \"User query: \\n {user_query} \\n\\n \" \"Candidate events: \\n {candidates} \\n\\n \" \"Return keep_ids and drop_ids. \\n {format_instructions} \" ), ], partial_variables = { \"format_instructions\" : parser . get_format_instructions ()}, input_variables = [ \"user_query\" , \"candidates\" ], ) lines : list [ str ] = [] for idx , event in enumerate ( events , start = 1 ): text = event_payload_text ( event ) if not text : continue lines . append ( f \" { idx } . { event . get ( 'type' , 'event' ) } : { text } \" ) candidates_text = \" \\n \" . join ( lines ) . strip () if not candidates_text : return events model = build_chat_model ( model_name = selector_model , openai_api_base = get_config_value ( \"llm\" , \"api_base\" ), api_key = get_config_value ( \"llm\" , \"api_key\" ), ) handler = build_langfuse_handler ( user_id = \"meeseeks-context\" , session_id = f \"context- { os . getpid () } - { os . urandom ( 4 ) . hex () } \" , trace_name = \"meeseeks-context\" , version = get_config_value ( \"runtime\" , \"version\" , default = \"Not Specified\" ), release = get_config_value ( \"runtime\" , \"envmode\" , default = \"Not Specified\" ), ) config : dict [ str , object ] = {} if handler is not None : config [ \"callbacks\" ] = [ handler ] metadata = getattr ( handler , \"langfuse_metadata\" , None ) if isinstance ( metadata , dict ) and metadata : config [ \"metadata\" ] = metadata try : with langfuse_trace_span ( \"context-select\" ) as span : if span is not None : try : span . update_trace ( input = { \"user_query\" : user_query . strip (), \"candidate_count\" : len ( lines ), } ) except Exception : pass selection = ( prompt | model | parser ) . invoke ( { \"user_query\" : user_query . strip (), \"candidates\" : candidates_text }, config = config or None , ) if span is not None : try : span . update_trace ( output = { \"keep_ids\" : selection . keep_ids , \"drop_ids\" : selection . drop_ids , } ) except Exception : pass except Exception as exc : # pragma: no cover - defensive logging . warning ( \"Context selection failed: {} \" , exc ) return events [ - 3 :] keep_ids = set ( selection . keep_ids or []) if not keep_ids : return events [ - 3 :] kept : list [ EventRecord ] = [] for idx , event in enumerate ( events , start = 1 ): if idx in keep_ids : kept . append ( event ) return kept or events [ - 3 :] __init__ ( session_store : SessionStore ) -> None Initialize the context builder. Source code in packages/meeseeks_core/src/meeseeks_core/context.py 70 71 72 def __init__ ( self , session_store : SessionStore ) -> None : \"\"\"Initialize the context builder.\"\"\" self . _session_store = session_store build ( session_id : str , user_query : str , model_name : str | None ) -> ContextSnapshot Build a context snapshot for planning and synthesis. Source code in packages/meeseeks_core/src/meeseeks_core/context.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 def build ( self , session_id : str , user_query : str , model_name : str | None , ) -> ContextSnapshot : \"\"\"Build a context snapshot for planning and synthesis.\"\"\" events = self . _session_store . load_transcript ( session_id ) summary = self . _session_store . load_summary ( session_id ) context_events = [ event for event in events if event . get ( \"type\" ) in { \"user\" , \"assistant\" , \"tool_result\" , \"step_reflection\" , } ] recent_limit = int ( get_config_value ( \"context\" , \"recent_event_limit\" , default = 8 )) recent_events = context_events [ - recent_limit :] if recent_limit > 0 else [] candidate_events = context_events [: - recent_limit ] if recent_limit > 0 else context_events budget = get_token_budget ( events , summary , model_name ) selected_events : list [ EventRecord ] | None = None selection_threshold = float ( get_config_value ( \"context\" , \"selection_threshold\" , default = 0.8 )) if ( bool ( get_config_value ( \"context\" , \"selection_enabled\" , default = True )) and candidate_events and budget . utilization >= selection_threshold ): selected_events = self . _select_context_events ( candidate_events , user_query = user_query , model_name = model_name , ) return ContextSnapshot ( summary = summary , recent_events = recent_events , selected_events = selected_events , events = events , budget = budget , ) ContextSelection Bases: BaseModel Model output for selecting context events. Source code in packages/meeseeks_core/src/meeseeks_core/context.py 25 26 27 28 29 class ContextSelection ( BaseModel ): \"\"\"Model output for selecting context events.\"\"\" keep_ids : list [ int ] = Field ( default_factory = list ) drop_ids : list [ int ] = Field ( default_factory = list ) ContextSnapshot dataclass Context snapshot for planning and synthesis. Source code in packages/meeseeks_core/src/meeseeks_core/context.py 32 33 34 35 36 37 38 39 40 @dataclass ( frozen = True ) class ContextSnapshot : \"\"\"Context snapshot for planning and synthesis.\"\"\" summary : str | None recent_events : list [ EventRecord ] selected_events : list [ EventRecord ] | None events : list [ EventRecord ] budget : TokenBudget event_payload_text ( event : EventRecord ) -> str Return a readable payload string for an event. Source code in packages/meeseeks_core/src/meeseeks_core/context.py 43 44 45 46 47 48 49 50 51 52 53 def event_payload_text ( event : EventRecord ) -> str : \"\"\"Return a readable payload string for an event.\"\"\" payload = event . get ( \"payload\" , \"\" ) if isinstance ( payload , dict ): if \"tool_input\" in payload : payload = dict ( payload ) payload [ \"tool_input\" ] = format_tool_input ( payload . get ( \"tool_input\" )) return str ( payload . get ( \"text\" ) or payload . get ( \"message\" ) or payload . get ( \"result\" ) or payload ) return str ( payload ) render_event_lines ( events : list [ EventRecord ]) -> str Render events into bullet lines for prompts. Source code in packages/meeseeks_core/src/meeseeks_core/context.py 56 57 58 59 60 61 62 63 64 def render_event_lines ( events : list [ EventRecord ]) -> str : \"\"\"Render events into bullet lines for prompts.\"\"\" lines : list [ str ] = [] for event in events : text = event_payload_text ( event ) if not text : continue lines . append ( f \"- { event . get ( 'type' , 'event' ) } : { text } \" ) return \" \\n \" . join ( lines ) . strip () meeseeks_core.compaction Transcript compaction utilities. should_compact ( events : Iterable [ EventRecord ], threshold : int = 50 ) -> bool Return True when the event list meets the compaction threshold. Parameters: Name Type Description Default events Iterable [ EventRecord ] Iterable of event records to count. required threshold int Minimum number of events that triggers compaction. 50 Returns: Type Description bool True when compaction should run. Source code in packages/meeseeks_core/src/meeseeks_core/compaction.py 40 41 42 43 44 45 46 47 48 49 50 def should_compact ( events : Iterable [ EventRecord ], threshold : int = 50 ) -> bool : \"\"\"Return True when the event list meets the compaction threshold. Args: events: Iterable of event records to count. threshold: Minimum number of events that triggers compaction. Returns: True when compaction should run. \"\"\" return len ( list ( events )) >= threshold summarize_events ( events : Iterable [ EventRecord ], max_items : int = 20 ) -> str Generate a lightweight summary of recent events. Parameters: Name Type Description Default events Iterable [ EventRecord ] Iterable of event records to summarize. required max_items int Maximum number of recent events to include. 20 Returns: Type Description str Concise summary string of recent events. Source code in packages/meeseeks_core/src/meeseeks_core/compaction.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def summarize_events ( events : Iterable [ EventRecord ], max_items : int = 20 ) -> str : \"\"\"Generate a lightweight summary of recent events. Args: events: Iterable of event records to summarize. max_items: Maximum number of recent events to include. Returns: Concise summary string of recent events. \"\"\" snippets : list [ str ] = [] for event in list ( events )[ - max_items :]: event_type = event . get ( \"type\" , \"event\" ) payload_value : object = event . get ( \"payload\" , \"\" ) if isinstance ( payload_value , dict ): payload_data = dict ( payload_value ) payload_value = ( payload_data . get ( \"text\" ) or payload_data . get ( \"message\" ) or str ( payload_data ) ) if payload_value : snippets . append ( f \" { event_type } : { payload_value } \" ) else : snippets . append ( f \" { event_type } .\" ) return \" | \" . join ( snippets ) . strip () meeseeks_core.token_budget Token budgeting utilities. TokenBudget dataclass Token accounting snapshot used to decide compaction. Source code in packages/meeseeks_core/src/meeseeks_core/token_budget.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @dataclass ( frozen = True ) class TokenBudget : \"\"\"Token accounting snapshot used to decide compaction.\"\"\" total_tokens : int summary_tokens : int event_tokens : int context_window : int remaining_tokens : int utilization : float threshold : float @property def needs_compact ( self ) -> bool : \"\"\"Return True when utilization exceeds the configured threshold.\"\"\" return self . utilization >= self . threshold needs_compact : bool property Return True when utilization exceeds the configured threshold. estimate_event_tokens ( events : Iterable [ EventRecord ]) -> int Estimate total tokens for a sequence of events. Source code in packages/meeseeks_core/src/meeseeks_core/token_budget.py 84 85 86 87 88 89 90 def estimate_event_tokens ( events : Iterable [ EventRecord ]) -> int : \"\"\"Estimate total tokens for a sequence of events.\"\"\" texts = [ _event_to_text ( event ) for event in events ] joined = \" \\n \" . join ( text for text in texts if text ) if not joined : return 0 return num_tokens_from_string ( joined ) estimate_summary_tokens ( summary : str | None ) -> int Estimate token usage for the stored summary. Source code in packages/meeseeks_core/src/meeseeks_core/token_budget.py 93 94 95 96 97 def estimate_summary_tokens ( summary : str | None ) -> int : \"\"\"Estimate token usage for the stored summary.\"\"\" if not summary : return 0 return num_tokens_from_string ( summary ) get_context_window ( model_name : str | None ) -> int Resolve the context window for a model name or default. Source code in packages/meeseeks_core/src/meeseeks_core/token_budget.py 58 59 60 61 62 63 64 65 66 67 68 69 def get_context_window ( model_name : str | None ) -> int : \"\"\"Resolve the context window for a model name or default.\"\"\" default_window = int ( get_config_value ( \"token_budget\" , \"default_context_window\" , default = 128000 )) if not model_name : return default_window overrides = _load_context_overrides () if model_name in overrides : return overrides [ model_name ] parsed = _parse_context_from_model ( model_name ) if parsed : return parsed return default_window get_token_budget ( events : Iterable [ EventRecord ], summary : str | None , model_name : str | None , threshold : float | None = None ) -> TokenBudget Calculate token utilization and remaining context budget. Source code in packages/meeseeks_core/src/meeseeks_core/token_budget.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 def get_token_budget ( events : Iterable [ EventRecord ], summary : str | None , model_name : str | None , threshold : float | None = None , ) -> TokenBudget : \"\"\"Calculate token utilization and remaining context budget.\"\"\" event_tokens = estimate_event_tokens ( events ) summary_tokens = estimate_summary_tokens ( summary ) total_tokens = event_tokens + summary_tokens context_window = get_context_window ( model_name ) remaining_tokens = max ( context_window - total_tokens , 0 ) if threshold is None : threshold = float ( get_config_value ( \"token_budget\" , \"auto_compact_threshold\" , default = 0.8 )) utilization = total_tokens / context_window if context_window else 0.0 return TokenBudget ( total_tokens = total_tokens , summary_tokens = summary_tokens , event_tokens = event_tokens , context_window = context_window , remaining_tokens = remaining_tokens , utilization = utilization , threshold = threshold , ) meeseeks_core.tool_registry Tool registry and manifest loading for Meeseeks. ToolRegistry Registry of configured tools and their instantiated runners. Source code in packages/meeseeks_core/src/meeseeks_core/tool_registry.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 class ToolRegistry : \"\"\"Registry of configured tools and their instantiated runners.\"\"\" def __init__ ( self ) -> None : \"\"\"Initialize an empty registry.\"\"\" self . _tools : dict [ str , ToolSpec ] = {} self . _instances : dict [ str , ToolRunner ] = {} def disable ( self , tool_id : str , reason : str ) -> None : \"\"\"Disable a tool and store a reason for later reporting.\"\"\" spec = self . _tools . get ( tool_id ) if spec is None : return metadata = dict ( spec . metadata ) metadata [ \"disabled_reason\" ] = reason self . _tools [ tool_id ] = ToolSpec ( tool_id = spec . tool_id , name = spec . name , description = spec . description , factory = spec . factory , enabled = False , kind = spec . kind , prompt_path = spec . prompt_path , metadata = metadata , ) if tool_id in self . _instances : self . _instances . pop ( tool_id , None ) set_available_tools ( [ current_id for current_id , current_spec in self . _tools . items () if current_spec . enabled ] ) def register ( self , spec : ToolSpec ) -> None : \"\"\"Register a tool specification and update action validation.\"\"\" self . _tools [ spec . tool_id ] = spec set_available_tools ( [ tool_id for tool_id , tool_spec in self . _tools . items () if tool_spec . enabled ] ) def get ( self , tool_id : str ) -> ToolRunner | None : \"\"\"Return an enabled tool runner, instantiating it if needed.\"\"\" spec = self . _tools . get ( tool_id ) if spec is None or not spec . enabled : return None if tool_id not in self . _instances : try : self . _instances [ tool_id ] = spec . factory () except Exception as exc : # pragma: no cover - defensive reason = f \"Initialization failed: { exc } \" logging . warning ( \"Disabling tool {} : {} \" , tool_id , reason ) self . disable ( tool_id , reason ) return None return self . _instances [ tool_id ] def get_spec ( self , tool_id : str ) -> ToolSpec | None : \"\"\"Return the tool specification, even if disabled.\"\"\" return self . _tools . get ( tool_id ) def list_specs ( self , include_disabled : bool = False ) -> list [ ToolSpec ]: \"\"\"List tool specifications, optionally including disabled tools.\"\"\" specs = list ( self . _tools . values ()) if include_disabled : return specs return [ spec for spec in specs if spec . enabled ] def list_specs_for_mode ( self , mode : str , * , include_disabled : bool = False ) -> list [ ToolSpec ]: \"\"\"List specs filtered by orchestration mode.\"\"\" specs = self . list_specs ( include_disabled = include_disabled ) if mode != \"plan\" : return specs return [ spec for spec in specs if spec . is_plan_safe ()] def tool_catalog ( self ) -> list [ dict [ str , str ]]: \"\"\"Return a serialized catalog of registered tool metadata.\"\"\" return [ { \"tool_id\" : spec . tool_id , \"name\" : spec . name , \"description\" : spec . description , } for spec in self . list_specs () ] __init__ () -> None Initialize an empty registry. Source code in packages/meeseeks_core/src/meeseeks_core/tool_registry.py 65 66 67 68 def __init__ ( self ) -> None : \"\"\"Initialize an empty registry.\"\"\" self . _tools : dict [ str , ToolSpec ] = {} self . _instances : dict [ str , ToolRunner ] = {} disable ( tool_id : str , reason : str ) -> None Disable a tool and store a reason for later reporting. Source code in packages/meeseeks_core/src/meeseeks_core/tool_registry.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 def disable ( self , tool_id : str , reason : str ) -> None : \"\"\"Disable a tool and store a reason for later reporting.\"\"\" spec = self . _tools . get ( tool_id ) if spec is None : return metadata = dict ( spec . metadata ) metadata [ \"disabled_reason\" ] = reason self . _tools [ tool_id ] = ToolSpec ( tool_id = spec . tool_id , name = spec . name , description = spec . description , factory = spec . factory , enabled = False , kind = spec . kind , prompt_path = spec . prompt_path , metadata = metadata , ) if tool_id in self . _instances : self . _instances . pop ( tool_id , None ) set_available_tools ( [ current_id for current_id , current_spec in self . _tools . items () if current_spec . enabled ] ) get ( tool_id : str ) -> ToolRunner | None Return an enabled tool runner, instantiating it if needed. Source code in packages/meeseeks_core/src/meeseeks_core/tool_registry.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 def get ( self , tool_id : str ) -> ToolRunner | None : \"\"\"Return an enabled tool runner, instantiating it if needed.\"\"\" spec = self . _tools . get ( tool_id ) if spec is None or not spec . enabled : return None if tool_id not in self . _instances : try : self . _instances [ tool_id ] = spec . factory () except Exception as exc : # pragma: no cover - defensive reason = f \"Initialization failed: { exc } \" logging . warning ( \"Disabling tool {} : {} \" , tool_id , reason ) self . disable ( tool_id , reason ) return None return self . _instances [ tool_id ] get_spec ( tool_id : str ) -> ToolSpec | None Return the tool specification, even if disabled. Source code in packages/meeseeks_core/src/meeseeks_core/tool_registry.py 115 116 117 def get_spec ( self , tool_id : str ) -> ToolSpec | None : \"\"\"Return the tool specification, even if disabled.\"\"\" return self . _tools . get ( tool_id ) list_specs ( include_disabled : bool = False ) -> list [ ToolSpec ] List tool specifications, optionally including disabled tools. Source code in packages/meeseeks_core/src/meeseeks_core/tool_registry.py 119 120 121 122 123 124 def list_specs ( self , include_disabled : bool = False ) -> list [ ToolSpec ]: \"\"\"List tool specifications, optionally including disabled tools.\"\"\" specs = list ( self . _tools . values ()) if include_disabled : return specs return [ spec for spec in specs if spec . enabled ] list_specs_for_mode ( mode : str , * , include_disabled : bool = False ) -> list [ ToolSpec ] List specs filtered by orchestration mode. Source code in packages/meeseeks_core/src/meeseeks_core/tool_registry.py 126 127 128 129 130 131 def list_specs_for_mode ( self , mode : str , * , include_disabled : bool = False ) -> list [ ToolSpec ]: \"\"\"List specs filtered by orchestration mode.\"\"\" specs = self . list_specs ( include_disabled = include_disabled ) if mode != \"plan\" : return specs return [ spec for spec in specs if spec . is_plan_safe ()] register ( spec : ToolSpec ) -> None Register a tool specification and update action validation. Source code in packages/meeseeks_core/src/meeseeks_core/tool_registry.py 93 94 95 96 97 98 def register ( self , spec : ToolSpec ) -> None : \"\"\"Register a tool specification and update action validation.\"\"\" self . _tools [ spec . tool_id ] = spec set_available_tools ( [ tool_id for tool_id , tool_spec in self . _tools . items () if tool_spec . enabled ] ) tool_catalog () -> list [ dict [ str , str ]] Return a serialized catalog of registered tool metadata. Source code in packages/meeseeks_core/src/meeseeks_core/tool_registry.py 133 134 135 136 137 138 139 140 141 142 def tool_catalog ( self ) -> list [ dict [ str , str ]]: \"\"\"Return a serialized catalog of registered tool metadata.\"\"\" return [ { \"tool_id\" : spec . tool_id , \"name\" : spec . name , \"description\" : spec . description , } for spec in self . list_specs () ] ToolRunner Bases: Protocol Source code in packages/meeseeks_core/src/meeseeks_core/tool_registry.py 32 33 34 35 36 37 38 39 40 41 class ToolRunner ( Protocol ): def run ( self , action_step : ActionStep ) -> MockSpeaker : # pragma: no cover \"\"\"Execute an action step and return a speaker response. Args: action_step: Action step payload to execute. Returns: MockSpeaker response from the tool. \"\"\" run ( action_step : ActionStep ) -> MockSpeaker Execute an action step and return a speaker response. Parameters: Name Type Description Default action_step ActionStep Action step payload to execute. required Returns: Type Description MockSpeaker MockSpeaker response from the tool. Source code in packages/meeseeks_core/src/meeseeks_core/tool_registry.py 33 34 35 36 37 38 39 40 41 def run ( self , action_step : ActionStep ) -> MockSpeaker : # pragma: no cover \"\"\"Execute an action step and return a speaker response. Args: action_step: Action step payload to execute. Returns: MockSpeaker response from the tool. \"\"\" ToolSpec dataclass Metadata describing a tool available to the assistant. Source code in packages/meeseeks_core/src/meeseeks_core/tool_registry.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 @dataclass ( frozen = True ) class ToolSpec : \"\"\"Metadata describing a tool available to the assistant.\"\"\" tool_id : str name : str description : str factory : Callable [[], ToolRunner ] enabled : bool = True kind : str = \"local\" prompt_path : str | None = None metadata : dict [ str , JsonValue ] = field ( default_factory = dict ) def is_plan_safe ( self ) -> bool : \"\"\"Return True if the tool is safe to use in plan mode.\"\"\" return bool ( self . metadata . get ( \"plan_safe\" )) is_plan_safe () -> bool Return True if the tool is safe to use in plan mode. Source code in packages/meeseeks_core/src/meeseeks_core/tool_registry.py 57 58 59 def is_plan_safe ( self ) -> bool : \"\"\"Return True if the tool is safe to use in plan mode.\"\"\" return bool ( self . metadata . get ( \"plan_safe\" )) load_registry ( manifest_path : str | None = None ) -> ToolRegistry Load tool registry, auto-discovering MCP tools when configured. Source code in packages/meeseeks_core/src/meeseeks_core/tool_registry.py 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 def load_registry ( manifest_path : str | None = None ) -> ToolRegistry : \"\"\"Load tool registry, auto-discovering MCP tools when configured.\"\"\" if manifest_path is None : mcp_config_path = get_mcp_config_path () if mcp_config_path and os . path . exists ( mcp_config_path ): manifest_path = _ensure_auto_manifest ( mcp_config_path ) if not manifest_path : return _default_registry () manifest_path = os . path . abspath ( manifest_path ) if not os . path . exists ( manifest_path ): logging . warning ( \"Tool manifest not found: {} \" , manifest_path ) return _default_registry () try : with open ( manifest_path , encoding = \"utf-8\" ) as handle : manifest = json . load ( handle ) except Exception as exc : # pragma: no cover - defensive logging . error ( \"Failed to load tool manifest: {} \" , exc ) return _default_registry () registry = ToolRegistry () for tool in manifest . get ( \"tools\" , []): kind = tool . get ( \"kind\" , \"local\" ) prompt_path = tool . get ( \"prompt\" ) if kind == \"local\" : module_path = tool . get ( \"module\" ) class_name = tool . get ( \"class\" ) if not module_path or not class_name : logging . warning ( \"Skipping tool with missing module/class: {} \" , tool ) continue factory = _import_factory ( module_path , class_name ) else : mcp_module = _load_mcp_support () if mcp_module is None : logging . warning ( \"Skipping MCP tool because MCP support is not installed: {} \" , tool , ) continue MCPToolRunner = mcp_module . MCPToolRunner server_name = tool . get ( \"server\" ) tool_name = tool . get ( \"tool\" ) if not server_name or not tool_name : logging . warning ( \"Skipping MCP tool with missing server/tool: {} \" , tool ) continue def _mcp_factory ( server_name : str = server_name , tool_name : str = tool_name , ) -> ToolRunner : return MCPToolRunner ( server_name = server_name , tool_name = tool_name ) factory = _mcp_factory spec = ToolSpec ( tool_id = tool . get ( \"tool_id\" , \"\" ), name = tool . get ( \"name\" , tool . get ( \"tool_id\" , \"\" )), description = tool . get ( \"description\" , \"\" ), factory = factory , enabled = tool . get ( \"enabled\" , True ), kind = kind , prompt_path = prompt_path , metadata = { key : value for key , value in tool . items () if key not in { \"tool_id\" , \"name\" , \"description\" , \"module\" , \"class\" , \"enabled\" , \"kind\" , \"prompt\" , } }, ) if not spec . tool_id : logging . warning ( \"Skipping tool with empty tool_id: {} \" , tool ) continue registry . register ( spec ) if not registry . list_specs ( include_disabled = True ): return _default_registry () builtin_registry = _default_registry () existing_ids = { spec . tool_id for spec in registry . list_specs ( include_disabled = True )} for spec in builtin_registry . list_specs ( include_disabled = True ): if spec . tool_id in existing_ids : continue registry . register ( spec ) existing_ids . add ( spec . tool_id ) set_available_tools ([ spec . tool_id for spec in registry . list_specs ()]) return registry meeseeks_core.classes Core data models and tool abstractions for Meeseeks orchestration. AbstractTool Bases: ABC Base tool with shared initialization helpers. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 class AbstractTool ( abc . ABC ): \"\"\"Base tool with shared initialization helpers.\"\"\" def __init__ ( self , name : str , description : str , model_name : str | None = None , use_llm : bool = True , ) -> None : \"\"\"Initialize tool configuration.\"\"\" tool_model = get_config_value ( \"llm\" , \"tool_model\" ) default_model = get_config_value ( \"llm\" , \"default_model\" , default = \"gpt-5.2\" ) self . model_name = cast ( str , model_name or tool_model or default_model , ) self . name = name self . description = description self . use_llm = use_llm self . _id = f \" { name . lower () . replace ( ' ' , '_' ) } _tool\" session_id = f \" { self . _id } -tool-id- { get_unique_timestamp () } \" logging . info ( f \"Tool created <name= { name } ; session_id= { session_id } ;>\" ) self . langfuse_handler = build_langfuse_handler ( user_id = f \"meeseeks- { name } \" , session_id = session_id , trace_name = f \"meeseeks- { self . _id } \" , version = get_config_value ( \"runtime\" , \"version\" , default = \"Not Specified\" ), release = get_config_value ( \"runtime\" , \"envmode\" , default = \"Not Specified\" ), ) self . model = None if self . use_llm : self . model = build_chat_model ( model_name = self . model_name , openai_api_base = get_config_value ( \"llm\" , \"api_base\" ), api_key = get_config_value ( \"llm\" , \"api_key\" ), ) root_cache_dir = get_config_value ( \"runtime\" , \"cache_dir\" , default = \".cache\" ) if not root_cache_dir : raise ValueError ( \"runtime.cache_dir is not set.\" ) self . cache_dir = os . path . abspath ( os . path . join ( str ( root_cache_dir ), self . _id )) logging . debug ( \" {} cache directory is {} .\" , self . _id , self . cache_dir ) def _save_json ( self , data : object , filename : str ) -> None : \"\"\"Persist JSON data under the cache directory.\"\"\" if not os . path . exists ( self . cache_dir ): os . makedirs ( self . cache_dir ) filename = os . path . join ( self . cache_dir , filename ) with open ( filename , \"w\" , encoding = \"utf-8\" ) as f : json . dump ( data , f , indent = 4 ) logging . info ( f \"Data saved to { filename } .\" ) def _load_rag_json ( self , filename : str ) -> list [ Document ]: \"\"\"Load JSON content as documents.\"\"\" logging . debug ( \"RAG directory is {} .\" , self . cache_dir ) logging . info ( f \"Loading ` { filename } ` as JSON.\" ) filename = os . path . join ( self . cache_dir , filename ) filename = os . path . abspath ( filename ) loader = JSONLoader ( file_path = filename , jq_schema = \".\" , text_content = False ) data = loader . load () return data def _load_rag_documents ( self , filenames : list [ str ]) -> list [ Document ]: \"\"\"Load and concatenate multiple JSON files.\"\"\" rag_documents : list [ Document ] = [] for rag_file in filenames : data = self . _load_rag_json ( rag_file ) rag_documents . extend ( data ) return rag_documents def set_state ( self , action_step : ActionStep | None = None ) -> MockSpeaker : \"\"\"Perform a state-changing action.\"\"\" MockSpeaker = get_mock_speaker () return MockSpeaker ( content = \"Not implemented yet.\" ) def get_state ( self , action_step : ActionStep | None = None ) -> MockSpeaker : \"\"\"Perform a read-only action.\"\"\" MockSpeaker = get_mock_speaker () return MockSpeaker ( content = \"Not implemented yet.\" ) def run ( self , action_step : ActionStep ) -> MockSpeaker : \"\"\"Execute the action based on the operation.\"\"\" if action_step . operation == \"set\" : return self . set_state ( action_step ) if action_step . operation == \"get\" : return self . get_state ( action_step ) raise ValueError ( f \"Invalid operation: { action_step . operation } \" ) __init__ ( name : str , description : str , model_name : str | None = None , use_llm : bool = True ) -> None Initialize tool configuration. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 def __init__ ( self , name : str , description : str , model_name : str | None = None , use_llm : bool = True , ) -> None : \"\"\"Initialize tool configuration.\"\"\" tool_model = get_config_value ( \"llm\" , \"tool_model\" ) default_model = get_config_value ( \"llm\" , \"default_model\" , default = \"gpt-5.2\" ) self . model_name = cast ( str , model_name or tool_model or default_model , ) self . name = name self . description = description self . use_llm = use_llm self . _id = f \" { name . lower () . replace ( ' ' , '_' ) } _tool\" session_id = f \" { self . _id } -tool-id- { get_unique_timestamp () } \" logging . info ( f \"Tool created <name= { name } ; session_id= { session_id } ;>\" ) self . langfuse_handler = build_langfuse_handler ( user_id = f \"meeseeks- { name } \" , session_id = session_id , trace_name = f \"meeseeks- { self . _id } \" , version = get_config_value ( \"runtime\" , \"version\" , default = \"Not Specified\" ), release = get_config_value ( \"runtime\" , \"envmode\" , default = \"Not Specified\" ), ) self . model = None if self . use_llm : self . model = build_chat_model ( model_name = self . model_name , openai_api_base = get_config_value ( \"llm\" , \"api_base\" ), api_key = get_config_value ( \"llm\" , \"api_key\" ), ) root_cache_dir = get_config_value ( \"runtime\" , \"cache_dir\" , default = \".cache\" ) if not root_cache_dir : raise ValueError ( \"runtime.cache_dir is not set.\" ) self . cache_dir = os . path . abspath ( os . path . join ( str ( root_cache_dir ), self . _id )) logging . debug ( \" {} cache directory is {} .\" , self . _id , self . cache_dir ) get_state ( action_step : ActionStep | None = None ) -> MockSpeaker Perform a read-only action. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 231 232 233 234 def get_state ( self , action_step : ActionStep | None = None ) -> MockSpeaker : \"\"\"Perform a read-only action.\"\"\" MockSpeaker = get_mock_speaker () return MockSpeaker ( content = \"Not implemented yet.\" ) run ( action_step : ActionStep ) -> MockSpeaker Execute the action based on the operation. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 236 237 238 239 240 241 242 def run ( self , action_step : ActionStep ) -> MockSpeaker : \"\"\"Execute the action based on the operation.\"\"\" if action_step . operation == \"set\" : return self . set_state ( action_step ) if action_step . operation == \"get\" : return self . get_state ( action_step ) raise ValueError ( f \"Invalid operation: { action_step . operation } \" ) set_state ( action_step : ActionStep | None = None ) -> MockSpeaker Perform a state-changing action. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 226 227 228 229 def set_state ( self , action_step : ActionStep | None = None ) -> MockSpeaker : \"\"\"Perform a state-changing action.\"\"\" MockSpeaker = get_mock_speaker () return MockSpeaker ( content = \"Not implemented yet.\" ) ActionStep Bases: BaseModel Action step with validation metadata. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 class ActionStep ( BaseModel ): \"\"\"Action step with validation metadata.\"\"\" title : str | None = Field ( default = None , description = \"Short header summarizing the task for this step.\" , ) objective : str | None = Field ( default = None , description = \"Brief objective explaining why this step is needed.\" , ) execution_checklist : list [ str ] = Field ( default_factory = list , description = \"Short checklist of execution details for this step.\" , ) expected_output : str | None = Field ( default = None , description = \"Optional description of what success looks like.\" , ) tool_id : str = Field ( description = ( \"Specify the tool_id that should execute the action. \" \"Use only tool IDs listed under Available tools.\" ) ) operation : str = Field ( description = \"Specify the execution type (get/set or execute).\" ) tool_input : ToolInput = Field ( description = ( \"Provide details for the action. If 'task', specify the task to perform. \" \"If 'talk', include the message to speak to the user.\" ) ) result : object | None = Field ( alias = \"_result\" , default = None , description = \"Private field to persist the action status and other data.\" , ) class Config : \"\"\"Allow both alias and field-name population.\"\"\" allow_population_by_field_name = True extra = \"forbid\" Config Allow both alias and field-name population. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 70 71 72 73 74 class Config : \"\"\"Allow both alias and field-name population.\"\"\" allow_population_by_field_name = True extra = \"forbid\" OrchestrationState Bases: BaseModel State for the orchestration loop. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 143 144 145 146 147 148 149 150 151 152 153 class OrchestrationState ( BaseModel ): \"\"\"State for the orchestration loop.\"\"\" goal : str session_id : str | None = None plan : list [ PlanStep ] = Field ( default_factory = list ) tool_results : list [ str ] = Field ( default_factory = list ) open_questions : list [ str ] = Field ( default_factory = list ) done : bool = False done_reason : str | None = None summary : str | None = None Plan Bases: BaseModel Plan with human-readable steps. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 84 85 86 87 88 89 90 91 92 class Plan ( BaseModel ): \"\"\"Plan with human-readable steps.\"\"\" human_message : str | None = Field ( alias = \"_human_message\" , default = None , description = \"Human message associated with the plan.\" , ) steps : list [ PlanStep ] = Field ( default_factory = list ) PlanStep Bases: BaseModel High-level plan step produced by the planner. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 77 78 79 80 81 class PlanStep ( BaseModel ): \"\"\"High-level plan step produced by the planner.\"\"\" title : str = Field ( description = \"Short title for the step.\" ) description : str = Field ( description = \"One-paragraph description of the step.\" ) TaskQueue Bases: BaseModel Queue of executed tool steps and results. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 class TaskQueue ( BaseModel ): \"\"\"Queue of executed tool steps and results.\"\"\" human_message : str | None = Field ( alias = \"_human_message\" , default = None , description = \"Human message associated with the task queue.\" , ) plan_steps : list [ PlanStep ] = Field ( default_factory = list ) action_steps : list [ ActionStep ] = Field ( default_factory = list ) task_result : str | None = Field ( alias = \"_task_result\" , default = None , description = \"Store the result for the entire task queue\" ) last_error : str | None = Field ( alias = \"_last_error\" , default = None , description = \"Short description of the most recent tool failure.\" , ) @validator ( \"action_steps\" , allow_reuse = True ) # pylint: disable=E0213,W0613 def validate_actions ( cls , field : list [ ActionStep ]) -> list [ ActionStep ]: \"\"\"Normalize and validate action steps.\"\"\" for action in field : action . tool_id = action . tool_id . lower () action . operation = action . operation . lower () error_msg_list = [] if action . tool_id not in AVAILABLE_TOOLS : error_msg_list . append ( f \"` { action . tool_id } ` is not a valid Assistant tool.\" ) if action . operation not in [ \"get\" , \"set\" , \"execute\" ]: error_msg = f \"` { action . operation } ` is not a valid operation.\" error_msg_list . append ( error_msg ) if action . tool_input is None : error_msg_list . append ( \"Tool input cannot be None.\" ) if error_msg_list : for msg in error_msg_list : logging . error ( msg ) return field validate_actions ( field : list [ ActionStep ]) -> list [ ActionStep ] Normalize and validate action steps. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 @validator ( \"action_steps\" , allow_reuse = True ) # pylint: disable=E0213,W0613 def validate_actions ( cls , field : list [ ActionStep ]) -> list [ ActionStep ]: \"\"\"Normalize and validate action steps.\"\"\" for action in field : action . tool_id = action . tool_id . lower () action . operation = action . operation . lower () error_msg_list = [] if action . tool_id not in AVAILABLE_TOOLS : error_msg_list . append ( f \"` { action . tool_id } ` is not a valid Assistant tool.\" ) if action . operation not in [ \"get\" , \"set\" , \"execute\" ]: error_msg = f \"` { action . operation } ` is not a valid operation.\" error_msg_list . append ( error_msg ) if action . tool_input is None : error_msg_list . append ( \"Tool input cannot be None.\" ) if error_msg_list : for msg in error_msg_list : logging . error ( msg ) return field create_plan ( step_data : list [ dict [ str , str ]] | None = None , is_example : bool = True ) -> Plan Create a Plan from serialized step data. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 260 261 262 263 264 265 266 267 268 269 270 271 def create_plan ( step_data : list [ dict [ str , str ]] | None = None , is_example : bool = True , ) -> Plan : \"\"\"Create a Plan from serialized step data.\"\"\" if step_data is None : raise ValueError ( \"Step data cannot be None.\" ) steps = [ PlanStep ( ** step ) for step in step_data ] plan = Plan ( steps = steps ) if is_example : del plan . human_message return plan create_task_queue ( action_data : list [ ActionStepPayload ] | None = None , is_example : bool = True ) -> TaskQueue Create a TaskQueue from serialized action data. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 245 246 247 248 249 250 251 252 253 254 255 256 257 def create_task_queue ( action_data : list [ ActionStepPayload ] | None = None , is_example : bool = True , ) -> TaskQueue : \"\"\"Create a TaskQueue from serialized action data.\"\"\" if action_data is None : raise ValueError ( \"Action data cannot be None.\" ) action_steps = [ ActionStep ( ** action ) for action in action_data ] task_queue = TaskQueue ( action_steps = action_steps ) if is_example : del task_queue . human_message return task_queue get_task_master_examples ( example_id : int = 0 , available_tools : Sequence [ str ] | None = None ) -> str Return serialized example plan data. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 def get_task_master_examples ( example_id : int = 0 , available_tools : Sequence [ str ] | None = None , ) -> str : \"\"\"Return serialized example plan data.\"\"\" if available_tools is None : available_tools = AVAILABLE_TOOLS include_home_assistant = \"home_assistant_tool\" in available_tools if include_home_assistant : examples : list [ list [ dict [ str , str ]]] = [ [ { \"title\" : \"Turn on strip lights\" , \"description\" : \"Use Home Assistant to switch on the strip lights.\" , }, { \"title\" : \"Turn on heater\" , \"description\" : \"Use Home Assistant to switch on the heater.\" , }, ], [ { \"title\" : \"Check weather\" , \"description\" : \"Use Home Assistant to retrieve today's weather details.\" , }, ], ] else : examples = [[], []] if example_id not in range ( 0 , len ( examples )): raise ValueError ( f \"Invalid example ID: { example_id } \" ) return create_plan ( step_data = examples [ example_id ], is_example = True ) . json () set_available_tools ( tool_ids : list [ str ]) -> None Update available tool IDs for validation. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 26 27 28 29 def set_available_tools ( tool_ids : list [ str ]) -> None : \"\"\"Update available tool IDs for validation.\"\"\" global AVAILABLE_TOOLS AVAILABLE_TOOLS = tool_ids meeseeks_core.types Shared type definitions for core components. ActionPlanPayload Bases: TypedDict Payload describing an action plan. Source code in packages/meeseeks_core/src/meeseeks_core/types.py 21 22 23 24 class ActionPlanPayload ( TypedDict ): \"\"\"Payload describing an action plan.\"\"\" steps : list [ PlanStepPayload ] ActionStepPayload Bases: TypedDict Serialized tool call data sent to/from execution. Source code in packages/meeseeks_core/src/meeseeks_core/types.py 27 28 29 30 31 32 33 34 35 36 class ActionStepPayload ( TypedDict ): \"\"\"Serialized tool call data sent to/from execution.\"\"\" tool_id : str operation : str tool_input : ToolInput title : NotRequired [ str ] objective : NotRequired [ str ] execution_checklist : NotRequired [ list [ str ]] expected_output : NotRequired [ str ] AssistantPayload Bases: TypedDict Payload describing an assistant response. Source code in packages/meeseeks_core/src/meeseeks_core/types.py 66 67 68 69 class AssistantPayload ( TypedDict ): \"\"\"Payload describing an assistant response.\"\"\" text : str CompletionPayload Bases: TypedDict Payload describing overall completion state. Source code in packages/meeseeks_core/src/meeseeks_core/types.py 72 73 74 75 76 77 78 79 class CompletionPayload ( TypedDict ): \"\"\"Payload describing overall completion state.\"\"\" done : bool done_reason : str | None task_result : str | None error : NotRequired [ str ] last_error : NotRequired [ str ] Event Bases: TypedDict Base event payload stored in transcripts. Source code in packages/meeseeks_core/src/meeseeks_core/types.py 93 94 95 96 97 class Event ( TypedDict ): \"\"\"Base event payload stored in transcripts.\"\"\" type : str payload : EventPayload EventRecord Bases: Event Event payload with a persisted timestamp. Source code in packages/meeseeks_core/src/meeseeks_core/types.py 100 101 102 103 class EventRecord ( Event ): \"\"\"Event payload with a persisted timestamp.\"\"\" ts : str PermissionPayload Bases: TypedDict Payload emitted for permission decisions. Source code in packages/meeseeks_core/src/meeseeks_core/types.py 39 40 41 42 43 44 45 class PermissionPayload ( TypedDict ): \"\"\"Payload emitted for permission decisions.\"\"\" tool_id : str operation : str tool_input : str decision : str PlanStepPayload Bases: TypedDict Payload describing a single plan step. Source code in packages/meeseeks_core/src/meeseeks_core/types.py 14 15 16 17 18 class PlanStepPayload ( TypedDict ): \"\"\"Payload describing a single plan step.\"\"\" title : str description : str ToolResultPayload Bases: TypedDict Payload describing the outcome of a tool invocation. Source code in packages/meeseeks_core/src/meeseeks_core/types.py 48 49 50 51 52 53 54 55 56 57 class ToolResultPayload ( TypedDict ): \"\"\"Payload describing the outcome of a tool invocation.\"\"\" tool_id : str operation : str tool_input : ToolInput result : str | None success : NotRequired [ bool ] summary : NotRequired [ str ] error : NotRequired [ str ] UserPayload Bases: TypedDict Payload describing a user message. Source code in packages/meeseeks_core/src/meeseeks_core/types.py 60 61 62 63 class UserPayload ( TypedDict ): \"\"\"Payload describing a user message.\"\"\" text : str meeseeks_core.config Central JSON configuration for Meeseeks. AppConfig Bases: BaseModel Typed configuration for the Meeseeks runtime. Source code in packages/meeseeks_core/src/meeseeks_core/config.py 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 class AppConfig ( BaseModel ): \"\"\"Typed configuration for the Meeseeks runtime.\"\"\" runtime : RuntimeConfig = Field ( default_factory = _runtime_config_default ) llm : LLMConfig = Field ( default_factory = _llm_config_default ) context : ContextConfig = Field ( default_factory = _context_config_default ) token_budget : TokenBudgetConfig = Field ( default_factory = _token_budget_config_default ) reflection : ReflectionConfig = Field ( default_factory = _reflection_config_default ) langfuse : LangfuseConfig = Field ( default_factory = _langfuse_config_default ) home_assistant : HomeAssistantConfig = Field ( default_factory = _home_assistant_config_default ) permissions : PermissionsConfig = Field ( default_factory = _permissions_config_default ) cli : CLIConfig = Field ( default_factory = _cli_config_default ) chat : ChatConfig = Field ( default_factory = _chat_config_default ) api : APIConfig = Field ( default_factory = _api_config_default ) class Config : \"\"\"Pydantic configuration settings.\"\"\" extra = \"ignore\" @classmethod def load ( cls , path : str | Path ) -> AppConfig : \"\"\"Load configuration from a JSON file.\"\"\" payload = _load_json ( path ) return cls . parse_obj ( payload ) def to_json ( self , * , indent : int = 2 ) -> str : \"\"\"Serialize config to JSON.\"\"\" return self . json ( indent = indent , exclude_none = True ) def write ( self , path : str | Path , * , indent : int = 2 ) -> None : \"\"\"Write config JSON to disk.\"\"\" target = Path ( path ) target . parent . mkdir ( parents = True , exist_ok = True ) target . write_text ( self . to_json ( indent = indent ) + \" \\n \" , encoding = \"utf-8\" ) async def preflight ( self , * , disable_on_failure : bool = True ) -> dict [ str , dict [ str , Any ]]: \"\"\"Run async validation checks for optional integrations.\"\"\" results : dict [ str , ConfigCheck ] = {} async def _llm_check () -> ConfigCheck : return await asyncio . to_thread ( self . llm . validate_models ) async def _langfuse_check () -> ConfigCheck : enabled , reason , metadata = self . langfuse . evaluate () if not enabled : return ConfigCheck ( name = \"langfuse\" , enabled = False , ok = True , reason = reason , metadata = metadata , ) try : host = self . langfuse . host . rstrip ( \"/\" ) if host : await asyncio . to_thread ( _probe_http , f \" { host } /api/public/health\" ) return ConfigCheck ( name = \"langfuse\" , enabled = True , ok = True ) except ValueError as exc : return ConfigCheck ( name = \"langfuse\" , enabled = True , ok = False , reason = str ( exc )) async def _ha_check () -> ConfigCheck : enabled , reason , metadata = self . home_assistant . evaluate () if not enabled : return ConfigCheck ( name = \"home_assistant\" , enabled = False , ok = True , reason = reason , metadata = metadata , ) try : url = self . home_assistant . url . rstrip ( \"/\" ) headers = { \"Authorization\" : f \"Bearer { self . home_assistant . token } \" } await asyncio . to_thread ( _probe_http , f \" { url } /api/config\" , headers = headers ) return ConfigCheck ( name = \"home_assistant\" , enabled = True , ok = True ) except ValueError as exc : return ConfigCheck ( name = \"home_assistant\" , enabled = True , ok = False , reason = str ( exc )) async def _mcp_check () -> ConfigCheck : config_path = get_mcp_config_path () if not config_path : return ConfigCheck ( name = \"mcp\" , enabled = False , ok = True , reason = \"mcp config disabled\" ) try : from meeseeks_tools.integration import mcp as mcp_module config = mcp_module . _load_mcp_config ( config_path ) tools , failures = await asyncio . to_thread ( mcp_module . discover_mcp_tool_details_with_failures , config ) if failures : return ConfigCheck ( name = \"mcp\" , enabled = True , ok = False , reason = \"mcp discovery failed\" , metadata = { \"failures\" : { k : str ( v ) for k , v in failures . items ()}}, ) return ConfigCheck ( name = \"mcp\" , enabled = True , ok = True , metadata = { \"servers\" : list ( tools . keys ())}, ) except Exception as exc : return ConfigCheck ( name = \"mcp\" , enabled = True , ok = False , reason = str ( exc )) checks = await asyncio . gather ( _llm_check (), _langfuse_check (), _ha_check (), _mcp_check ()) for check in checks : results [ check . name ] = check if disable_on_failure : langfuse_check = results . get ( \"langfuse\" ) if langfuse_check and not langfuse_check . ok and self . langfuse . enabled : self . langfuse . enabled = False ha_check = results . get ( \"home_assistant\" ) if ha_check and not ha_check . ok and self . home_assistant . enabled : self . home_assistant . enabled = False return { name : check . to_dict () for name , check in results . items ()} Config Pydantic configuration settings. Source code in packages/meeseeks_core/src/meeseeks_core/config.py 416 417 418 419 class Config : \"\"\"Pydantic configuration settings.\"\"\" extra = \"ignore\" load ( path : str | Path ) -> AppConfig classmethod Load configuration from a JSON file. Source code in packages/meeseeks_core/src/meeseeks_core/config.py 421 422 423 424 425 @classmethod def load ( cls , path : str | Path ) -> AppConfig : \"\"\"Load configuration from a JSON file.\"\"\" payload = _load_json ( path ) return cls . parse_obj ( payload ) preflight ( * , disable_on_failure : bool = True ) -> dict [ str , dict [ str , Any ]] async Run async validation checks for optional integrations. Source code in packages/meeseeks_core/src/meeseeks_core/config.py 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 async def preflight ( self , * , disable_on_failure : bool = True ) -> dict [ str , dict [ str , Any ]]: \"\"\"Run async validation checks for optional integrations.\"\"\" results : dict [ str , ConfigCheck ] = {} async def _llm_check () -> ConfigCheck : return await asyncio . to_thread ( self . llm . validate_models ) async def _langfuse_check () -> ConfigCheck : enabled , reason , metadata = self . langfuse . evaluate () if not enabled : return ConfigCheck ( name = \"langfuse\" , enabled = False , ok = True , reason = reason , metadata = metadata , ) try : host = self . langfuse . host . rstrip ( \"/\" ) if host : await asyncio . to_thread ( _probe_http , f \" { host } /api/public/health\" ) return ConfigCheck ( name = \"langfuse\" , enabled = True , ok = True ) except ValueError as exc : return ConfigCheck ( name = \"langfuse\" , enabled = True , ok = False , reason = str ( exc )) async def _ha_check () -> ConfigCheck : enabled , reason , metadata = self . home_assistant . evaluate () if not enabled : return ConfigCheck ( name = \"home_assistant\" , enabled = False , ok = True , reason = reason , metadata = metadata , ) try : url = self . home_assistant . url . rstrip ( \"/\" ) headers = { \"Authorization\" : f \"Bearer { self . home_assistant . token } \" } await asyncio . to_thread ( _probe_http , f \" { url } /api/config\" , headers = headers ) return ConfigCheck ( name = \"home_assistant\" , enabled = True , ok = True ) except ValueError as exc : return ConfigCheck ( name = \"home_assistant\" , enabled = True , ok = False , reason = str ( exc )) async def _mcp_check () -> ConfigCheck : config_path = get_mcp_config_path () if not config_path : return ConfigCheck ( name = \"mcp\" , enabled = False , ok = True , reason = \"mcp config disabled\" ) try : from meeseeks_tools.integration import mcp as mcp_module config = mcp_module . _load_mcp_config ( config_path ) tools , failures = await asyncio . to_thread ( mcp_module . discover_mcp_tool_details_with_failures , config ) if failures : return ConfigCheck ( name = \"mcp\" , enabled = True , ok = False , reason = \"mcp discovery failed\" , metadata = { \"failures\" : { k : str ( v ) for k , v in failures . items ()}}, ) return ConfigCheck ( name = \"mcp\" , enabled = True , ok = True , metadata = { \"servers\" : list ( tools . keys ())}, ) except Exception as exc : return ConfigCheck ( name = \"mcp\" , enabled = True , ok = False , reason = str ( exc )) checks = await asyncio . gather ( _llm_check (), _langfuse_check (), _ha_check (), _mcp_check ()) for check in checks : results [ check . name ] = check if disable_on_failure : langfuse_check = results . get ( \"langfuse\" ) if langfuse_check and not langfuse_check . ok and self . langfuse . enabled : self . langfuse . enabled = False ha_check = results . get ( \"home_assistant\" ) if ha_check and not ha_check . ok and self . home_assistant . enabled : self . home_assistant . enabled = False return { name : check . to_dict () for name , check in results . items ()} to_json ( * , indent : int = 2 ) -> str Serialize config to JSON. Source code in packages/meeseeks_core/src/meeseeks_core/config.py 427 428 429 def to_json ( self , * , indent : int = 2 ) -> str : \"\"\"Serialize config to JSON.\"\"\" return self . json ( indent = indent , exclude_none = True ) write ( path : str | Path , * , indent : int = 2 ) -> None Write config JSON to disk. Source code in packages/meeseeks_core/src/meeseeks_core/config.py 431 432 433 434 435 def write ( self , path : str | Path , * , indent : int = 2 ) -> None : \"\"\"Write config JSON to disk.\"\"\" target = Path ( path ) target . parent . mkdir ( parents = True , exist_ok = True ) target . write_text ( self . to_json ( indent = indent ) + \" \\n \" , encoding = \"utf-8\" ) ConfigCheck dataclass Result of a configuration preflight check. Source code in packages/meeseeks_core/src/meeseeks_core/config.py 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 @dataclass class ConfigCheck : \"\"\"Result of a configuration preflight check.\"\"\" name : str enabled : bool ok : bool reason : str | None = None metadata : dict [ str , Any ] = field ( default_factory = dict ) def to_dict ( self ) -> dict [ str , Any ]: \"\"\"Serialize the check result to a dictionary.\"\"\" return { \"name\" : self . name , \"enabled\" : self . enabled , \"ok\" : self . ok , \"reason\" : self . reason , \"metadata\" : self . metadata , } to_dict () -> dict [ str , Any ] Serialize the check result to a dictionary. Source code in packages/meeseeks_core/src/meeseeks_core/config.py 576 577 578 579 580 581 582 583 584 def to_dict ( self ) -> dict [ str , Any ]: \"\"\"Serialize the check result to a dictionary.\"\"\" return { \"name\" : self . name , \"enabled\" : self . enabled , \"ok\" : self . ok , \"reason\" : self . reason , \"metadata\" : self . metadata , } ensure_app_config ( path : str | Path ) -> None Write the default config file if missing. Source code in packages/meeseeks_core/src/meeseeks_core/config.py 705 706 707 708 709 710 def ensure_app_config ( path : str | Path ) -> None : \"\"\"Write the default config file if missing.\"\"\" target = Path ( path ) if target . exists (): return AppConfig () . write ( target ) ensure_example_configs ( app_path : str | Path | None = None , mcp_path : str | Path | None = None ) -> None Write example config files if missing. Source code in packages/meeseeks_core/src/meeseeks_core/config.py 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 def ensure_example_configs ( app_path : str | Path | None = None , mcp_path : str | Path | None = None , ) -> None : \"\"\"Write example config files if missing.\"\"\" app_target = Path ( app_path ) if app_path else _APP_EXAMPLE_PATH if not app_target . exists (): app_target . parent . mkdir ( parents = True , exist_ok = True ) app_target . write_text ( json . dumps ( _example_app_payload (), indent = 2 ) + \" \\n \" , encoding = \"utf-8\" ) mcp_target = Path ( mcp_path ) if mcp_path else _MCP_EXAMPLE_PATH if not mcp_target . exists (): mcp_target . parent . mkdir ( parents = True , exist_ok = True ) mcp_target . write_text ( json . dumps ( { \"servers\" : { \"codex_tools\" : { \"transport\" : \"streamable_http\" , \"url\" : \"http://127.0.0.1:6783/mcp/Codex-Tools-Personal\" , \"headers\" : { \"Authorization\" : \"Bearer YOUR_MCP_TOKEN\" }, } } }, indent = 2 , ) + \" \\n \" , encoding = \"utf-8\" , ) get_app_config_path () -> str Return the configured app JSON path. Source code in packages/meeseeks_core/src/meeseeks_core/config.py 647 648 649 def get_app_config_path () -> str : \"\"\"Return the configured app JSON path.\"\"\" return str ( _APP_CONFIG_PATH_OVERRIDE or _APP_CONFIG_PATH ) get_config () -> AppConfig Return cached AppConfig instance. Source code in packages/meeseeks_core/src/meeseeks_core/config.py 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 def get_config () -> AppConfig : \"\"\"Return cached AppConfig instance.\"\"\" global _CONFIG_CACHE , _CONFIG_WARNED if _CONFIG_CACHE is not None : return _CONFIG_CACHE config_path = Path ( get_app_config_path ()) if not config_path . exists () and not _CONFIG_WARNED : _logger . warning ( \"Config file not found at %s . Run /config init to scaffold examples.\" , config_path , ) _CONFIG_WARNED = True base_payload = AppConfig () . dict () file_payload = _load_json ( get_app_config_path ()) merged = _deep_merge ( base_payload , file_payload ) if _APP_CONFIG_OVERRIDE : merged = _deep_merge ( merged , _APP_CONFIG_OVERRIDE ) _CONFIG_CACHE = AppConfig . parse_obj ( merged ) return _CONFIG_CACHE get_config_section ( * keys : str ) -> dict [ str , Any ] Return a config section as a dictionary. Source code in packages/meeseeks_core/src/meeseeks_core/config.py 695 696 697 698 699 700 701 702 def get_config_section ( * keys : str ) -> dict [ str , Any ]: \"\"\"Return a config section as a dictionary.\"\"\" value = get_config_value ( * keys , default = {}) if isinstance ( value , BaseModel ): return value . dict () if isinstance ( value , dict ): return value return {} get_config_value ( * keys : str , default : Any | None = None ) -> Any Return a nested config value or default. Source code in packages/meeseeks_core/src/meeseeks_core/config.py 680 681 682 683 684 685 686 687 688 689 690 691 692 def get_config_value ( * keys : str , default : Any | None = None ) -> Any : \"\"\"Return a nested config value or default.\"\"\" current : Any = get_config () for key in keys : if isinstance ( current , BaseModel ): current = getattr ( current , key , None ) elif isinstance ( current , dict ): current = current . get ( key ) else : return default if current is None : return default return current get_last_preflight () -> dict [ str , dict [ str , Any ]] | None Return the most recent preflight results if available. Source code in packages/meeseeks_core/src/meeseeks_core/config.py 561 562 563 def get_last_preflight () -> dict [ str , dict [ str , Any ]] | None : \"\"\"Return the most recent preflight results if available.\"\"\" return _LAST_PREFLIGHT get_mcp_config_path () -> str Return the configured MCP JSON path. Source code in packages/meeseeks_core/src/meeseeks_core/config.py 652 653 654 655 656 def get_mcp_config_path () -> str : \"\"\"Return the configured MCP JSON path.\"\"\" if _MCP_CONFIG_DISABLED : return \"\" return str ( _MCP_CONFIG_PATH_OVERRIDE or _MCP_CONFIG_PATH ) reset_config () -> None Clear cached configuration and overrides. Source code in packages/meeseeks_core/src/meeseeks_core/config.py 625 626 627 628 629 630 631 632 633 634 def reset_config () -> None : \"\"\"Clear cached configuration and overrides.\"\"\" global _CONFIG_CACHE , _APP_CONFIG_OVERRIDE , _APP_CONFIG_PATH_OVERRIDE , _MCP_CONFIG_PATH_OVERRIDE global _MCP_CONFIG_DISABLED , _CONFIG_WARNED _CONFIG_CACHE = None _APP_CONFIG_OVERRIDE = {} _APP_CONFIG_PATH_OVERRIDE = None _MCP_CONFIG_PATH_OVERRIDE = None _MCP_CONFIG_DISABLED = False _CONFIG_WARNED = False set_app_config_path ( path : str | Path ) -> None Override the app config path (tests only). Source code in packages/meeseeks_core/src/meeseeks_core/config.py 607 608 609 610 611 def set_app_config_path ( path : str | Path ) -> None : \"\"\"Override the app config path (tests only).\"\"\" global _APP_CONFIG_PATH_OVERRIDE , _CONFIG_CACHE _APP_CONFIG_PATH_OVERRIDE = Path ( path ) _CONFIG_CACHE = None set_config_override ( payload : dict [ str , Any ], * , replace : bool = False ) -> None Override config values in-memory (tests/CLI). Source code in packages/meeseeks_core/src/meeseeks_core/config.py 637 638 639 640 641 642 643 644 def set_config_override ( payload : dict [ str , Any ], * , replace : bool = False ) -> None : \"\"\"Override config values in-memory (tests/CLI).\"\"\" global _APP_CONFIG_OVERRIDE , _CONFIG_CACHE if replace : _APP_CONFIG_OVERRIDE = payload else : _APP_CONFIG_OVERRIDE = _deep_merge ( _APP_CONFIG_OVERRIDE , payload ) _CONFIG_CACHE = None set_mcp_config_path ( path : str | Path | None ) -> None Override the MCP config path (tests only). Source code in packages/meeseeks_core/src/meeseeks_core/config.py 614 615 616 617 618 619 620 621 622 def set_mcp_config_path ( path : str | Path | None ) -> None : \"\"\"Override the MCP config path (tests only).\"\"\" global _MCP_CONFIG_PATH_OVERRIDE , _MCP_CONFIG_DISABLED if path is None or str ( path ) . strip () == \"\" : _MCP_CONFIG_PATH_OVERRIDE = None _MCP_CONFIG_DISABLED = True return _MCP_CONFIG_DISABLED = False _MCP_CONFIG_PATH_OVERRIDE = Path ( path ) start_preflight ( config : AppConfig | None = None , * , disable_on_failure : bool = True , on_complete : Callable [[ dict [ str , dict [ str , Any ]]], None ] | None = None ) -> threading . Thread Run config preflight checks in a background thread. Source code in packages/meeseeks_core/src/meeseeks_core/config.py 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 def start_preflight ( config : AppConfig | None = None , * , disable_on_failure : bool = True , on_complete : Callable [[ dict [ str , dict [ str , Any ]]], None ] | None = None , ) -> threading . Thread : \"\"\"Run config preflight checks in a background thread.\"\"\" target = config or get_config () def _runner () -> None : global _LAST_PREFLIGHT results = asyncio . run ( target . preflight ( disable_on_failure = disable_on_failure )) _LAST_PREFLIGHT = results failures = { name : info for name , info in results . items () if info . get ( \"enabled\" ) and not info . get ( \"ok\" ) } for name , info in failures . items (): reason = info . get ( \"reason\" ) or \"unknown failure\" _logger . warning ( \"Preflight check failed for %s : %s \" , name , reason ) if on_complete is not None : on_complete ( results ) thread = threading . Thread ( target = _runner , daemon = True ) thread . start () return thread meeseeks_core.components Helpers for optional components and observability integration. ComponentStatus dataclass Describe whether a component is enabled and why. Source code in packages/meeseeks_core/src/meeseeks_core/components.py 34 35 36 37 38 39 40 41 @dataclass ( frozen = True ) class ComponentStatus : \"\"\"Describe whether a component is enabled and why.\"\"\" name : str enabled : bool reason : str | None = None metadata : dict [ str , JsonValue ] = field ( default_factory = dict ) build_langfuse_handler ( * , user_id : str , session_id : str , trace_name : str , version : str , release : str , trace_context : TraceContext | None = None ) -> LangfuseCallbackHandler | None Create a Langfuse callback handler when configured. Source code in packages/meeseeks_core/src/meeseeks_core/components.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def build_langfuse_handler ( * , user_id : str , session_id : str , trace_name : str , version : str , release : str , trace_context : TraceContext | None = None , ) -> LangfuseCallbackHandler | None : \"\"\"Create a Langfuse callback handler when configured.\"\"\" status = resolve_langfuse_status () if not status . enabled : logging . debug ( \"Langfuse disabled: {} \" , status . reason ) return None config = get_config () . langfuse _ensure_langfuse_client ( config ) from langfuse.langchain import CallbackHandler trace_context = trace_context or _LANGFUSE_TRACE_CONTEXT . get () session_id_value = _LANGFUSE_SESSION_ID . get () or session_id user_id_value = _LANGFUSE_USER_ID . get () or user_id try : handler = CallbackHandler ( public_key = config . public_key or None , trace_context = trace_context ) _attach_langfuse_metadata ( handler , user_id = user_id_value , session_id = session_id_value , trace_name = trace_name , version = version , release = release , ) return handler except Exception as exc : # pragma: no cover - defensive logging . warning ( \"Langfuse initialization failed: {} \" , exc ) return None format_component_status ( statuses : Iterable [ ComponentStatus ]) -> str Format component statuses for inclusion in prompts. Source code in packages/meeseeks_core/src/meeseeks_core/components.py 101 102 103 104 105 106 107 108 def format_component_status ( statuses : Iterable [ ComponentStatus ]) -> str : \"\"\"Format component statuses for inclusion in prompts.\"\"\" lines : list [ str ] = [] for status in statuses : state = \"enabled\" if status . enabled else \"disabled\" reason = f \" ( { status . reason } )\" if status . reason else \"\" lines . append ( f \"- { status . name } : { state }{ reason } \" ) return \" \\n \" . join ( lines ) langfuse_session_context ( session_id : str , * , user_id : str | None = None ) -> Iterator [ None ] Bind a stable Langfuse trace context to the current session. Source code in packages/meeseeks_core/src/meeseeks_core/components.py 133 134 135 136 137 138 139 140 141 142 143 144 145 @contextmanager def langfuse_session_context ( session_id : str , * , user_id : str | None = None ) -> Iterator [ None ]: \"\"\"Bind a stable Langfuse trace context to the current session.\"\"\" trace_context = _build_langfuse_trace_context ( session_id ) token_ctx = _LANGFUSE_TRACE_CONTEXT . set ( trace_context ) token_session = _LANGFUSE_SESSION_ID . set ( session_id ) token_user = _LANGFUSE_USER_ID . set ( user_id or session_id ) try : yield finally : _LANGFUSE_TRACE_CONTEXT . reset ( token_ctx ) _LANGFUSE_SESSION_ID . reset ( token_session ) _LANGFUSE_USER_ID . reset ( token_user ) langfuse_trace_span ( name : str ) -> Iterator [ object | None ] Open a Langfuse span bound to the current session trace context. Source code in packages/meeseeks_core/src/meeseeks_core/components.py 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 @contextmanager def langfuse_trace_span ( name : str ) -> Iterator [ object | None ]: \"\"\"Open a Langfuse span bound to the current session trace context.\"\"\" status = resolve_langfuse_status () if not status . enabled : yield None return trace_context = _LANGFUSE_TRACE_CONTEXT . get () if not trace_context : yield None return try : from langfuse import get_client except Exception : # pragma: no cover - defensive yield None return try : langfuse = get_client () with langfuse . start_as_current_observation ( as_type = \"span\" , name = name , trace_context = trace_context , ) as span : yield span except Exception : # pragma: no cover - defensive yield None resolve_home_assistant_status () -> ComponentStatus Determine whether the Home Assistant tool is configured. Source code in packages/meeseeks_core/src/meeseeks_core/components.py 90 91 92 93 94 95 96 97 98 def resolve_home_assistant_status () -> ComponentStatus : \"\"\"Determine whether the Home Assistant tool is configured.\"\"\" enabled , reason , metadata = get_config () . home_assistant . evaluate () return ComponentStatus ( name = \"home_assistant_tool\" , enabled = enabled , reason = reason , metadata = metadata , ) resolve_langfuse_status () -> ComponentStatus Determine whether Langfuse callbacks are available and configured. Source code in packages/meeseeks_core/src/meeseeks_core/components.py 44 45 46 47 def resolve_langfuse_status () -> ComponentStatus : \"\"\"Determine whether Langfuse callbacks are available and configured.\"\"\" enabled , reason , metadata = get_config () . langfuse . evaluate () return ComponentStatus ( name = \"langfuse\" , enabled = enabled , reason = reason , metadata = metadata ) meeseeks_core.permissions Permission policies for tool execution. PermissionDecision Bases: str , Enum Outcomes for a permission check. Source code in packages/meeseeks_core/src/meeseeks_core/permissions.py 23 24 25 26 27 28 class PermissionDecision ( str , Enum ): \"\"\"Outcomes for a permission check.\"\"\" ALLOW = \"allow\" DENY = \"deny\" ASK = \"ask\" PermissionPolicy Evaluate permission rules for action steps. Source code in packages/meeseeks_core/src/meeseeks_core/permissions.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 class PermissionPolicy : \"\"\"Evaluate permission rules for action steps.\"\"\" def __init__ ( self , rules : list [ PermissionRule ] | None = None , default_by_operation : dict [ str , PermissionDecision ] | None = None , default_decision : PermissionDecision = PermissionDecision . ASK , ) -> None : \"\"\"Initialize the permission policy.\"\"\" self . _rules = rules or [] self . _default_by_operation = default_by_operation or {} self . _default_decision = default_decision def decide ( self , action_step : ActionStep ) -> PermissionDecision : \"\"\"Return the permission decision for an action step.\"\"\" for rule in self . _rules : if rule . matches ( action_step ): return rule . decision operation_decision = self . _default_by_operation . get ( action_step . operation ) if operation_decision is not None : return operation_decision return self . _default_decision __init__ ( rules : list [ PermissionRule ] | None = None , default_by_operation : dict [ str , PermissionDecision ] | None = None , default_decision : PermissionDecision = PermissionDecision . ASK ) -> None Initialize the permission policy. Source code in packages/meeseeks_core/src/meeseeks_core/permissions.py 49 50 51 52 53 54 55 56 57 58 def __init__ ( self , rules : list [ PermissionRule ] | None = None , default_by_operation : dict [ str , PermissionDecision ] | None = None , default_decision : PermissionDecision = PermissionDecision . ASK , ) -> None : \"\"\"Initialize the permission policy.\"\"\" self . _rules = rules or [] self . _default_by_operation = default_by_operation or {} self . _default_decision = default_decision decide ( action_step : ActionStep ) -> PermissionDecision Return the permission decision for an action step. Source code in packages/meeseeks_core/src/meeseeks_core/permissions.py 60 61 62 63 64 65 66 67 68 def decide ( self , action_step : ActionStep ) -> PermissionDecision : \"\"\"Return the permission decision for an action step.\"\"\" for rule in self . _rules : if rule . matches ( action_step ): return rule . decision operation_decision = self . _default_by_operation . get ( action_step . operation ) if operation_decision is not None : return operation_decision return self . _default_decision PermissionRule dataclass Rule describing a tool/action permission decision. Source code in packages/meeseeks_core/src/meeseeks_core/permissions.py 31 32 33 34 35 36 37 38 39 40 41 42 43 @dataclass ( frozen = True ) class PermissionRule : \"\"\"Rule describing a tool/action permission decision.\"\"\" tool_id : str = \"*\" operation : str = \"*\" decision : PermissionDecision = PermissionDecision . ASK def matches ( self , action_step : ActionStep ) -> bool : \"\"\"Return True when the action step matches the rule pattern.\"\"\" return fnmatch ( action_step . tool_id , self . tool_id ) and fnmatch ( action_step . operation , self . operation ) matches ( action_step : ActionStep ) -> bool Return True when the action step matches the rule pattern. Source code in packages/meeseeks_core/src/meeseeks_core/permissions.py 39 40 41 42 43 def matches ( self , action_step : ActionStep ) -> bool : \"\"\"Return True when the action step matches the rule pattern.\"\"\" return fnmatch ( action_step . tool_id , self . tool_id ) and fnmatch ( action_step . operation , self . operation ) approval_callback_from_config () -> Callable [[ ActionStep ], bool ] | None Return an approval callback based on config settings. Source code in packages/meeseeks_core/src/meeseeks_core/permissions.py 149 150 151 152 153 154 155 156 157 def approval_callback_from_config () -> Callable [[ ActionStep ], bool ] | None : \"\"\"Return an approval callback based on config settings.\"\"\" mode_raw = get_config_value ( \"permissions\" , \"approval_mode\" , default = \"\" ) mode = str ( mode_raw or \"\" ) . strip () . lower () if mode in { \"allow\" , \"auto\" , \"approve\" , \"yes\" }: return lambda _ : True if mode in { \"deny\" , \"never\" , \"no\" }: return lambda _ : False return None auto_approve ( _ : ActionStep ) -> bool Approval callback that always approves. Source code in packages/meeseeks_core/src/meeseeks_core/permissions.py 160 161 162 def auto_approve ( _ : ActionStep ) -> bool : \"\"\"Approval callback that always approves.\"\"\" return True auto_deny ( _ : ActionStep ) -> bool Approval callback that always denies. Source code in packages/meeseeks_core/src/meeseeks_core/permissions.py 165 166 167 def auto_deny ( _ : ActionStep ) -> bool : \"\"\"Approval callback that always denies.\"\"\" return False load_permission_policy ( path : str | None = None ) -> PermissionPolicy Load permission policy configuration from disk or defaults. Source code in packages/meeseeks_core/src/meeseeks_core/permissions.py 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 def load_permission_policy ( path : str | None = None ) -> PermissionPolicy : \"\"\"Load permission policy configuration from disk or defaults.\"\"\" if path is None : path = get_config_value ( \"permissions\" , \"policy_path\" ) if not path : return _default_policy () if not os . path . exists ( path ): logging . warning ( \"Permission policy file not found: {} \" , path ) return _default_policy () try : payload = _load_policy_data ( path ) except ( json . JSONDecodeError , OSError , tomllib . TOMLDecodeError ) as exc : logging . warning ( \"Failed to load permission policy: {} \" , exc ) return _default_policy () rules : list [ PermissionRule ] = [] for rule_data in payload . get ( \"rules\" , []): decision = _parse_decision ( rule_data . get ( \"decision\" )) if decision is None : continue rules . append ( PermissionRule ( tool_id = str ( rule_data . get ( \"tool_id\" , \"*\" )), operation = str ( rule_data . get ( \"operation\" , \"*\" )), decision = decision , ) ) default_by_operation : dict [ str , PermissionDecision ] = {} for key , value in payload . get ( \"default_by_operation\" , {}) . items (): parsed = _parse_decision ( str ( value )) if parsed is not None : default_by_operation [ str ( key )] = parsed default_decision = _parse_decision ( payload . get ( \"default_decision\" )) if default_decision is None : default_decision = PermissionDecision . ASK return PermissionPolicy ( rules = rules , default_by_operation = default_by_operation , default_decision = default_decision , ) meeseeks_core.hooks Hook manager for orchestration lifecycle events. HookManager dataclass Container for hook callbacks used during orchestration. Source code in packages/meeseeks_core/src/meeseeks_core/hooks.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 @dataclass class HookManager : \"\"\"Container for hook callbacks used during orchestration.\"\"\" pre_tool_use : list [ Callable [[ ActionStep ], ActionStep ]] = field ( default_factory = list ) post_tool_use : list [ Callable [[ ActionStep , MockSpeaker ], MockSpeaker ]] = field ( default_factory = list ) permission_request : list [ Callable [[ ActionStep , PermissionDecision ], PermissionDecision ]] = ( field ( default_factory = list ) ) pre_compact : list [ Callable [[ list [ EventRecord ]], list [ EventRecord ]]] = field ( default_factory = list ) def run_pre_tool_use ( self , action_step : ActionStep ) -> ActionStep : \"\"\"Apply pre-tool hooks to an action step. Args: action_step: Action step to process. Returns: Updated action step after hooks run. \"\"\" for hook in self . pre_tool_use : action_step = hook ( action_step ) return action_step def run_post_tool_use ( self , action_step : ActionStep , result : MockSpeaker ) -> MockSpeaker : \"\"\"Apply post-tool hooks to a tool result. Args: action_step: Action step that was executed. result: Result returned by the tool. Returns: Updated result after hooks run. \"\"\" for hook in self . post_tool_use : result = hook ( action_step , result ) return result def run_permission_request ( self , action_step : ActionStep , decision : PermissionDecision ) -> PermissionDecision : \"\"\"Apply permission hooks to a decision outcome. Args: action_step: Action step under review. decision: Current decision to modify. Returns: Updated permission decision after hooks run. \"\"\" for hook in self . permission_request : decision = hook ( action_step , decision ) return decision def run_pre_compact ( self , events : Iterable [ EventRecord ]) -> list [ EventRecord ]: \"\"\"Apply compaction hooks to events prior to summarization. Args: events: Iterable of event records. Returns: List of event records after hooks run. \"\"\" event_list : list [ EventRecord ] = list ( events ) for hook in self . pre_compact : event_list = hook ( event_list ) return event_list run_permission_request ( action_step : ActionStep , decision : PermissionDecision ) -> PermissionDecision Apply permission hooks to a decision outcome. Parameters: Name Type Description Default action_step ActionStep Action step under review. required decision PermissionDecision Current decision to modify. required Returns: Type Description PermissionDecision Updated permission decision after hooks run. Source code in packages/meeseeks_core/src/meeseeks_core/hooks.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 def run_permission_request ( self , action_step : ActionStep , decision : PermissionDecision ) -> PermissionDecision : \"\"\"Apply permission hooks to a decision outcome. Args: action_step: Action step under review. decision: Current decision to modify. Returns: Updated permission decision after hooks run. \"\"\" for hook in self . permission_request : decision = hook ( action_step , decision ) return decision run_post_tool_use ( action_step : ActionStep , result : MockSpeaker ) -> MockSpeaker Apply post-tool hooks to a tool result. Parameters: Name Type Description Default action_step ActionStep Action step that was executed. required result MockSpeaker Result returned by the tool. required Returns: Type Description MockSpeaker Updated result after hooks run. Source code in packages/meeseeks_core/src/meeseeks_core/hooks.py 43 44 45 46 47 48 49 50 51 52 53 54 55 def run_post_tool_use ( self , action_step : ActionStep , result : MockSpeaker ) -> MockSpeaker : \"\"\"Apply post-tool hooks to a tool result. Args: action_step: Action step that was executed. result: Result returned by the tool. Returns: Updated result after hooks run. \"\"\" for hook in self . post_tool_use : result = hook ( action_step , result ) return result run_pre_compact ( events : Iterable [ EventRecord ]) -> list [ EventRecord ] Apply compaction hooks to events prior to summarization. Parameters: Name Type Description Default events Iterable [ EventRecord ] Iterable of event records. required Returns: Type Description list [ EventRecord ] List of event records after hooks run. Source code in packages/meeseeks_core/src/meeseeks_core/hooks.py 73 74 75 76 77 78 79 80 81 82 83 84 85 def run_pre_compact ( self , events : Iterable [ EventRecord ]) -> list [ EventRecord ]: \"\"\"Apply compaction hooks to events prior to summarization. Args: events: Iterable of event records. Returns: List of event records after hooks run. \"\"\" event_list : list [ EventRecord ] = list ( events ) for hook in self . pre_compact : event_list = hook ( event_list ) return event_list run_pre_tool_use ( action_step : ActionStep ) -> ActionStep Apply pre-tool hooks to an action step. Parameters: Name Type Description Default action_step ActionStep Action step to process. required Returns: Type Description ActionStep Updated action step after hooks run. Source code in packages/meeseeks_core/src/meeseeks_core/hooks.py 30 31 32 33 34 35 36 37 38 39 40 41 def run_pre_tool_use ( self , action_step : ActionStep ) -> ActionStep : \"\"\"Apply pre-tool hooks to an action step. Args: action_step: Action step to process. Returns: Updated action step after hooks run. \"\"\" for hook in self . pre_tool_use : action_step = hook ( action_step ) return action_step default_hook_manager () -> HookManager Create a hook manager with no custom hooks registered. Returns: Type Description HookManager Empty HookManager instance. Source code in packages/meeseeks_core/src/meeseeks_core/hooks.py 88 89 90 91 92 93 94 def default_hook_manager () -> HookManager : \"\"\"Create a hook manager with no custom hooks registered. Returns: Empty HookManager instance. \"\"\" return HookManager () meeseeks_core.common Common helpers shared across the assistant runtime. MockSpeaker Bases: NamedTuple Simple mock response container used across tools and tests. Source code in packages/meeseeks_core/src/meeseeks_core/common.py 22 23 24 25 class MockSpeaker ( NamedTuple ): \"\"\"Simple mock response container used across tools and tests.\"\"\" content : str format_tool_input ( tool_input : object ) -> str Format a tool input for logs and prompts. Source code in packages/meeseeks_core/src/meeseeks_core/common.py 169 170 171 172 173 def format_tool_input ( tool_input : object ) -> str : \"\"\"Format a tool input for logs and prompts.\"\"\" if isinstance ( tool_input , dict ): return json . dumps ( tool_input , ensure_ascii = True ) return str ( tool_input ) get_logger ( name : str | None = None ) Get the logger for the module. Source code in packages/meeseeks_core/src/meeseeks_core/common.py 131 132 133 134 135 136 def get_logger ( name : str | None = None ): \"\"\"Get the logger for the module.\"\"\" _configure_logging () if not name : name = __name__ return loguru_logger . bind ( name = name ) get_mock_speaker () -> type [ MockSpeaker ] Return a mock speaker for testing. Source code in packages/meeseeks_core/src/meeseeks_core/common.py 28 29 30 def get_mock_speaker () -> type [ MockSpeaker ]: \"\"\"Return a mock speaker for testing.\"\"\" return MockSpeaker get_system_prompt ( name : str = 'action-planner' ) -> str Get the system prompt for the task queue. Source code in packages/meeseeks_core/src/meeseeks_core/common.py 157 158 159 160 161 162 163 164 165 166 def get_system_prompt ( name : str = \"action-planner\" ) -> str : \"\"\"Get the system prompt for the task queue.\"\"\" logging = get_logger ( name = \"core.common.get_system_prompt\" ) prompt_resource = resources . files ( \"meeseeks_core\" ) . joinpath ( \"prompts\" ) . joinpath ( f \" { name } .txt\" ) with resources . as_file ( prompt_resource ) as system_prompt_path : with open ( system_prompt_path , encoding = \"utf-8\" ) as system_prompt_file : system_prompt = system_prompt_file . read () logging . debug ( \"Getting system prompt from ` {} `\" , system_prompt_path ) del logging return system_prompt . strip () get_unique_timestamp () -> int Get a unique timestamp for the task queue. Source code in packages/meeseeks_core/src/meeseeks_core/common.py 147 148 149 150 151 152 153 154 def get_unique_timestamp () -> int : \"\"\"Get a unique timestamp for the task queue.\"\"\" # Get the number of seconds since epoch (Jan 1, 1970) as a float current_timestamp = int ( time . time ()) # Convert it to string for uniqueness and consistency unique_timestamp = str ( current_timestamp ) # Return the integer version of this string timestamp return int ( \"\" . join ( str ( x ) for x in map ( int , unique_timestamp ))) ha_render_system_prompt ( all_entities : object | None = None , name : str = 'homeassistant-set-state' ) -> str Render the Home Assistant Jinja2 system prompt. Source code in packages/meeseeks_core/src/meeseeks_core/common.py 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 def ha_render_system_prompt ( all_entities : object | None = None , name : str = \"homeassistant-set-state\" , ) -> str : \"\"\"Render the Home Assistant Jinja2 system prompt.\"\"\" if all_entities is not None : all_entities = str ( all_entities ) . strip () logging = get_logger ( name = \"core.common.render_system_prompt\" ) # TODO: Catch and log TemplateNotFound when necessary. template_env = Environment ( loader = PackageLoader ( \"meeseeks_core\" , \"prompts\" )) template = template_env . get_template ( f \" { name } .txt\" ) logging . debug ( \"Render system prompt for ` {} `\" , name ) del logging return template . render ( ALL_ENTITIES = all_entities ) num_tokens_from_string ( string : str , encoding_name : str = 'cl100k_base' ) -> int Get the number of tokens in a string using a specific model. Source code in packages/meeseeks_core/src/meeseeks_core/common.py 139 140 141 142 143 144 def num_tokens_from_string ( string : str , encoding_name : str = \"cl100k_base\" ) -> int : \"\"\"Get the number of tokens in a string using a specific model.\"\"\" # TODO: Add support for dynamic model selection encoding = tiktoken . get_encoding ( encoding_name ) num_tokens = len ( encoding . encode ( string )) return num_tokens session_log_context ( session_id : str , log_dir : str | None = None ) Context manager that logs all session output to a session log file. Source code in packages/meeseeks_core/src/meeseeks_core/common.py 120 121 122 123 124 125 126 127 128 @contextmanager def session_log_context ( session_id : str , log_dir : str | None = None ): \"\"\"Context manager that logs all session output to a session log file.\"\"\" _ensure_session_log_sink ( session_id , log_dir = log_dir ) try : with loguru_logger . contextualize ( session_id = session_id ): yield finally : _release_session_log_sink ( session_id ) meeseeks_core.errors Core error types for tool/runtime coordination. ToolInputError Bases: Exception Raised when a tool input is invalid but the tool remains healthy. Source code in packages/meeseeks_core/src/meeseeks_core/errors.py 7 8 class ToolInputError ( Exception ): \"\"\"Raised when a tool input is invalid but the tool remains healthy.\"\"\" meeseeks_core.notifications Lightweight notification storage for Meeseeks. NotificationRecord dataclass Typed record for serialized notifications. Source code in packages/meeseeks_core/src/meeseeks_core/notifications.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 @dataclass ( frozen = True ) class NotificationRecord : \"\"\"Typed record for serialized notifications.\"\"\" id : str title : str message : str level : str created_at : str dismissed : bool session_id : str | None = None dismissed_at : str | None = None event_type : str | None = None metadata : dict [ str , object ] | None = None NotificationStore JSON-backed notification store for single-user UI. Source code in packages/meeseeks_core/src/meeseeks_core/notifications.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 class NotificationStore : \"\"\"JSON-backed notification store for single-user UI.\"\"\" def __init__ ( self , root_dir : str | None = None , filename : str = \"notifications.json\" ) -> None : \"\"\"Initialize the notification store location.\"\"\" if root_dir is None : root_dir = get_config_value ( \"runtime\" , \"session_dir\" , default = \"./data/sessions\" ) root_dir = os . path . abspath ( root_dir ) os . makedirs ( root_dir , exist_ok = True ) self . _path = os . path . join ( root_dir , filename ) self . _lock = threading . Lock () def _load ( self ) -> list [ dict [ str , object ]]: \"\"\"Load notification records from disk.\"\"\" if not os . path . exists ( self . _path ): return [] with open ( self . _path , encoding = \"utf-8\" ) as handle : try : data = json . load ( handle ) except json . JSONDecodeError : return [] if isinstance ( data , list ): return data return [] def _save ( self , data : list [ dict [ str , object ]]) -> None : \"\"\"Persist notification records to disk.\"\"\" with open ( self . _path , \"w\" , encoding = \"utf-8\" ) as handle : json . dump ( data , handle , indent = 2 ) def list ( self , * , include_dismissed : bool = False ) -> list [ dict [ str , object ]]: \"\"\"Return notifications, optionally including dismissed ones.\"\"\" with self . _lock : data = self . _load () if not include_dismissed : data = [ item for item in data if not item . get ( \"dismissed\" )] return sorted ( data , key = lambda item : str ( item . get ( \"created_at\" , \"\" )), reverse = True , ) def add ( self , * , title : str , message : str , level : str = \"info\" , session_id : str | None = None , event_type : str | None = None , metadata : dict [ str , object ] | None = None , ) -> dict [ str , object ]: \"\"\"Add a new notification record and return it.\"\"\" record = NotificationRecord ( id = uuid . uuid4 () . hex , title = title , message = message , level = level , created_at = _utc_now (), dismissed = False , session_id = session_id , dismissed_at = None , event_type = event_type , metadata = metadata , ) payload = record . __dict__ with self . _lock : data = self . _load () data . append ( payload ) self . _save ( data ) return payload def dismiss ( self , ids : Sequence [ str ]) -> int : \"\"\"Mark notifications as dismissed.\"\"\" if not ids : return 0 dismissed_at = _utc_now () updated = 0 with self . _lock : data = self . _load () for item in data : if item . get ( \"id\" ) in ids and not item . get ( \"dismissed\" ): item [ \"dismissed\" ] = True item [ \"dismissed_at\" ] = dismissed_at updated += 1 self . _save ( data ) return updated def clear ( self , * , dismissed_only : bool = True ) -> int : \"\"\"Clear dismissed notifications (or all when requested).\"\"\" with self . _lock : data = self . _load () if dismissed_only : remaining = [ item for item in data if not item . get ( \"dismissed\" )] else : remaining = [] removed = len ( data ) - len ( remaining ) self . _save ( remaining ) return removed __init__ ( root_dir : str | None = None , filename : str = 'notifications.json' ) -> None Initialize the notification store location. Source code in packages/meeseeks_core/src/meeseeks_core/notifications.py 40 41 42 43 44 45 46 47 def __init__ ( self , root_dir : str | None = None , filename : str = \"notifications.json\" ) -> None : \"\"\"Initialize the notification store location.\"\"\" if root_dir is None : root_dir = get_config_value ( \"runtime\" , \"session_dir\" , default = \"./data/sessions\" ) root_dir = os . path . abspath ( root_dir ) os . makedirs ( root_dir , exist_ok = True ) self . _path = os . path . join ( root_dir , filename ) self . _lock = threading . Lock () add ( * , title : str , message : str , level : str = 'info' , session_id : str | None = None , event_type : str | None = None , metadata : dict [ str , object ] | None = None ) -> dict [ str , object ] Add a new notification record and return it. Source code in packages/meeseeks_core/src/meeseeks_core/notifications.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def add ( self , * , title : str , message : str , level : str = \"info\" , session_id : str | None = None , event_type : str | None = None , metadata : dict [ str , object ] | None = None , ) -> dict [ str , object ]: \"\"\"Add a new notification record and return it.\"\"\" record = NotificationRecord ( id = uuid . uuid4 () . hex , title = title , message = message , level = level , created_at = _utc_now (), dismissed = False , session_id = session_id , dismissed_at = None , event_type = event_type , metadata = metadata , ) payload = record . __dict__ with self . _lock : data = self . _load () data . append ( payload ) self . _save ( data ) return payload clear ( * , dismissed_only : bool = True ) -> int Clear dismissed notifications (or all when requested). Source code in packages/meeseeks_core/src/meeseeks_core/notifications.py 125 126 127 128 129 130 131 132 133 134 135 def clear ( self , * , dismissed_only : bool = True ) -> int : \"\"\"Clear dismissed notifications (or all when requested).\"\"\" with self . _lock : data = self . _load () if dismissed_only : remaining = [ item for item in data if not item . get ( \"dismissed\" )] else : remaining = [] removed = len ( data ) - len ( remaining ) self . _save ( remaining ) return removed dismiss ( ids : Sequence [ str ]) -> int Mark notifications as dismissed. Source code in packages/meeseeks_core/src/meeseeks_core/notifications.py 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 def dismiss ( self , ids : Sequence [ str ]) -> int : \"\"\"Mark notifications as dismissed.\"\"\" if not ids : return 0 dismissed_at = _utc_now () updated = 0 with self . _lock : data = self . _load () for item in data : if item . get ( \"id\" ) in ids and not item . get ( \"dismissed\" ): item [ \"dismissed\" ] = True item [ \"dismissed_at\" ] = dismissed_at updated += 1 self . _save ( data ) return updated list ( * , include_dismissed : bool = False ) -> list [ dict [ str , object ]] Return notifications, optionally including dismissed ones. Source code in packages/meeseeks_core/src/meeseeks_core/notifications.py 67 68 69 70 71 72 73 74 75 76 77 def list ( self , * , include_dismissed : bool = False ) -> list [ dict [ str , object ]]: \"\"\"Return notifications, optionally including dismissed ones.\"\"\" with self . _lock : data = self . _load () if not include_dismissed : data = [ item for item in data if not item . get ( \"dismissed\" )] return sorted ( data , key = lambda item : str ( item . get ( \"created_at\" , \"\" )), reverse = True , ) meeseeks_core.share_store Session share token storage. ShareStore JSON-backed share token store for session exports. Source code in packages/meeseeks_core/src/meeseeks_core/share_store.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 class ShareStore : \"\"\"JSON-backed share token store for session exports.\"\"\" def __init__ ( self , root_dir : str | None = None , filename : str = \"shares.json\" ) -> None : \"\"\"Initialize the share token store location.\"\"\" if root_dir is None : root_dir = get_config_value ( \"runtime\" , \"session_dir\" , default = \"./data/sessions\" ) root_dir = os . path . abspath ( root_dir ) os . makedirs ( root_dir , exist_ok = True ) self . _path = os . path . join ( root_dir , filename ) self . _lock = threading . Lock () def _load ( self ) -> dict [ str , dict [ str , object ]]: \"\"\"Load share token records from disk.\"\"\" if not os . path . exists ( self . _path ): return {} with open ( self . _path , encoding = \"utf-8\" ) as handle : try : data = json . load ( handle ) except json . JSONDecodeError : return {} if isinstance ( data , dict ): return data return {} def _save ( self , data : dict [ str , dict [ str , object ]]) -> None : \"\"\"Persist share token records to disk.\"\"\" with open ( self . _path , \"w\" , encoding = \"utf-8\" ) as handle : json . dump ( data , handle , indent = 2 ) def create ( self , session_id : str ) -> dict [ str , object ]: \"\"\"Create and store a new share token.\"\"\" token = uuid . uuid4 () . hex record : dict [ str , object ] = { \"session_id\" : session_id , \"created_at\" : _utc_now ()} with self . _lock : data = self . _load () data [ token ] = record self . _save ( data ) return { \"token\" : token , ** record } def resolve ( self , token : str ) -> dict [ str , object ] | None : \"\"\"Resolve a share token to its record.\"\"\" if not token : return None with self . _lock : data = self . _load () record = data . get ( token ) if not record : return None return { \"token\" : token , ** record } def revoke ( self , token : str ) -> bool : \"\"\"Revoke a share token.\"\"\" if not token : return False with self . _lock : data = self . _load () if token not in data : return False data . pop ( token , None ) self . _save ( data ) return True __init__ ( root_dir : str | None = None , filename : str = 'shares.json' ) -> None Initialize the share token store location. Source code in packages/meeseeks_core/src/meeseeks_core/share_store.py 22 23 24 25 26 27 28 29 def __init__ ( self , root_dir : str | None = None , filename : str = \"shares.json\" ) -> None : \"\"\"Initialize the share token store location.\"\"\" if root_dir is None : root_dir = get_config_value ( \"runtime\" , \"session_dir\" , default = \"./data/sessions\" ) root_dir = os . path . abspath ( root_dir ) os . makedirs ( root_dir , exist_ok = True ) self . _path = os . path . join ( root_dir , filename ) self . _lock = threading . Lock () create ( session_id : str ) -> dict [ str , object ] Create and store a new share token. Source code in packages/meeseeks_core/src/meeseeks_core/share_store.py 49 50 51 52 53 54 55 56 57 def create ( self , session_id : str ) -> dict [ str , object ]: \"\"\"Create and store a new share token.\"\"\" token = uuid . uuid4 () . hex record : dict [ str , object ] = { \"session_id\" : session_id , \"created_at\" : _utc_now ()} with self . _lock : data = self . _load () data [ token ] = record self . _save ( data ) return { \"token\" : token , ** record } resolve ( token : str ) -> dict [ str , object ] | None Resolve a share token to its record. Source code in packages/meeseeks_core/src/meeseeks_core/share_store.py 59 60 61 62 63 64 65 66 67 68 def resolve ( self , token : str ) -> dict [ str , object ] | None : \"\"\"Resolve a share token to its record.\"\"\" if not token : return None with self . _lock : data = self . _load () record = data . get ( token ) if not record : return None return { \"token\" : token , ** record } revoke ( token : str ) -> bool Revoke a share token. Source code in packages/meeseeks_core/src/meeseeks_core/share_store.py 70 71 72 73 74 75 76 77 78 79 80 def revoke ( self , token : str ) -> bool : \"\"\"Revoke a share token.\"\"\" if not token : return False with self . _lock : data = self . _load () if token not in data : return False data . pop ( token , None ) self . _save ( data ) return True meeseeks_core.llm Model configuration helpers for ChatLiteLLM. ChatModel Bases: Protocol Protocol for LangChain-compatible chat models. Source code in packages/meeseeks_core/src/meeseeks_core/llm.py 12 13 14 15 16 class ChatModel ( Protocol ): \"\"\"Protocol for LangChain-compatible chat models.\"\"\" def invoke ( self , input_data : object , config : object | None = None , ** kwargs : object ) -> object : \"\"\"Invoke the model with structured input.\"\"\" invoke ( input_data : object , config : object | None = None , ** kwargs : object ) -> object Invoke the model with structured input. Source code in packages/meeseeks_core/src/meeseeks_core/llm.py 15 16 def invoke ( self , input_data : object , config : object | None = None , ** kwargs : object ) -> object : \"\"\"Invoke the model with structured input.\"\"\" build_chat_model ( model_name : str , * , openai_api_base : str | None = None , api_key : str | None = None ) -> ChatModel Build a ChatLiteLLM model with reasoning-effort compatibility. Source code in packages/meeseeks_core/src/meeseeks_core/llm.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def build_chat_model ( model_name : str , * , openai_api_base : str | None = None , api_key : str | None = None , ) -> ChatModel : \"\"\"Build a ChatLiteLLM model with reasoning-effort compatibility.\"\"\" try : from langchain_litellm import ChatLiteLLM except ImportError as exc : # pragma: no cover - dependency guard raise ImportError ( \"langchain-litellm is required to build ChatLiteLLM\" ) from exc reasoning_effort = resolve_reasoning_effort ( model_name ) model_kwargs : dict [ str , Any ] = {} if reasoning_effort is not None : model_kwargs [ \"reasoning_effort\" ] = reasoning_effort kwargs : dict [ str , Any ] = { \"model\" : _resolve_litellm_model ( model_name , openai_api_base ), } if openai_api_base : kwargs [ \"api_base\" ] = openai_api_base if api_key : kwargs [ \"api_key\" ] = api_key if model_kwargs : kwargs [ \"model_kwargs\" ] = model_kwargs return cast ( ChatModel , ChatLiteLLM ( ** kwargs )) model_supports_reasoning_effort ( model_name : str | None ) -> bool Return True if the model is known to support reasoning_effort. Source code in packages/meeseeks_core/src/meeseeks_core/llm.py 47 48 49 50 51 52 53 54 55 56 57 58 def model_supports_reasoning_effort ( model_name : str | None ) -> bool : \"\"\"Return True if the model is known to support reasoning_effort.\"\"\" if not model_name : return False raw = model_name . lower () normalized = _strip_provider ( model_name ) allowlist = _normalize_model_list ( get_config_value ( \"llm\" , \"reasoning_effort_models\" , default = []) ) if _matches_model_list ( raw , allowlist ) or _matches_model_list ( normalized , allowlist ): return True return normalized . startswith ( \"gpt-5\" ) resolve_reasoning_effort ( model_name : str | None ) -> str | None Resolve the reasoning effort to use for a model. Source code in packages/meeseeks_core/src/meeseeks_core/llm.py 61 62 63 64 65 66 67 68 69 70 71 def resolve_reasoning_effort ( model_name : str | None ) -> str | None : \"\"\"Resolve the reasoning effort to use for a model.\"\"\" configured = get_config_value ( \"llm\" , \"reasoning_effort\" , default = \"\" ) if isinstance ( configured , str ) and configured . strip (): return configured . strip () . lower () if not model_supports_reasoning_effort ( model_name ): return None normalized = _strip_provider ( model_name ) if \"gpt-5-pro\" in normalized : return \"high\" return \"medium\" packages/meeseeks_tools (tool integrations) meeseeks_tools.integration.mcp MCP tool runner for integrating MCP servers into Meeseeks. MCPToolRunner Wrapper to invoke MCP tools via langchain-mcp-adapters. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/mcp.py 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 class MCPToolRunner : \"\"\"Wrapper to invoke MCP tools via langchain-mcp-adapters.\"\"\" def __init__ ( self , server_name : str , tool_name : str ) -> None : \"\"\"Initialize the MCP tool runner for a specific server tool. Args: server_name: MCP server name from configuration. tool_name: Tool name to invoke on the server. \"\"\" self . server_name = server_name self . tool_name = tool_name async def _invoke_async ( self , input_payload : str | dict [ str , Any ]) -> str : \"\"\"Invoke an MCP tool asynchronously and return its output. Args: input_payload: Input payload to send to the MCP tool. Returns: Stringified tool response. Raises: RuntimeError: If MCP adapters are not installed. ValueError: If the server or tool is not configured. \"\"\" try : from langchain_mcp_adapters.client import MultiServerMCPClient except Exception as exc : # pragma: no cover - runtime dependency raise RuntimeError ( \"langchain-mcp-adapters is required for MCP tools.\" ) from exc config = _load_mcp_config () servers = config . get ( \"servers\" , {}) if not servers or self . server_name not in servers : raise ValueError ( f \"MCP server ' { self . server_name } ' not found in config.\" ) client = MultiServerMCPClient ({ self . server_name : servers [ self . server_name ]}) tools = await client . get_tools ( server_name = self . server_name ) tool_map = { tool . name : tool for tool in tools } tool = tool_map . get ( self . tool_name ) if tool is None : raise ValueError ( f \"Tool ' { self . tool_name } ' not found on MCP server ' { self . server_name } '.\" ) try : result = await tool . ainvoke ( _prepare_mcp_input ( tool , input_payload )) return str ( result ) except Exception as exc : _log_runtime_failure ( self . server_name , self . tool_name , exc ) raise def run ( self , action_step : ActionStep ) -> MockSpeaker : \"\"\"Execute the MCP tool using the action step argument. Args: action_step: Action step containing the prompt argument. Returns: MockSpeaker with the tool response content. Raises: ValueError: If action_step is None. \"\"\" if action_step is None : raise ValueError ( \"Action step cannot be None.\" ) MockSpeakerType = get_mock_speaker () result = asyncio . run ( self . _invoke_async ( action_step . tool_input )) return MockSpeakerType ( content = result ) __init__ ( server_name : str , tool_name : str ) -> None Initialize the MCP tool runner for a specific server tool. Parameters: Name Type Description Default server_name str MCP server name from configuration. required tool_name str Tool name to invoke on the server. required Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/mcp.py 265 266 267 268 269 270 271 272 273 def __init__ ( self , server_name : str , tool_name : str ) -> None : \"\"\"Initialize the MCP tool runner for a specific server tool. Args: server_name: MCP server name from configuration. tool_name: Tool name to invoke on the server. \"\"\" self . server_name = server_name self . tool_name = tool_name run ( action_step : ActionStep ) -> MockSpeaker Execute the MCP tool using the action step argument. Parameters: Name Type Description Default action_step ActionStep Action step containing the prompt argument. required Returns: Type Description MockSpeaker MockSpeaker with the tool response content. Raises: Type Description ValueError If action_step is None. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/mcp.py 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 def run ( self , action_step : ActionStep ) -> MockSpeaker : \"\"\"Execute the MCP tool using the action step argument. Args: action_step: Action step containing the prompt argument. Returns: MockSpeaker with the tool response content. Raises: ValueError: If action_step is None. \"\"\" if action_step is None : raise ValueError ( \"Action step cannot be None.\" ) MockSpeakerType = get_mock_speaker () result = asyncio . run ( self . _invoke_async ( action_step . tool_input )) return MockSpeakerType ( content = result ) discover_mcp_tool_details ( config : dict [ str , Any ]) -> dict [ str , list [ dict [ str , Any ]]] Discover MCP tool names and schemas per server from configuration. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/mcp.py 206 207 208 def discover_mcp_tool_details ( config : dict [ str , Any ]) -> dict [ str , list [ dict [ str , Any ]]]: \"\"\"Discover MCP tool names and schemas per server from configuration.\"\"\" return _run_async ( _discover_mcp_tool_details_async ( _normalize_mcp_config ( config ))) discover_mcp_tool_details_with_failures ( config : dict [ str , Any ]) -> tuple [ dict [ str , list [ dict [ str , Any ]]], dict [ str , Exception ]] Discover MCP tool names, schemas, and per-server failures. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/mcp.py 211 212 213 214 215 216 217 218 219 def discover_mcp_tool_details_with_failures ( config : dict [ str , Any ], ) -> tuple [ dict [ str , list [ dict [ str , Any ]]], dict [ str , Exception ]]: \"\"\"Discover MCP tool names, schemas, and per-server failures.\"\"\" discovered , failures = _run_async ( _discover_mcp_tool_details_with_failures_async ( _normalize_mcp_config ( config )) ) _record_discovery_failures ( failures ) return discovered , failures discover_mcp_tools ( config : dict [ str , Any ]) -> dict [ str , list [ str ]] Discover MCP tool names per server from configuration. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/mcp.py 197 198 199 200 201 202 203 def discover_mcp_tools ( config : dict [ str , Any ]) -> dict [ str , list [ str ]]: \"\"\"Discover MCP tool names per server from configuration.\"\"\" details = discover_mcp_tool_details ( config ) return { server_name : [ tool [ \"name\" ] for tool in tools if tool . get ( \"name\" )] for server_name , tools in details . items () } get_last_discovery_failures () -> dict [ str , str ] Return last MCP discovery failures per server (if any). Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/mcp.py 229 230 231 def get_last_discovery_failures () -> dict [ str , str ]: \"\"\"Return last MCP discovery failures per server (if any).\"\"\" return dict ( _LAST_DISCOVERY_FAILURES ) mark_tool_auto_approved ( config : dict [ str , Any ], server_name : str , tool_name : str ) -> dict [ str , Any ] Record a tool as auto-approved in the MCP config. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/mcp.py 247 248 249 250 251 252 253 254 255 256 257 258 259 def mark_tool_auto_approved ( config : dict [ str , Any ], server_name : str , tool_name : str , ) -> dict [ str , Any ]: \"\"\"Record a tool as auto-approved in the MCP config.\"\"\" servers = config . setdefault ( \"servers\" , {}) server_config = servers . setdefault ( server_name , {}) allowlist = server_config . setdefault ( \"auto_approve_tools\" , []) if tool_name not in allowlist : allowlist . append ( tool_name ) server_config [ \"auto_approve_tools\" ] = sorted ( set ( allowlist )) return config save_mcp_config ( config : dict [ str , Any ], path : str | None = None ) -> None Persist an MCP configuration payload to disk. Parameters: Name Type Description Default config dict [ str , Any ] MCP configuration payload to write. required path str | None Optional explicit file path (defaults to the configured MCP path). None Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/mcp.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 def save_mcp_config ( config : dict [ str , Any ], path : str | None = None ) -> None : \"\"\"Persist an MCP configuration payload to disk. Args: config: MCP configuration payload to write. path: Optional explicit file path (defaults to the configured MCP path). \"\"\" config_path = path or get_mcp_config_path () if not config_path : raise ValueError ( \"MCP config path is not set.\" ) config_path = os . path . abspath ( config_path ) with open ( config_path , \"w\" , encoding = \"utf-8\" ) as handle : json . dump ( config , handle , indent = 2 ) handle . write ( \" \\n \" ) tool_auto_approved ( config : dict [ str , Any ], server_name : str , tool_name : str ) -> bool Return True when a tool is marked as auto-approved. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/mcp.py 234 235 236 237 238 239 240 241 242 243 244 def tool_auto_approved ( config : dict [ str , Any ], server_name : str , tool_name : str , ) -> bool : \"\"\"Return True when a tool is marked as auto-approved.\"\"\" server_config = config . get ( \"servers\" , {}) . get ( server_name , {}) if server_config . get ( \"auto_approve_all\" ): return True allowlist = server_config . get ( \"auto_approve_tools\" , []) return tool_name in allowlist meeseeks_tools.integration.homeassistant Home Assistant integration tools and data models. CacheHolder Bases: Protocol Protocol describing objects with a Home Assistant cache attribute. Attributes: Name Type Description cache HomeAssistantCache Home Assistant cache payload. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 45 46 47 48 49 50 51 52 53 @runtime_checkable class CacheHolder ( Protocol ): \"\"\"Protocol describing objects with a Home Assistant cache attribute. Attributes: cache: Home Assistant cache payload. \"\"\" cache : HomeAssistantCache HomeAssistant Bases: AbstractTool A service to manage and interact with Home Assistant. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 class HomeAssistant ( AbstractTool ): \"\"\"A service to manage and interact with Home Assistant.\"\"\" def __init__ ( self ) -> None : \"\"\"Initialize the Home Assistant tool with environment defaults.\"\"\" super () . __init__ ( name = \"Home Assistant\" , description = \"A service to manage and interact with Home Assistant\" , ) self . base_url = get_config_value ( \"home_assistant\" , \"url\" ) self . _api_token = get_config_value ( \"home_assistant\" , \"token\" ) self . cache : HomeAssistantCache = { \"entity_ids\" : [], \"sensor_ids\" : [], \"entities\" : [], \"services\" : [], \"sensors\" : [], \"allowed_domains\" : [ \"scene\" , \"switch\" , \"weather\" , \"kodi\" , \"automation\" ], } if not self . base_url or not self . _api_token : raise ValueError ( \"home_assistant.url and home_assistant.token must be set.\" ) self . api_headers : dict [ str , str ] = { \"Authorization\" : f \"Bearer { self . _api_token } \" , \"Content-Type\" : \"application/json\" , } @cache_monitor def update_services ( self ) -> bool : \"\"\"Update the list of services from Home Assistant. Returns: True when services are fetched successfully. \"\"\" url = f \" { self . base_url } /services\" try : response = requests . get ( url , headers = self . api_headers , timeout = 30 ) status_code = getattr ( response , \"status_code\" , None ) if status_code in { 401 , 403 }: logging . error ( \"Home Assistant authorization failed with status {} .\" , status_code ) raise PermissionError ( \"Home Assistant authorization failed.\" ) response . raise_for_status () self . cache [ \"services\" ] = response . json () self . _save_json ( self . cache [ \"services\" ], \"services.json\" ) return True except requests . exceptions . RequestException as e : logging . error ( \"Error: {} \" , e ) return False @cache_monitor def update_entities ( self ) -> bool : \"\"\"Update the list of entities from Home Assistant. Returns: True when entities are fetched successfully. \"\"\" url = f \" { self . base_url } /states\" try : response = requests . get ( url , headers = self . api_headers , timeout = 30 ) status_code = getattr ( response , \"status_code\" , None ) if status_code in { 401 , 403 }: logging . error ( \"Home Assistant authorization failed with status {} .\" , status_code ) raise PermissionError ( \"Home Assistant authorization failed.\" ) response . raise_for_status () self . cache [ \"entities\" ] = response . json () return True except requests . exceptions . RequestException as e : logging . error ( \"Error: {} \" , e ) return False @cache_monitor def update_entity_ids ( self ) -> bool : \"\"\"Update the list of entity IDs from Home Assistant. Returns: True when entity IDs are populated. Raises: ValueError: If no entities are available for ID extraction. \"\"\" # TODO: Always assumes blacklist by default due to cache_monitor. self . update_entities () entities = self . cache [ \"entities\" ] if not entities : raise ValueError ( \"No entities found while updating entity IDs.\" ) self . cache [ \"entity_ids\" ] = [ entity [ \"entity_id\" ] for entity in entities ] logging . info ( \"Entity IDs updated.\" ) return True @cache_monitor def update_cache ( self ) -> None : \"\"\"Update the entire cache. Raises: ValueError: If entity IDs cannot be derived. \"\"\" self . update_entity_ids () self . update_services () self . _save_json ( self . cache [ \"entities\" ], \"entities.json\" ) self . _save_json ( self . cache [ \"sensors\" ], \"sensors.json\" ) def call_service ( self , domain : str , service : str , entity_id : str , data : dict | None = None , ) -> tuple [ bool , list [ dict [ str , Any ]]]: \"\"\"Call a service in Home Assistant. Args: domain: Home Assistant domain name (e.g., \"light\"). service: Service name within the domain (e.g., \"turn_on\"). entity_id: Entity ID to target. data: Optional extra payload for the service call. Returns: Tuple of success flag and JSON response payload. Raises: ValueError: If the domain is not allowed. \"\"\" if domain not in self . cache [ \"allowed_domains\" ]: raise ValueError ( f \"Domain does not exist or blacklisted: { domain } \" ) url = f \" { self . base_url } /services/ { domain } / { service } \" payload = { \"entity_id\" : entity_id } if data : payload . update ( data ) try : response = requests . post ( url , headers = self . api_headers , json = payload , timeout = 30 ) status_code = getattr ( response , \"status_code\" , None ) if status_code in { 401 , 403 }: logging . error ( \"Home Assistant authorization failed with status {} .\" , status_code ) raise PermissionError ( \"Home Assistant authorization failed.\" ) response . raise_for_status () logging . info ( \"Service < {} . {} > called on entity < {} > returned ` {} `.\" , domain , service , entity_id , response . text , ) return True , response . json () except requests . exceptions . RequestException as e : logging . error ( \"Unable to call service < {} . {} > on entity < {} >: {} \" , domain , service , entity_id , e ) return False , [] @staticmethod def _create_set_prompt ( system_prompt : str , parser : PydanticOutputParser , ) -> ChatPromptTemplate : \"\"\"Create the prompt template for a set-state operation. Args: system_prompt: System prompt content. parser: Pydantic output parser for HomeAssistantCall. Returns: ChatPromptTemplate configured for set-state tasks. \"\"\" example = HomeAssistantCall ( domain = \"scene\" , service = \"turn_on\" , entity_id = \"scene.lamp_power_on\" ) prompt = ChatPromptTemplate ( messages = [ SystemMessage ( content = system_prompt ), HumanMessage ( content = \"Turn on the lamp lights.\" ), AIMessage ( content = example . json ()), HumanMessagePromptTemplate . from_template ( \"The user asked you to ` {action_step} `. You must use the information \" \"provided to pick the right Home Assistant service call values only \" \"considering the current user query. \\n\\n \" \"## Format Instructions \\n {format_instructions} \\n\\n \" \"## Home Assistant Entities and Domain-Services \\n ``` \\n {context} ``` \\n \" ), ], partial_variables = { \"format_instructions\" : parser . get_format_instructions ()}, input_variables = [ \"action_step\" ], ) return prompt @staticmethod def _create_get_prompt ( system_prompt : str ) -> ChatPromptTemplate : \"\"\"Create the prompt template for a get-state operation. Args: system_prompt: System prompt content. Returns: ChatPromptTemplate configured for get-state tasks. \"\"\" prompt = ChatPromptTemplate ( messages = [ SystemMessage ( content = system_prompt ), HumanMessage ( content = \"How is the air quality today?\" ), AIMessage ( content = ( \"AccuWeather reported today's air quality in your home as good. \" \"This level of air quality ensures that the environment is healthy, \" \"supporting your daily activities and wellbeing without any air \" \"quality-related risks.\" ) ), HumanMessagePromptTemplate . from_template ( \"The user asked you to ` {action_step} `. You must use the sensor \" \"information to answer the user's query. Keep your answer \" \"analytical, brief and useful. \\n\\n \" \"## Home Assistant Sensors \\n ``` \\n {context} ``` \\n \" ), ], input_variables = [ \"action_step\" ], ) return prompt @staticmethod def _clean_answer ( answer : str ) -> str : \"\"\"Clean the answer by removing/replacing characters. Args: answer: Raw answer string to normalize. Returns: Cleaned answer string. \"\"\" replacements = { # Common entities \"RealFeel\" : \"Real Feel\" , # Confident Abbreviations \"km/h\" : \" kilometer per hour\" , \"\u00b0C\" : \" degrees celsius\" , \"%\" : \" percent\" , \"mm/h\" : \" millimeter per hour\" , \"Gb/s\" : \" gigabits per second\" , \"Mb/s\" : \" megabits per second\" , \"Kb/s\" : \" kilobits per second\" , \"GHz\" : \"Gigahertz\" , # Formatting '\"' : \"\" , } # Replace using the dictionary for old , new in replacements . items (): answer = answer . replace ( old , new ) # Remove extra spaces and new lines, condense all multiple spaces # to a single space answer = re . sub ( r \"\\s+\" , \" \" , answer ) . strip () return answer def _invoke_service_and_set_state ( self , chain : SupportsInvoke , rag_documents : list [ Document ], action_step : ActionStep , ) -> MockSpeaker : \"\"\"Invoke the service and set the state. Args: chain: Runnable chain that yields HomeAssistantCall. rag_documents: Context documents for the chain. action_step: Action step describing the request. Returns: MockSpeaker with a status message. \"\"\" MockSpeaker = get_mock_speaker () try : action_step_curr = str ( action_step . tool_input ) . strip () call_service_values = chain . invoke ( { \"action_step\" : action_step_curr , \"context\" : rag_documents , \"cache\" : self . cache }, ) logging . debug ( \"Call Service Values for ` {} `: ` {} `\" , action_step_curr , call_service_values ) status_bool , response_json = self . call_service ( domain = call_service_values . domain , service = call_service_values . service , entity_id = call_service_values . entity_id , ) if status_bool : tmp_return_message = f \"Successfully called service: ` { response_json } `\" else : tmp_return_message = f \"Failed to call service: ` { response_json } `\" except Exception as err_mesaage : logging . error ( \"Error: {} \" , err_mesaage ) tmp_return_message = f \"I received an error - ` { err_mesaage } `\" return MockSpeaker ( content = tmp_return_message ) def set_state ( self , action_step : ActionStep | None = None ) -> MockSpeaker : \"\"\"Predict and call a service for a given action step. Args: action_step: Action step describing the desired change. Returns: MockSpeaker with a status message. Raises: ValueError: If action_step is None. \"\"\" if action_step is None : raise ValueError ( \"Action step cannot be None.\" ) self . update_cache () rag_documents = self . _load_rag_documents ([ \"entities.json\" , \"services.json\" ]) system_prompt = ha_render_system_prompt ( name = \"homeassistant-set-state\" , all_entities = self . cache [ \"entity_ids\" ] ) parser = PydanticOutputParser ( pydantic_object = HomeAssistantCall ) # type: ignore[type-var] prompt = self . _create_set_prompt ( system_prompt , parser ) if self . model is None : raise RuntimeError ( \"LLM client not initialized for Home Assistant.\" ) model = self . model chain : Any = prompt | model | parser logging . info ( \"Invoking `set` action chain using ` {} ` for ` {} `.\" , self . model_name , action_step ) # TODO: Interpret the response from call service. return self . _invoke_service_and_set_state ( chain , rag_documents , action_step ) def get_state ( self , action_step : ActionStep | None = None ) -> MockSpeaker : \"\"\"Generate response for a given action step based on sensors. Args: action_step: Action step describing the desired query. Returns: MockSpeaker with the generated response. Raises: ValueError: If action_step is None. \"\"\" if action_step is None : raise ValueError ( \"Action step cannot be None.\" ) self . update_cache () rag_documents = self . _load_rag_documents ([ \"sensors.json\" ]) system_prompt = ha_render_system_prompt ( name = \"homeassistant-get-state\" ) prompt = self . _create_get_prompt ( system_prompt ) if self . model is None : raise RuntimeError ( \"LLM client not initialized for Home Assistant.\" ) model = self . model chain : Any = prompt | model logging . info ( \"Invoking `get` action chain using ` {} `.\" , self . model_name ) message = chain . invoke ( { \"action_step\" : str ( action_step . tool_input ) . strip (), \"context\" : rag_documents , }, ) cleaned_message = self . _clean_answer ( str ( message . content )) MockSpeaker = get_mock_speaker () return MockSpeaker ( content = cleaned_message ) __init__ () -> None Initialize the Home Assistant tool with environment defaults. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 def __init__ ( self ) -> None : \"\"\"Initialize the Home Assistant tool with environment defaults.\"\"\" super () . __init__ ( name = \"Home Assistant\" , description = \"A service to manage and interact with Home Assistant\" , ) self . base_url = get_config_value ( \"home_assistant\" , \"url\" ) self . _api_token = get_config_value ( \"home_assistant\" , \"token\" ) self . cache : HomeAssistantCache = { \"entity_ids\" : [], \"sensor_ids\" : [], \"entities\" : [], \"services\" : [], \"sensors\" : [], \"allowed_domains\" : [ \"scene\" , \"switch\" , \"weather\" , \"kodi\" , \"automation\" ], } if not self . base_url or not self . _api_token : raise ValueError ( \"home_assistant.url and home_assistant.token must be set.\" ) self . api_headers : dict [ str , str ] = { \"Authorization\" : f \"Bearer { self . _api_token } \" , \"Content-Type\" : \"application/json\" , } call_service ( domain : str , service : str , entity_id : str , data : dict | None = None ) -> tuple [ bool , list [ dict [ str , Any ]]] Call a service in Home Assistant. Parameters: Name Type Description Default domain str Home Assistant domain name (e.g., \"light\"). required service str Service name within the domain (e.g., \"turn_on\"). required entity_id str Entity ID to target. required data dict | None Optional extra payload for the service call. None Returns: Type Description tuple [ bool , list [ dict [ str , Any ]]] Tuple of success flag and JSON response payload. Raises: Type Description ValueError If the domain is not allowed. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 def call_service ( self , domain : str , service : str , entity_id : str , data : dict | None = None , ) -> tuple [ bool , list [ dict [ str , Any ]]]: \"\"\"Call a service in Home Assistant. Args: domain: Home Assistant domain name (e.g., \"light\"). service: Service name within the domain (e.g., \"turn_on\"). entity_id: Entity ID to target. data: Optional extra payload for the service call. Returns: Tuple of success flag and JSON response payload. Raises: ValueError: If the domain is not allowed. \"\"\" if domain not in self . cache [ \"allowed_domains\" ]: raise ValueError ( f \"Domain does not exist or blacklisted: { domain } \" ) url = f \" { self . base_url } /services/ { domain } / { service } \" payload = { \"entity_id\" : entity_id } if data : payload . update ( data ) try : response = requests . post ( url , headers = self . api_headers , json = payload , timeout = 30 ) status_code = getattr ( response , \"status_code\" , None ) if status_code in { 401 , 403 }: logging . error ( \"Home Assistant authorization failed with status {} .\" , status_code ) raise PermissionError ( \"Home Assistant authorization failed.\" ) response . raise_for_status () logging . info ( \"Service < {} . {} > called on entity < {} > returned ` {} `.\" , domain , service , entity_id , response . text , ) return True , response . json () except requests . exceptions . RequestException as e : logging . error ( \"Unable to call service < {} . {} > on entity < {} >: {} \" , domain , service , entity_id , e ) return False , [] get_state ( action_step : ActionStep | None = None ) -> MockSpeaker Generate response for a given action step based on sensors. Parameters: Name Type Description Default action_step ActionStep | None Action step describing the desired query. None Returns: Type Description MockSpeaker MockSpeaker with the generated response. Raises: Type Description ValueError If action_step is None. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 def get_state ( self , action_step : ActionStep | None = None ) -> MockSpeaker : \"\"\"Generate response for a given action step based on sensors. Args: action_step: Action step describing the desired query. Returns: MockSpeaker with the generated response. Raises: ValueError: If action_step is None. \"\"\" if action_step is None : raise ValueError ( \"Action step cannot be None.\" ) self . update_cache () rag_documents = self . _load_rag_documents ([ \"sensors.json\" ]) system_prompt = ha_render_system_prompt ( name = \"homeassistant-get-state\" ) prompt = self . _create_get_prompt ( system_prompt ) if self . model is None : raise RuntimeError ( \"LLM client not initialized for Home Assistant.\" ) model = self . model chain : Any = prompt | model logging . info ( \"Invoking `get` action chain using ` {} `.\" , self . model_name ) message = chain . invoke ( { \"action_step\" : str ( action_step . tool_input ) . strip (), \"context\" : rag_documents , }, ) cleaned_message = self . _clean_answer ( str ( message . content )) MockSpeaker = get_mock_speaker () return MockSpeaker ( content = cleaned_message ) set_state ( action_step : ActionStep | None = None ) -> MockSpeaker Predict and call a service for a given action step. Parameters: Name Type Description Default action_step ActionStep | None Action step describing the desired change. None Returns: Type Description MockSpeaker MockSpeaker with a status message. Raises: Type Description ValueError If action_step is None. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 def set_state ( self , action_step : ActionStep | None = None ) -> MockSpeaker : \"\"\"Predict and call a service for a given action step. Args: action_step: Action step describing the desired change. Returns: MockSpeaker with a status message. Raises: ValueError: If action_step is None. \"\"\" if action_step is None : raise ValueError ( \"Action step cannot be None.\" ) self . update_cache () rag_documents = self . _load_rag_documents ([ \"entities.json\" , \"services.json\" ]) system_prompt = ha_render_system_prompt ( name = \"homeassistant-set-state\" , all_entities = self . cache [ \"entity_ids\" ] ) parser = PydanticOutputParser ( pydantic_object = HomeAssistantCall ) # type: ignore[type-var] prompt = self . _create_set_prompt ( system_prompt , parser ) if self . model is None : raise RuntimeError ( \"LLM client not initialized for Home Assistant.\" ) model = self . model chain : Any = prompt | model | parser logging . info ( \"Invoking `set` action chain using ` {} ` for ` {} `.\" , self . model_name , action_step ) # TODO: Interpret the response from call service. return self . _invoke_service_and_set_state ( chain , rag_documents , action_step ) update_cache () -> None Update the entire cache. Raises: Type Description ValueError If entity IDs cannot be derived. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 380 381 382 383 384 385 386 387 388 389 390 @cache_monitor def update_cache ( self ) -> None : \"\"\"Update the entire cache. Raises: ValueError: If entity IDs cannot be derived. \"\"\" self . update_entity_ids () self . update_services () self . _save_json ( self . cache [ \"entities\" ], \"entities.json\" ) self . _save_json ( self . cache [ \"sensors\" ], \"sensors.json\" ) update_entities () -> bool Update the list of entities from Home Assistant. Returns: Type Description bool True when entities are fetched successfully. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 @cache_monitor def update_entities ( self ) -> bool : \"\"\"Update the list of entities from Home Assistant. Returns: True when entities are fetched successfully. \"\"\" url = f \" { self . base_url } /states\" try : response = requests . get ( url , headers = self . api_headers , timeout = 30 ) status_code = getattr ( response , \"status_code\" , None ) if status_code in { 401 , 403 }: logging . error ( \"Home Assistant authorization failed with status {} .\" , status_code ) raise PermissionError ( \"Home Assistant authorization failed.\" ) response . raise_for_status () self . cache [ \"entities\" ] = response . json () return True except requests . exceptions . RequestException as e : logging . error ( \"Error: {} \" , e ) return False update_entity_ids () -> bool Update the list of entity IDs from Home Assistant. Returns: Type Description bool True when entity IDs are populated. Raises: Type Description ValueError If no entities are available for ID extraction. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 @cache_monitor def update_entity_ids ( self ) -> bool : \"\"\"Update the list of entity IDs from Home Assistant. Returns: True when entity IDs are populated. Raises: ValueError: If no entities are available for ID extraction. \"\"\" # TODO: Always assumes blacklist by default due to cache_monitor. self . update_entities () entities = self . cache [ \"entities\" ] if not entities : raise ValueError ( \"No entities found while updating entity IDs.\" ) self . cache [ \"entity_ids\" ] = [ entity [ \"entity_id\" ] for entity in entities ] logging . info ( \"Entity IDs updated.\" ) return True update_services () -> bool Update the list of services from Home Assistant. Returns: Type Description bool True when services are fetched successfully. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 @cache_monitor def update_services ( self ) -> bool : \"\"\"Update the list of services from Home Assistant. Returns: True when services are fetched successfully. \"\"\" url = f \" { self . base_url } /services\" try : response = requests . get ( url , headers = self . api_headers , timeout = 30 ) status_code = getattr ( response , \"status_code\" , None ) if status_code in { 401 , 403 }: logging . error ( \"Home Assistant authorization failed with status {} .\" , status_code ) raise PermissionError ( \"Home Assistant authorization failed.\" ) response . raise_for_status () self . cache [ \"services\" ] = response . json () self . _save_json ( self . cache [ \"services\" ], \"services.json\" ) return True except requests . exceptions . RequestException as e : logging . error ( \"Error: {} \" , e ) return False HomeAssistantCache Bases: TypedDict Cached Home Assistant entity and service metadata. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 33 34 35 36 37 38 39 40 41 42 class HomeAssistantCache ( TypedDict ): \"\"\"Cached Home Assistant entity and service metadata.\"\"\" entity_ids : list [ str ] sensor_ids : list [ str ] entities : list [ dict [ str , Any ]] services : list [ dict [ str , Any ]] sensors : list [ dict [ str , Any ]] allowed_domains : list [ str ] sensor : NotRequired [ list [ dict [ str , Any ]]] HomeAssistantCall Bases: BaseModel Structured Home Assistant service call extracted from the model output. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 class HomeAssistantCall ( BaseModel ): \"\"\"Structured Home Assistant service call extracted from the model output.\"\"\" cache : CacheHolder | None = Field ( alias = \"_ha_cache\" , default = None ) domain : str = Field ( description = ( \"The category of the service to call, such as 'light', 'switch', or 'scene'.\" ) ) service : str = Field ( description = ( \"The specific action to perform within the domain, such as 'turn_on', \" \"'turn_off', or 'set_temperature'.\" ) ) entity_id : str = Field ( description = ( \"The ID of the specific device or entity within the domain to apply the \" \"service to, such as 'scene.heater'.\" ) ) @validator ( \"entity_id\" , allow_reuse = True ) # pylint: disable=E0213,W0613 def validate_entity_id ( cls , entity_id : str , values : dict [ str , Any ], ** kwargs : Any ) -> str : \"\"\"Validate the entity_id against the cache when available. Args: cls: Pydantic model class. entity_id: Candidate entity identifier. values: Parsed model values. **kwargs: Additional validator arguments. Returns: Validated entity identifier. Raises: ValueError: If the entity ID is not found in the cache. \"\"\" # ! BUG: The entity_id may not be validated correctly as the cache # ! is not passed to the validator. ha_cache = values . get ( \"ha_cache\" ) if ha_cache and entity_id not in ha_cache . cache [ \"entity_ids\" ]: raise ValueError ( f \"Entity ID ' { entity_id } ' is not in the Home Assistant cache.\" ) return entity_id @validator ( \"domain\" , allow_reuse = True ) # pylint: disable=E0213,W0613 def validate_domain ( cls , domain : str , values : dict [ str , Any ], ** kwargs : Any ) -> str : \"\"\"Validate the domain against the cache when available. Args: cls: Pydantic model class. domain: Domain string to validate. values: Parsed model values. **kwargs: Additional validator arguments. Returns: Validated domain string. Raises: ValueError: If the domain is not found in the cache. \"\"\" # ! BUG: The entity_id may not be validated correctly as the cache # ! is not passed to the validator. ha_cache = values . get ( \"ha_cache\" ) if ha_cache and domain not in ha_cache . cache [ \"allowed_domains\" ]: raise ValueError ( f \"Domain ' { domain } ' is not in the Home Assistant cache.\" ) return domain class Config : \"\"\"Pydantic configuration for HomeAssistantCall.\"\"\" arbitrary_types_allowed = True Config Pydantic configuration for HomeAssistantCall. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 284 285 286 287 class Config : \"\"\"Pydantic configuration for HomeAssistantCall.\"\"\" arbitrary_types_allowed = True validate_domain ( domain : str , values : dict [ str , Any ], ** kwargs : Any ) -> str Validate the domain against the cache when available. Parameters: Name Type Description Default cls Pydantic model class. required domain str Domain string to validate. required values dict [ str , Any ] Parsed model values. required **kwargs Any Additional validator arguments. {} Returns: Type Description str Validated domain string. Raises: Type Description ValueError If the domain is not found in the cache. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 @validator ( \"domain\" , allow_reuse = True ) # pylint: disable=E0213,W0613 def validate_domain ( cls , domain : str , values : dict [ str , Any ], ** kwargs : Any ) -> str : \"\"\"Validate the domain against the cache when available. Args: cls: Pydantic model class. domain: Domain string to validate. values: Parsed model values. **kwargs: Additional validator arguments. Returns: Validated domain string. Raises: ValueError: If the domain is not found in the cache. \"\"\" # ! BUG: The entity_id may not be validated correctly as the cache # ! is not passed to the validator. ha_cache = values . get ( \"ha_cache\" ) if ha_cache and domain not in ha_cache . cache [ \"allowed_domains\" ]: raise ValueError ( f \"Domain ' { domain } ' is not in the Home Assistant cache.\" ) return domain validate_entity_id ( entity_id : str , values : dict [ str , Any ], ** kwargs : Any ) -> str Validate the entity_id against the cache when available. Parameters: Name Type Description Default cls Pydantic model class. required entity_id str Candidate entity identifier. required values dict [ str , Any ] Parsed model values. required **kwargs Any Additional validator arguments. {} Returns: Type Description str Validated entity identifier. Raises: Type Description ValueError If the entity ID is not found in the cache. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 @validator ( \"entity_id\" , allow_reuse = True ) # pylint: disable=E0213,W0613 def validate_entity_id ( cls , entity_id : str , values : dict [ str , Any ], ** kwargs : Any ) -> str : \"\"\"Validate the entity_id against the cache when available. Args: cls: Pydantic model class. entity_id: Candidate entity identifier. values: Parsed model values. **kwargs: Additional validator arguments. Returns: Validated entity identifier. Raises: ValueError: If the entity ID is not found in the cache. \"\"\" # ! BUG: The entity_id may not be validated correctly as the cache # ! is not passed to the validator. ha_cache = values . get ( \"ha_cache\" ) if ha_cache and entity_id not in ha_cache . cache [ \"entity_ids\" ]: raise ValueError ( f \"Entity ID ' { entity_id } ' is not in the Home Assistant cache.\" ) return entity_id SupportsInvoke Bases: Protocol Protocol for runnable chains that return HomeAssistantCall. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 56 57 58 59 60 61 62 63 64 65 66 67 68 class SupportsInvoke ( Protocol ): \"\"\"Protocol for runnable chains that return HomeAssistantCall.\"\"\" def invoke ( self , input_data : dict [ str , Any ]) -> HomeAssistantCall : \"\"\"Invoke the chain with structured input. Args: input_data: Input payload for the chain. Returns: Parsed HomeAssistantCall. \"\"\" ... invoke ( input_data : dict [ str , Any ]) -> HomeAssistantCall Invoke the chain with structured input. Parameters: Name Type Description Default input_data dict [ str , Any ] Input payload for the chain. required Returns: Type Description HomeAssistantCall Parsed HomeAssistantCall. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 59 60 61 62 63 64 65 66 67 68 def invoke ( self , input_data : dict [ str , Any ]) -> HomeAssistantCall : \"\"\"Invoke the chain with structured input. Args: input_data: Input payload for the chain. Returns: Parsed HomeAssistantCall. \"\"\" ... cache_monitor ( func : Callable [ Concatenate [ SelfT , P ], R ]) -> Callable [ Concatenate [ SelfT , P ], R ] Decorator to monitor and update the cache. Parameters: Name Type Description Default func Callable [ Concatenate [ SelfT , P ], R ] Method that updates a portion of the cache. required Returns: Type Description Callable [ Concatenate [ SelfT , P ], R ] Wrapped function that normalizes cache contents after execution. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 def cache_monitor ( func : Callable [ Concatenate [ SelfT , P ], R ]) -> Callable [ Concatenate [ SelfT , P ], R ]: \"\"\"Decorator to monitor and update the cache. Args: func: Method that updates a portion of the cache. Returns: Wrapped function that normalizes cache contents after execution. \"\"\" def sort_by_entity_id ( dict_list : list [ dict [ str , Any ]]) -> list [ dict [ str , Any ]]: \"\"\"Sort a list of entities by the entity_id field. Args: dict_list: List of entity dictionaries. Returns: Sorted list of entities. \"\"\" return sorted ( dict_list , key = lambda x : x [ \"entity_id\" ]) def clean_entities ( self : CacheHolder , forbidden_prefixes : list [ str ], forbidden_substrings : list [ str ], ) -> HomeAssistantCache : \"\"\"Filter and normalize entities while populating sensors. Args: self: Cache holder to mutate. forbidden_prefixes: Entity ID prefixes to exclude. forbidden_substrings: Entity ID substrings to exclude. Returns: Updated HomeAssistantCache payload. \"\"\" for idx , entity in enumerate ( self . cache [ \"entities\" ]): if \"context\" in entity : self . cache [ \"entities\" ][ idx ] . pop ( \"context\" ) self . cache [ \"entities\" ][ idx ] . pop ( \"last_changed\" ) self . cache [ \"entities\" ][ idx ] . pop ( \"last_reported\" ) self . cache [ \"entities\" ][ idx ] . pop ( \"last_updated\" ) if \"attributes\" in entity : self . cache [ \"entities\" ][ idx ][ \"attributes\" ] . pop ( \"icon\" , None ) self . cache [ \"entities\" ][ idx ][ \"attributes\" ] . pop ( \"monitor_cert_days_remaining\" , None ) self . cache [ \"entities\" ][ idx ][ \"attributes\" ] . pop ( \"monitor_cert_is_valid\" , None ) self . cache [ \"entities\" ][ idx ][ \"attributes\" ] . pop ( \"monitor_hostname\" , None ) self . cache [ \"entities\" ][ idx ][ \"attributes\" ] . pop ( \"monitor_port\" , None ) if any ( entity [ \"entity_id\" ] . startswith ( prefix ) for prefix in forbidden_prefixes ): self . cache [ \"entities\" ] . remove ( entity ) if any ( substring in entity [ \"entity_id\" ] for substring in forbidden_substrings ): self . cache [ \"entities\" ] . remove ( entity ) if entity [ \"entity_id\" ] . startswith ( \"scene.\" ): self . cache [ \"entities\" ][ idx ] . pop ( \"state\" , None ) if entity [ \"entity_id\" ] . startswith ( \"sensor.\" ) or entity [ \"entity_id\" ] . startswith ( \"binary_sensor.\" ): self . cache [ \"sensors\" ] . append ( entity ) self . cache [ \"entities\" ] . pop ( idx ) self . cache [ \"entities\" ] = sort_by_entity_id ( self . cache [ \"entities\" ]) self . cache [ \"sensors\" ] = sort_by_entity_id ( self . cache [ \"sensors\" ]) return self . cache def wrapper ( self : SelfT , * args : P . args , ** kwargs : P . kwargs ) -> R : \"\"\"Invoke the wrapped function and normalize cache content. Args: self: Cache holder instance. *args: Positional arguments forwarded to the wrapped function. **kwargs: Keyword arguments forwarded to the wrapped function. Returns: Result of the wrapped function. \"\"\" result = func ( self , * args , ** kwargs ) forbidden_prefixes = [ \"alarm_control_panel.\" , \"automation.\" , \"binary_sensor.remote_ui\" , \"camera.\" , \"climate\" , \"conversation\" , \"device_tracker.kraken_raspberry_pi_5\" , \"media_player.axios\" , \"media_player.axios_2\" , \"media_player.chrome\" , \"media_player.fire_tv_192_168_1_12\" , \"person.\" , \"remote.\" , \"script.higher\" , \"sensor.hacs\" , \"sensor.hacs\" , \"sensor.kraken_raspberry_pi_5_\" , \"sensor.sonarr_commands\" , \"sensor.sun\" , \"sensor.uptimekuma_\" , \"stt.\" , \"sun.\" , \"switch.\" , \"switch.adam\" , \"switch.bedroom_camera_camera_motion_detection\" , \"tts.\" , \"update.\" , \"zone.home\" , ] forbidden_substrings = [ \"blink_kk_bedroom\" ] self . cache [ \"sensor\" ] = [] # Clean entities self . cache = clean_entities ( self , forbidden_prefixes , forbidden_substrings ) # Clean services self . cache [ \"services\" ] = [ service for service in self . cache [ \"services\" ] if service [ \"domain\" ] in self . cache [ \"allowed_domains\" ] ] # Retrieve entity and sensor IDs self . cache [ \"entity_ids\" ] = sorted ( self . cache [ \"entity_ids\" ]) self . cache [ \"sensor_ids\" ] = sorted ( self . cache [ \"sensor_ids\" ]) logging . info ( ( \"` {} ` modified cache to <(len) Entity IDs: {} ; (len) Entities: {} ; \" \"(len) Sensors: {} ; (len) Services: {} ;>\" ), func . __name__ , len ( self . cache [ \"entity_ids\" ]), len ( self . cache [ \"entities\" ]), len ( self . cache [ \"sensors\" ]), len ( self . cache [ \"services\" ]), ) return result return wrapper Clients (apps/) API entry point: apps/meeseeks_api/src/meeseeks_api/backend.py Chat entry point: apps/meeseeks_chat/src/meeseeks_chat/chat_master.py CLI entry point: apps/meeseeks_cli/src/meeseeks_cli/cli_master.py Home Assistant integration (meeseeks_ha_conversation) meeseeks_ha_conversation.api Meeseeks API client. MeeseeksApiClient Meeseeks API Client. Source code in meeseeks_ha_conversation/api.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 class MeeseeksApiClient : \"\"\"Meeseeks API Client.\"\"\" def __init__ ( self , base_url : str , timeout : int , session : aiohttp . ClientSession , ) -> None : \"\"\"Initialize the API client. Args: base_url: Base URL for the Meeseeks API. timeout: Request timeout in seconds. session: Shared aiohttp client session. \"\"\" self . _base_url = base_url . rstrip ( \"/\" ) self . _api_key = \"msk-strong-password\" self . timeout = timeout self . _session = session async def async_get_heartbeat ( self ) -> bool : \"\"\"Get heartbeat from the API. Returns: True when the service is considered healthy. \"\"\" # TODO: Implement a heartbeat check return True async def async_get_models ( self ) -> str : \"\"\"Get models from the API. Returns: JSON-serialized model list. \"\"\" # TODO: This is monkey-patched for now response_data : ModelsResponse = { \"models\" : [ { \"name\" : \"meeseeks\" , \"modified_at\" : \"2023-11-01T00:00:00.000000000-04:00\" , \"size\" : 0 , \"digest\" : None , } ] } return json . dumps ( response_data ) async def async_generate ( self , data : dict [ str , Any ] | None = None ) -> MeeseeksQueryResponse : \"\"\"Generate a completion from the API. Args: data: Request payload including prompt and optional session ID. Returns: Parsed query response payload. Raises: ValueError: If prompt data is missing. ApiJsonError: If the API returns unexpected data. \"\"\" if not data or \"prompt\" not in data : raise ValueError ( \"Missing prompt in request data.\" ) url_query = f \" { self . _base_url } /api/query\" data_custom = { \"query\" : str ( data [ \"prompt\" ]) . strip (), } session_id = data . get ( \"session_id\" ) if isinstance ( data , dict ) else None if session_id : data_custom [ \"session_id\" ] = session_id # Pass headers as None to use the default headers result = await self . _meeseeks_api_wrapper ( method = \"post\" , url = url_query , data = data_custom , headers = None , ) if isinstance ( result , str ): raise ApiJsonError ( \"Unexpected text response from Meeseeks API.\" ) return result async def _meeseeks_api_wrapper ( self , method : str , url : str , data : dict [ str , Any ] | None = None , headers : dict [ str , str ] | None = None , decode_json : bool = True , ) -> MeeseeksQueryResponse | str : \"\"\"Perform an HTTP request to the Meeseeks API. Args: method: HTTP method to use. url: Fully qualified request URL. data: Optional JSON payload to send. headers: Optional HTTP headers override. decode_json: Whether to parse JSON responses. Returns: Parsed response payload or raw text depending on decode_json. Raises: ApiJsonError: If the API returns an error payload. aiohttp.ClientResponseError: For non-2xx responses. \"\"\" if headers is None : headers = { \"accept\" : \"application/json\" , \"X-API-KEY\" : self . _api_key , \"Content-Type\" : \"application/json\" , } async with async_timeout . timeout ( self . timeout ): response = await self . _session . request ( method = method , url = url , headers = headers , json = data , ) response . raise_for_status () if decode_json : raw_data : dict [ str , Any ] = await response . json () if response . status == 404 : raise ApiJsonError ( raw_data . get ( \"error\" , \"Unknown error\" )) task_result = str ( raw_data . get ( \"task_result\" , \"\" )) response_data : MeeseeksQueryResponse = { \"task_result\" : task_result , \"response\" : str ( raw_data . get ( \"response\" , task_result )), \"context\" : str ( raw_data . get ( \"context\" , task_result )), \"session_id\" : raw_data . get ( \"session_id\" ), } LOGGER . debug ( \"Response data: %s \" , response_data ) return response_data else : LOGGER . debug ( \"Fallback to text response\" ) return await response . text () __init__ ( base_url : str , timeout : int , session : aiohttp . ClientSession ) -> None Initialize the API client. Parameters: Name Type Description Default base_url str Base URL for the Meeseeks API. required timeout int Request timeout in seconds. required session ClientSession Shared aiohttp client session. required Source code in meeseeks_ha_conversation/api.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def __init__ ( self , base_url : str , timeout : int , session : aiohttp . ClientSession , ) -> None : \"\"\"Initialize the API client. Args: base_url: Base URL for the Meeseeks API. timeout: Request timeout in seconds. session: Shared aiohttp client session. \"\"\" self . _base_url = base_url . rstrip ( \"/\" ) self . _api_key = \"msk-strong-password\" self . timeout = timeout self . _session = session async_generate ( data : dict [ str , Any ] | None = None ) -> MeeseeksQueryResponse async Generate a completion from the API. Parameters: Name Type Description Default data dict [ str , Any ] | None Request payload including prompt and optional session ID. None Returns: Type Description MeeseeksQueryResponse Parsed query response payload. Raises: Type Description ValueError If prompt data is missing. ApiJsonError If the API returns unexpected data. Source code in meeseeks_ha_conversation/api.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 async def async_generate ( self , data : dict [ str , Any ] | None = None ) -> MeeseeksQueryResponse : \"\"\"Generate a completion from the API. Args: data: Request payload including prompt and optional session ID. Returns: Parsed query response payload. Raises: ValueError: If prompt data is missing. ApiJsonError: If the API returns unexpected data. \"\"\" if not data or \"prompt\" not in data : raise ValueError ( \"Missing prompt in request data.\" ) url_query = f \" { self . _base_url } /api/query\" data_custom = { \"query\" : str ( data [ \"prompt\" ]) . strip (), } session_id = data . get ( \"session_id\" ) if isinstance ( data , dict ) else None if session_id : data_custom [ \"session_id\" ] = session_id # Pass headers as None to use the default headers result = await self . _meeseeks_api_wrapper ( method = \"post\" , url = url_query , data = data_custom , headers = None , ) if isinstance ( result , str ): raise ApiJsonError ( \"Unexpected text response from Meeseeks API.\" ) return result async_get_heartbeat () -> bool async Get heartbeat from the API. Returns: Type Description bool True when the service is considered healthy. Source code in meeseeks_ha_conversation/api.py 53 54 55 56 57 58 59 60 async def async_get_heartbeat ( self ) -> bool : \"\"\"Get heartbeat from the API. Returns: True when the service is considered healthy. \"\"\" # TODO: Implement a heartbeat check return True async_get_models () -> str async Get models from the API. Returns: Type Description str JSON-serialized model list. Source code in meeseeks_ha_conversation/api.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 async def async_get_models ( self ) -> str : \"\"\"Get models from the API. Returns: JSON-serialized model list. \"\"\" # TODO: This is monkey-patched for now response_data : ModelsResponse = { \"models\" : [ { \"name\" : \"meeseeks\" , \"modified_at\" : \"2023-11-01T00:00:00.000000000-04:00\" , \"size\" : 0 , \"digest\" : None , } ] } return json . dumps ( response_data ) MeeseeksQueryResponse Bases: TypedDict Schema for the main query response. Source code in meeseeks_ha_conversation/api.py 23 24 25 26 27 28 29 class MeeseeksQueryResponse ( TypedDict ): \"\"\"Schema for the main query response.\"\"\" task_result : str response : str context : str session_id : str | None ModelsResponse Bases: TypedDict Schema for the models list endpoint response. Source code in meeseeks_ha_conversation/api.py 17 18 19 20 class ModelsResponse ( TypedDict ): \"\"\"Schema for the models list endpoint response.\"\"\" models : list [ dict [ str , Any ]] meeseeks_ha_conversation.config_flow Adds config flow for Meeseeks. MeeseeksConfigFlow Bases: ConfigFlow Handle a config flow for Meeseeks Conversation. Handles UI wizard. Source code in meeseeks_ha_conversation/config_flow.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 class MeeseeksConfigFlow ( config_entries . ConfigFlow , domain = DOMAIN ): # type: ignore[call-arg] \"\"\"Handle a config flow for Meeseeks Conversation. Handles UI wizard.\"\"\" VERSION = 1 client : MeeseeksApiClient async def async_step_user ( self , user_input : dict [ str , Any ] | None = None ) -> FlowResult : \"\"\"Handle the initial config flow step. Args: user_input: Submitted form data, if available. Returns: FlowResult for the configuration step. \"\"\" if user_input is None : return self . async_show_form ( step_id = \"user\" , data_schema = STEP_USER_DATA_SCHEMA ) # Search for duplicates with the same CONF_BASE_URL value. for existing_entry in self . _async_current_entries ( include_ignore = False ): if existing_entry . data . get ( CONF_BASE_URL ) == user_input [ CONF_BASE_URL ]: return self . async_abort ( reason = \"already_configured\" ) errors : dict [ str , str ] = {} try : self . client = MeeseeksApiClient ( base_url = cv . url_no_path ( user_input [ CONF_BASE_URL ]), timeout = user_input [ CONF_TIMEOUT ], session = async_create_clientsession ( self . hass ), ) response = await self . client . async_get_heartbeat () if not response : raise vol . Invalid ( \"Invalid Meeseeks server\" ) # except vol.Invalid: # errors[\"base\"] = \"invalid_url\" # except ApiTimeoutError: # errors[\"base\"] = \"timeout_connect\" # except ApiCommError: # errors[\"base\"] = \"cannot_connect\" # except ApiClientError as exception: # LOGGER.exception(\"Unexpected exception: %s\", exception) # errors[\"base\"] = \"unknown\" except Exception as exception : LOGGER . exception ( \"Unexpected exception: %s \" , exception ) errors [ \"base\" ] = \"unknown\" else : return self . async_create_entry ( title = f \"Meeseeks - { user_input [ CONF_BASE_URL ] } \" , data = { CONF_BASE_URL : user_input [ CONF_BASE_URL ]}, options = { CONF_TIMEOUT : user_input [ CONF_TIMEOUT ]}, ) return self . async_show_form ( step_id = \"user\" , data_schema = STEP_USER_DATA_SCHEMA , errors = errors ) @staticmethod def async_get_options_flow ( config_entry : config_entries . ConfigEntry , ) -> config_entries . OptionsFlow : \"\"\"Create the options flow. Args: config_entry: Existing config entry to edit. Returns: Options flow handler. \"\"\" return MeeseeksOptionsFlow ( config_entry ) async_get_options_flow ( config_entry : config_entries . ConfigEntry ) -> config_entries . OptionsFlow staticmethod Create the options flow. Parameters: Name Type Description Default config_entry ConfigEntry Existing config entry to edit. required Returns: Type Description OptionsFlow Options flow handler. Source code in meeseeks_ha_conversation/config_flow.py 108 109 110 111 112 113 114 115 116 117 118 119 120 @staticmethod def async_get_options_flow ( config_entry : config_entries . ConfigEntry , ) -> config_entries . OptionsFlow : \"\"\"Create the options flow. Args: config_entry: Existing config entry to edit. Returns: Options flow handler. \"\"\" return MeeseeksOptionsFlow ( config_entry ) async_step_user ( user_input : dict [ str , Any ] | None = None ) -> FlowResult async Handle the initial config flow step. Parameters: Name Type Description Default user_input dict [ str , Any ] | None Submitted form data, if available. None Returns: Type Description FlowResult FlowResult for the configuration step. Source code in meeseeks_ha_conversation/config_flow.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 async def async_step_user ( self , user_input : dict [ str , Any ] | None = None ) -> FlowResult : \"\"\"Handle the initial config flow step. Args: user_input: Submitted form data, if available. Returns: FlowResult for the configuration step. \"\"\" if user_input is None : return self . async_show_form ( step_id = \"user\" , data_schema = STEP_USER_DATA_SCHEMA ) # Search for duplicates with the same CONF_BASE_URL value. for existing_entry in self . _async_current_entries ( include_ignore = False ): if existing_entry . data . get ( CONF_BASE_URL ) == user_input [ CONF_BASE_URL ]: return self . async_abort ( reason = \"already_configured\" ) errors : dict [ str , str ] = {} try : self . client = MeeseeksApiClient ( base_url = cv . url_no_path ( user_input [ CONF_BASE_URL ]), timeout = user_input [ CONF_TIMEOUT ], session = async_create_clientsession ( self . hass ), ) response = await self . client . async_get_heartbeat () if not response : raise vol . Invalid ( \"Invalid Meeseeks server\" ) # except vol.Invalid: # errors[\"base\"] = \"invalid_url\" # except ApiTimeoutError: # errors[\"base\"] = \"timeout_connect\" # except ApiCommError: # errors[\"base\"] = \"cannot_connect\" # except ApiClientError as exception: # LOGGER.exception(\"Unexpected exception: %s\", exception) # errors[\"base\"] = \"unknown\" except Exception as exception : LOGGER . exception ( \"Unexpected exception: %s \" , exception ) errors [ \"base\" ] = \"unknown\" else : return self . async_create_entry ( title = f \"Meeseeks - { user_input [ CONF_BASE_URL ] } \" , data = { CONF_BASE_URL : user_input [ CONF_BASE_URL ]}, options = { CONF_TIMEOUT : user_input [ CONF_TIMEOUT ]}, ) return self . async_show_form ( step_id = \"user\" , data_schema = STEP_USER_DATA_SCHEMA , errors = errors ) MeeseeksOptionsFlow Bases: OptionsFlow Meeseeks config flow options handler. Source code in meeseeks_ha_conversation/config_flow.py 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 class MeeseeksOptionsFlow ( config_entries . OptionsFlow ): \"\"\"Meeseeks config flow options handler.\"\"\" def __init__ ( self , config_entry : config_entries . ConfigEntry ) -> None : \"\"\"Initialize options flow. Args: config_entry: Config entry to manage. \"\"\" self . config_entry = config_entry self . options = dict ( config_entry . options ) async def async_step_init ( self , user_input : dict [ str , Any ] | None = None ) -> FlowResult : \"\"\"Show the options menu. Args: user_input: Submitted form data, if available. Returns: FlowResult for the options menu. \"\"\" return self . async_show_menu ( step_id = \"init\" , menu_options = MENU_OPTIONS ) async def async_step_all_set ( self , user_input : dict [ str , Any ] | None = None ) -> FlowResult : \"\"\"Handle the \"all_set\" options step. Args: user_input: Submitted form data, if available. Returns: FlowResult for the options menu. \"\"\" return self . async_show_menu ( step_id = \"init\" , menu_options = MENU_OPTIONS ) async def async_step_general_config ( self , user_input : dict [ str , Any ] | None = None ) -> FlowResult : \"\"\"Handle the general configuration step. Args: user_input: Submitted form data, if available. Returns: FlowResult for the options menu. \"\"\" return self . async_show_menu ( step_id = \"init\" , menu_options = MENU_OPTIONS ) async def async_step_prompt_system ( self , user_input : dict [ str , Any ] | None = None ) -> FlowResult : \"\"\"Handle the prompt system configuration step. Args: user_input: Submitted form data, if available. Returns: FlowResult for the options menu. \"\"\" return self . async_show_menu ( step_id = \"init\" , menu_options = MENU_OPTIONS ) async def async_step_model_config ( self , user_input : dict [ str , Any ] | None = None ) -> FlowResult : \"\"\"Handle the model configuration step. Args: user_input: Submitted form data, if available. Returns: FlowResult for the options menu. \"\"\" return self . async_show_menu ( step_id = \"init\" , menu_options = MENU_OPTIONS ) __init__ ( config_entry : config_entries . ConfigEntry ) -> None Initialize options flow. Parameters: Name Type Description Default config_entry ConfigEntry Config entry to manage. required Source code in meeseeks_ha_conversation/config_flow.py 126 127 128 129 130 131 132 133 def __init__ ( self , config_entry : config_entries . ConfigEntry ) -> None : \"\"\"Initialize options flow. Args: config_entry: Config entry to manage. \"\"\" self . config_entry = config_entry self . options = dict ( config_entry . options ) async_step_all_set ( user_input : dict [ str , Any ] | None = None ) -> FlowResult async Handle the \"all_set\" options step. Parameters: Name Type Description Default user_input dict [ str , Any ] | None Submitted form data, if available. None Returns: Type Description FlowResult FlowResult for the options menu. Source code in meeseeks_ha_conversation/config_flow.py 146 147 148 149 150 151 152 153 154 155 async def async_step_all_set ( self , user_input : dict [ str , Any ] | None = None ) -> FlowResult : \"\"\"Handle the \"all_set\" options step. Args: user_input: Submitted form data, if available. Returns: FlowResult for the options menu. \"\"\" return self . async_show_menu ( step_id = \"init\" , menu_options = MENU_OPTIONS ) async_step_general_config ( user_input : dict [ str , Any ] | None = None ) -> FlowResult async Handle the general configuration step. Parameters: Name Type Description Default user_input dict [ str , Any ] | None Submitted form data, if available. None Returns: Type Description FlowResult FlowResult for the options menu. Source code in meeseeks_ha_conversation/config_flow.py 157 158 159 160 161 162 163 164 165 166 167 168 async def async_step_general_config ( self , user_input : dict [ str , Any ] | None = None ) -> FlowResult : \"\"\"Handle the general configuration step. Args: user_input: Submitted form data, if available. Returns: FlowResult for the options menu. \"\"\" return self . async_show_menu ( step_id = \"init\" , menu_options = MENU_OPTIONS ) async_step_init ( user_input : dict [ str , Any ] | None = None ) -> FlowResult async Show the options menu. Parameters: Name Type Description Default user_input dict [ str , Any ] | None Submitted form data, if available. None Returns: Type Description FlowResult FlowResult for the options menu. Source code in meeseeks_ha_conversation/config_flow.py 135 136 137 138 139 140 141 142 143 144 async def async_step_init ( self , user_input : dict [ str , Any ] | None = None ) -> FlowResult : \"\"\"Show the options menu. Args: user_input: Submitted form data, if available. Returns: FlowResult for the options menu. \"\"\" return self . async_show_menu ( step_id = \"init\" , menu_options = MENU_OPTIONS ) async_step_model_config ( user_input : dict [ str , Any ] | None = None ) -> FlowResult async Handle the model configuration step. Parameters: Name Type Description Default user_input dict [ str , Any ] | None Submitted form data, if available. None Returns: Type Description FlowResult FlowResult for the options menu. Source code in meeseeks_ha_conversation/config_flow.py 183 184 185 186 187 188 189 190 191 192 async def async_step_model_config ( self , user_input : dict [ str , Any ] | None = None ) -> FlowResult : \"\"\"Handle the model configuration step. Args: user_input: Submitted form data, if available. Returns: FlowResult for the options menu. \"\"\" return self . async_show_menu ( step_id = \"init\" , menu_options = MENU_OPTIONS ) async_step_prompt_system ( user_input : dict [ str , Any ] | None = None ) -> FlowResult async Handle the prompt system configuration step. Parameters: Name Type Description Default user_input dict [ str , Any ] | None Submitted form data, if available. None Returns: Type Description FlowResult FlowResult for the options menu. Source code in meeseeks_ha_conversation/config_flow.py 170 171 172 173 174 175 176 177 178 179 180 181 async def async_step_prompt_system ( self , user_input : dict [ str , Any ] | None = None ) -> FlowResult : \"\"\"Handle the prompt system configuration step. Args: user_input: Submitted form data, if available. Returns: FlowResult for the options menu. \"\"\" return self . async_show_menu ( step_id = \"init\" , menu_options = MENU_OPTIONS ) meeseeks_ha_conversation.const Constants for meeseeks_conversation. meeseeks_ha_conversation.coordinator DataUpdateCoordinator for meeseeks_conversation. MeeseeksDataUpdateCoordinator Bases: DataUpdateCoordinator Class to manage fetching data from the API. Source code in meeseeks_ha_conversation/coordinator.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 class MeeseeksDataUpdateCoordinator ( DataUpdateCoordinator ): \"\"\"Class to manage fetching data from the API.\"\"\" config_entry : ConfigEntry def __init__ ( self , hass : HomeAssistant , client : MeeseeksApiClient , ) -> None : \"\"\"Initialize the coordinator. Args: hass: Home Assistant core instance. client: API client for Meeseeks. \"\"\" self . client = client super () . __init__ ( hass = hass , logger = LOGGER , name = DOMAIN , update_interval = timedelta ( minutes = 5 ), ) async def _async_update_data ( self ) -> bool : \"\"\"Update data via library. Returns: True when the heartbeat check succeeds. Raises: UpdateFailed: If the API heartbeat fails. \"\"\" try : return await self . client . async_get_heartbeat () except ApiClientError as exception : raise UpdateFailed ( exception ) from exception __init__ ( hass : HomeAssistant , client : MeeseeksApiClient ) -> None Initialize the coordinator. Parameters: Name Type Description Default hass HomeAssistant Home Assistant core instance. required client MeeseeksApiClient API client for Meeseeks. required Source code in meeseeks_ha_conversation/coordinator.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def __init__ ( self , hass : HomeAssistant , client : MeeseeksApiClient , ) -> None : \"\"\"Initialize the coordinator. Args: hass: Home Assistant core instance. client: API client for Meeseeks. \"\"\" self . client = client super () . __init__ ( hass = hass , logger = LOGGER , name = DOMAIN , update_interval = timedelta ( minutes = 5 ), ) meeseeks_ha_conversation.exceptions The exceptions used by Extended OpenAI Conversation. ApiClientError Bases: HomeAssistantError Exception to indicate a general API error. Source code in meeseeks_ha_conversation/exceptions.py 6 7 class ApiClientError ( HomeAssistantError ): \"\"\"Exception to indicate a general API error.\"\"\" ApiCommError Bases: ApiClientError Exception to indicate a communication error. Source code in meeseeks_ha_conversation/exceptions.py 10 11 class ApiCommError ( ApiClientError ): \"\"\"Exception to indicate a communication error.\"\"\" ApiJsonError Bases: ApiClientError Exception to indicate an error with json response. Source code in meeseeks_ha_conversation/exceptions.py 14 15 class ApiJsonError ( ApiClientError ): \"\"\"Exception to indicate an error with json response.\"\"\" ApiTimeoutError Bases: ApiClientError Exception to indicate a timeout error. Source code in meeseeks_ha_conversation/exceptions.py 18 19 class ApiTimeoutError ( ApiClientError ): \"\"\"Exception to indicate a timeout error.\"\"\" meeseeks_ha_conversation.helpers Helper functions for Meeseeks. ExposedEntity Bases: TypedDict Typed representation of a Home Assistant entity exposed to conversation. Source code in meeseeks_ha_conversation/helpers.py 13 14 15 16 17 18 19 class ExposedEntity ( TypedDict ): \"\"\"Typed representation of a Home Assistant entity exposed to conversation.\"\"\" entity_id : str name : str state : str aliases : list [ str ] get_exposed_entities ( hass : HomeAssistant ) -> list [ ExposedEntity ] Return exposed entities. Parameters: Name Type Description Default hass HomeAssistant Home Assistant core instance. required Returns: Type Description list [ ExposedEntity ] List of exposed entities and their metadata. Source code in meeseeks_ha_conversation/helpers.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 def get_exposed_entities ( hass : HomeAssistant ) -> list [ ExposedEntity ]: \"\"\"Return exposed entities. Args: hass: Home Assistant core instance. Returns: List of exposed entities and their metadata. \"\"\" hass_entity = entity_registry . async_get ( hass ) exposed_entities : list [ ExposedEntity ] = [] for state in hass . states . async_all (): if async_should_expose ( hass , CONVERSATION_DOMAIN , state . entity_id ): entity = hass_entity . async_get ( state . entity_id ) exposed_entities . append ( { \"entity_id\" : state . entity_id , \"name\" : state . name , \"state\" : state . state , \"aliases\" : entity . aliases if entity else [], } ) return exposed_entities","title":"Reference"},{"location":"reference/#packagesmeeseeks_core-core-runtime","text":"","title":"packages/meeseeks_core (core runtime)"},{"location":"reference/#meeseeks_core.orchestrator","text":"Session orchestration entrypoint.","title":"orchestrator"},{"location":"reference/#meeseeks_core.orchestrator.Orchestrator","text":"Plan-act-observe orchestration loop. Source code in packages/meeseeks_core/src/meeseeks_core/orchestrator.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 class Orchestrator : \"\"\"Plan-act-observe orchestration loop.\"\"\" def __init__ ( self , * , model_name : str | None = None , session_store : SessionStore | None = None , tool_registry : ToolRegistry | None = None , permission_policy : PermissionPolicy | None = None , approval_callback : Callable [[ ActionStep ], bool ] | None = None , hook_manager : HookManager | None = None , ) -> None : \"\"\"Initialize orchestration dependencies.\"\"\" self . _model_name = ( model_name or get_config_value ( \"llm\" , \"action_plan_model\" ) or get_config_value ( \"llm\" , \"default_model\" , default = \"gpt-5.2\" ) ) self . _session_store = session_store or SessionStore () self . _tool_registry = tool_registry or load_registry () self . _permission_policy = permission_policy or load_permission_policy () self . _approval_callback = approval_callback or approval_callback_from_config () self . _hook_manager = hook_manager or default_hook_manager () self . _context_builder = ContextBuilder ( self . _session_store ) self . _planner = Planner ( self . _tool_registry ) self . _tool_selector = ToolSelector ( self . _tool_registry ) self . _step_executor = StepExecutor ( self . _tool_registry ) self . _plan_updater = PlanUpdater ( self . _tool_registry ) self . _synthesizer = ResponseSynthesizer ( self . _tool_registry ) def run ( self , user_query : str , * , max_iters : int = 3 , initial_plan : Plan | None = None , return_state : bool = False , session_id : str | None = None , mode : str | None = None , should_cancel : Callable [[], bool ] | None = None , ) -> TaskQueue | tuple [ TaskQueue , OrchestrationState ]: \"\"\"Run a plan-act-observe loop for a session.\"\"\" if session_id is None : session_id = self . _session_store . create_session () with session_log_context ( session_id ): with langfuse_session_context ( session_id ): return self . _run_with_session_context ( user_query , max_iters = max_iters , initial_plan = initial_plan , return_state = return_state , session_id = session_id , mode = mode , should_cancel = should_cancel , ) def _run_with_session_context ( self , user_query : str , * , max_iters : int , initial_plan : Plan | None , return_state : bool , session_id : str , mode : str | None , should_cancel : Callable [[], bool ] | None , ) -> TaskQueue | tuple [ TaskQueue , OrchestrationState ]: \"\"\"Run orchestration with Langfuse session context set.\"\"\" state = OrchestrationState ( goal = user_query , session_id = session_id ) resolved_mode = self . _resolve_mode ( user_query , mode ) state . summary = self . _session_store . load_summary ( session_id ) state . tool_results = state . tool_results or [] state . open_questions = state . open_questions or [] task_queue : TaskQueue | None = None try : self . _session_store . append_event ( session_id , { \"type\" : \"user\" , \"payload\" : { \"text\" : user_query }} ) if self . _should_update_summary ( user_query ): state . summary = self . _update_summary_with_memory ( session_id , user_query . strip (), ) updated_summary = self . _maybe_auto_compact ( session_id ) if updated_summary : state . summary = updated_summary if user_query . strip () == \"/compact\" : summary = summarize_events ( self . _session_store . load_transcript ( session_id )) self . _session_store . save_summary ( session_id , summary ) state . summary = summary state . done = True state . done_reason = \"compacted\" task_queue = self . _build_direct_response ( f \"Compaction complete. Summary: { summary } \" ) return ( task_queue , state ) if return_state else task_queue context = self . _context_builder . build ( session_id = session_id , user_query = user_query , model_name = self . _model_name , ) plan = initial_plan tool_specs = ( self . _tool_registry . list_specs () if resolved_mode == \"plan\" else self . _tool_registry . list_specs_for_mode ( \"act\" ) ) if plan is None : if resolved_mode != \"plan\" : selection = self . _tool_selector . select ( user_query , self . _model_name , tool_specs = tool_specs , context = context , ) if selection . tool_required and selection . tool_ids : selected_ids = self . _expand_tool_ids ( set ( selection . tool_ids ), tool_specs ) tool_specs = [ spec for spec in tool_specs if spec . tool_id in selected_ids ] plan = self . _planner . generate ( user_query , self . _model_name , context = context , tool_specs = tool_specs , mode = resolved_mode , ) if resolved_mode != \"plan\" and plan and self . _plan_needs_verification ( plan ): tool_specs = self . _ensure_web_verification_tools ( tool_specs , self . _tool_registry . list_specs_for_mode ( \"act\" ), ) state . plan = plan . steps self . _append_action_plan ( session_id , plan . steps ) task_queue = TaskQueue ( plan_steps = plan . steps , action_steps = []) tool_outputs : list [ str ] = [] executed_steps : list [ ActionStep ] = [] completed_steps : list [ PlanStep ] = [] remaining_steps : list [ PlanStep ] = list ( plan . steps ) last_error : str | None = None direct_response : str | None = None if resolved_mode == \"plan\" : state . done = True state . done_reason = \"planned\" else : max_steps = max ( 0 , max_iters ) * 5 steps_run = 0 allowed_tool_ids = { spec . tool_id for spec in tool_specs } while remaining_steps and steps_run < max_steps : if should_cancel is not None and should_cancel (): state . done = True state . done_reason = \"canceled\" break current_step = remaining_steps . pop ( 0 ) decision = self . _step_executor . decide ( user_query , current_step , self . _model_name , allowed_tools = tool_specs , context = context , ) decision_type = ( decision . decision or \"\" ) . strip () . lower () if decision_type == \"respond\" : if decision . response : direct_response = decision . response tool_outputs . append ( decision . response ) else : last_error = \"Step executor returned an empty response.\" tool_outputs . append ( f \"ERROR: { last_error } \" ) completed_steps . append ( current_step ) steps_run += 1 state . done = True state . done_reason = \"completed\" if direct_response else \"incomplete\" break elif decision_type == \"tool\" : tool_id = str ( decision . tool_id or \"\" ) . strip () if not tool_id or tool_id not in allowed_tool_ids : last_error = f \"Tool ' { tool_id or 'unknown' } ' not allowed for this step.\" tool_outputs . append ( f \"ERROR: { last_error } \" ) else : args = decision . args if args is None : args = \"\" elif not isinstance ( args , ( dict , str )): args = str ( args ) action_step = self . _build_action_step ( current_step , tool_id , args , ) run_queue = TaskQueue ( plan_steps = plan . steps , action_steps = [ action_step ]) run_queue = self . _run_action_plan ( session_id , run_queue , mode = resolved_mode , should_cancel = should_cancel , ) executed_steps . extend ( run_queue . action_steps ) if run_queue . task_result : tool_outputs . append ( run_queue . task_result ) if run_queue . last_error : last_error = run_queue . last_error else : last_error = f \"Invalid step decision: { decision . decision } \" tool_outputs . append ( f \"ERROR: { last_error } \" ) completed_steps . append ( current_step ) steps_run += 1 if should_cancel is not None and should_cancel (): state . done = True state . done_reason = \"canceled\" break if remaining_steps : remaining_steps = self . _plan_updater . update ( user_query , self . _model_name , completed_step = current_step , last_result = tool_outputs [ - 1 ] if tool_outputs else None , remaining_steps = remaining_steps , context = context , ) state . plan = completed_steps + remaining_steps self . _append_action_plan ( session_id , state . plan ) if not state . done : if remaining_steps and steps_run >= max_steps : state . done_reason = \"max_steps_reached\" elif last_error : state . done_reason = ( \"blocked\" if \"permission denied\" in last_error . lower () else \"incomplete\" ) else : state . done_reason = \"completed\" state . done = True task_queue . plan_steps = completed_steps + remaining_steps task_queue . action_steps = executed_steps task_queue . task_result = \" \\n \" . join ( item for item in tool_outputs if item ) . strip () task_queue . last_error = last_error state . tool_results . extend ( tool_outputs ) if direct_response is not None and resolved_mode != \"plan\" and state . done : task_queue . task_result = direct_response self . _session_store . append_event ( session_id , { \"type\" : \"assistant\" , \"payload\" : { \"text\" : direct_response }} ) elif ( state . done and resolved_mode != \"plan\" and self . _should_synthesize_response ( task_queue ) ): tool_outputs = tool_outputs or self . _collect_tool_outputs ( task_queue ) response = self . _synthesizer . synthesize ( user_query = user_query , tool_outputs = tool_outputs , model_name = self . _model_name , context = context , ) task_queue . task_result = response self . _session_store . append_event ( session_id , { \"type\" : \"assistant\" , \"payload\" : { \"text\" : response }} ) if not state . done : # pragma: no cover - defensive guard state . done_reason = \"max_iterations_reached\" completion_payload = { \"done\" : state . done , \"done_reason\" : state . done_reason , \"task_result\" : task_queue . task_result , } if task_queue . last_error : completion_payload [ \"error\" ] = task_queue . last_error completion_payload [ \"last_error\" ] = task_queue . last_error self . _session_store . append_event ( session_id , { \"type\" : \"completion\" , \"payload\" : completion_payload }, ) updated_summary = self . _maybe_auto_compact ( session_id ) if updated_summary : state . summary = updated_summary return ( task_queue , state ) if return_state else task_queue except Exception as exc : logging . exception ( \"Orchestration failed for session {} \" , session_id ) if task_queue is None : task_queue = TaskQueue ( _human_message = user_query , action_steps = []) task_queue . last_error = str ( exc ) state . done = True state . done_reason = \"error\" self . _session_store . append_event ( session_id , { \"type\" : \"completion\" , \"payload\" : { \"done\" : True , \"done_reason\" : state . done_reason , \"task_result\" : task_queue . task_result , \"error\" : str ( exc ), \"last_error\" : str ( exc ), }, }, ) return ( task_queue , state ) if return_state else task_queue def _run_action_plan ( self , session_id : str , task_queue : TaskQueue , * , mode : str , should_cancel : Callable [[], bool ] | None = None , ) -> TaskQueue : reflector = StepReflector ( self . _model_name ) allowed_tools = None if mode == \"plan\" : allowed_tools = { spec . tool_id for spec in self . _tool_registry . list_specs_for_mode ( \"plan\" ) } runner = ActionPlanRunner ( tool_registry = self . _tool_registry , permission_policy = self . _permission_policy , approval_callback = self . _approval_callback , hook_manager = self . _hook_manager , reflector = reflector , event_logger = lambda event : self . _session_store . append_event ( session_id , event ), allowed_tool_ids = allowed_tools , mode = mode , should_cancel = should_cancel , ) return runner . run ( task_queue ) def _maybe_auto_compact ( self , session_id : str ) -> str | None : events = self . _session_store . load_transcript ( session_id ) events = self . _hook_manager . run_pre_compact ( events ) summary = self . _session_store . load_summary ( session_id ) budget = get_token_budget ( events , summary , self . _model_name ) if budget . needs_compact or should_compact ( events ): summary = summarize_events ( events ) self . _session_store . save_summary ( session_id , summary ) return summary return None def _append_action_plan ( self , session_id : str , steps : list [ PlanStep ]) -> None : payload_steps = [ self . _serialize_plan_step ( step ) for step in steps ] self . _session_store . append_event ( session_id , { \"type\" : \"action_plan\" , \"payload\" : { \"steps\" : payload_steps }} ) @staticmethod def _serialize_plan_step ( step : PlanStep ) -> dict [ str , str ]: return { \"title\" : step . title , \"description\" : step . description } def _build_action_step ( self , plan_step : PlanStep , tool_id : str , args : object | None , ) -> ActionStep : operation = self . _infer_operation ( tool_id ) return ActionStep ( title = plan_step . title , objective = plan_step . description , tool_id = tool_id , operation = operation , tool_input = args if args is not None else \"\" , ) @staticmethod def _infer_operation ( tool_id : str ) -> str : lowered = tool_id . lower () write_keywords = [ \"set\" , \"edit\" , \"write\" , \"update\" , \"delete\" , \"create\" , \"apply\" , \"add\" , \"remove\" , \"patch\" , \"insert\" , \"append\" , \"replace\" , \"upload\" , \"post\" , \"put\" , ] if any ( keyword in lowered for keyword in write_keywords ): return \"set\" read_keywords = [ \"read\" , \"list\" , \"search\" , \"get\" , \"fetch\" , \"query\" , \"lookup\" , \"web_search\" , \"web_url_read\" , ] if any ( keyword in lowered for keyword in read_keywords ): return \"get\" return \"get\" @staticmethod def _expand_tool_ids ( selected_ids : set [ str ], tool_specs : list [ ToolSpec ]) -> set [ str ]: if not selected_ids : return selected_ids lowered_selected = { tool_id . lower () for tool_id in selected_ids } has_web_search = any ( key in tool_id for tool_id in lowered_selected for key in ( \"internet_search\" , \"web_search\" , \"searxng\" ) ) if has_web_search : for spec in tool_specs : tool_id = spec . tool_id . lower () if \"web_url_read\" in tool_id or \"web_url\" in tool_id or \"web_read\" in tool_id : selected_ids . add ( spec . tool_id ) return selected_ids @staticmethod def _plan_needs_verification ( plan : Plan ) -> bool : keywords = ( \"open\" , \"verify\" , \"read\" , \"source\" , \"citation\" , \"citations\" ) for step in plan . steps : combined = f \" { step . title } { step . description } \" . lower () if any ( keyword in combined for keyword in keywords ): return True return False @staticmethod def _ensure_web_verification_tools ( selected : list [ ToolSpec ], all_specs : list [ ToolSpec ], ) -> list [ ToolSpec ]: existing = { spec . tool_id for spec in selected } needed = [] for spec in all_specs : if spec . tool_id in existing : continue tool_id = spec . tool_id . lower () if ( \"internet_search\" in tool_id or \"web_search\" in tool_id or \"searxng\" in tool_id or \"web_url_read\" in tool_id or \"web_url\" in tool_id or \"web_read\" in tool_id ): needed . append ( spec ) return selected + needed @staticmethod def _should_update_summary ( text : str ) -> bool : lowered = text . lower () keywords = [ \"remember\" , \"note this\" , \"save this\" , \"pin this\" , \"keep this\" , \"magic number\" , \"magic numbers\" , ] return any ( keyword in lowered for keyword in keywords ) def _update_summary_with_memory ( self , session_id : str , text : str ) -> str : summary = self . _session_store . load_summary ( session_id ) or \"\" new_line = f \"Memory: { text } \" lines = [ line for line in summary . splitlines () if line . strip ()] if summary else [] if new_line not in lines : lines . append ( new_line ) updated = \" \\n \" . join ( lines [ - 10 :]) . strip () self . _session_store . save_summary ( session_id , updated ) return updated @staticmethod def _build_direct_response ( message : str ) -> TaskQueue : task_queue = TaskQueue ( action_steps = []) task_queue . task_result = message return task_queue @staticmethod def _collect_tool_outputs ( task_queue : TaskQueue ) -> list [ str ]: outputs : list [ str ] = [] for step in task_queue . action_steps : if step . result is None : continue content = getattr ( step . result , \"content\" , step . result ) outputs . append ( str ( content )) if outputs or not task_queue . last_error : return outputs return [ f \"ERROR: { task_queue . last_error } \" ] @staticmethod def _should_synthesize_response ( task_queue : TaskQueue ) -> bool : if not task_queue . action_steps : return True return bool ( Orchestrator . _collect_tool_outputs ( task_queue )) @staticmethod def _build_revised_query ( user_query : str , task_queue : TaskQueue ) -> str : failure_note = ( f \"Last tool failure: { task_queue . last_error } \\n \" if task_queue . last_error else \"\" ) return ( f \" { user_query } \\n\\n Previous tool results: \\n { task_queue . task_result or '' } \\n \" f \" { failure_note } \" \"Please revise the action plan to resolve remaining tasks.\" ) @staticmethod def _resolve_mode ( user_query : str , mode : str | None ) -> str : if mode in { \"plan\" , \"act\" }: return mode lowered = user_query . strip () . lower () plan_triggers = [ \"make a plan\" , \"create a plan\" , \"draft a plan\" , \"plan the\" , \"plan for\" , \"planning\" , ] if any ( trigger in lowered for trigger in plan_triggers ): return \"plan\" return \"act\" @staticmethod def _should_replan ( task_queue : TaskQueue , iteration : int , max_iters : int , * , mode : str ) -> bool : if iteration >= max_iters - 1 : return False if mode == \"plan\" : return False if task_queue . last_error : lowered = task_queue . last_error . lower () if \"permission denied\" in lowered or \"tool not allowed\" in lowered : return False return True","title":"Orchestrator"},{"location":"reference/#meeseeks_core.orchestrator.Orchestrator.__init__","text":"Initialize orchestration dependencies. Source code in packages/meeseeks_core/src/meeseeks_core/orchestrator.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 def __init__ ( self , * , model_name : str | None = None , session_store : SessionStore | None = None , tool_registry : ToolRegistry | None = None , permission_policy : PermissionPolicy | None = None , approval_callback : Callable [[ ActionStep ], bool ] | None = None , hook_manager : HookManager | None = None , ) -> None : \"\"\"Initialize orchestration dependencies.\"\"\" self . _model_name = ( model_name or get_config_value ( \"llm\" , \"action_plan_model\" ) or get_config_value ( \"llm\" , \"default_model\" , default = \"gpt-5.2\" ) ) self . _session_store = session_store or SessionStore () self . _tool_registry = tool_registry or load_registry () self . _permission_policy = permission_policy or load_permission_policy () self . _approval_callback = approval_callback or approval_callback_from_config () self . _hook_manager = hook_manager or default_hook_manager () self . _context_builder = ContextBuilder ( self . _session_store ) self . _planner = Planner ( self . _tool_registry ) self . _tool_selector = ToolSelector ( self . _tool_registry ) self . _step_executor = StepExecutor ( self . _tool_registry ) self . _plan_updater = PlanUpdater ( self . _tool_registry ) self . _synthesizer = ResponseSynthesizer ( self . _tool_registry )","title":"__init__"},{"location":"reference/#meeseeks_core.orchestrator.Orchestrator.run","text":"Run a plan-act-observe loop for a session. Source code in packages/meeseeks_core/src/meeseeks_core/orchestrator.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 def run ( self , user_query : str , * , max_iters : int = 3 , initial_plan : Plan | None = None , return_state : bool = False , session_id : str | None = None , mode : str | None = None , should_cancel : Callable [[], bool ] | None = None , ) -> TaskQueue | tuple [ TaskQueue , OrchestrationState ]: \"\"\"Run a plan-act-observe loop for a session.\"\"\" if session_id is None : session_id = self . _session_store . create_session () with session_log_context ( session_id ): with langfuse_session_context ( session_id ): return self . _run_with_session_context ( user_query , max_iters = max_iters , initial_plan = initial_plan , return_state = return_state , session_id = session_id , mode = mode , should_cancel = should_cancel , )","title":"run"},{"location":"reference/#meeseeks_core.task_master","text":"Task planning and orchestration loop for Meeseeks.","title":"task_master"},{"location":"reference/#meeseeks_core.task_master.generate_action_plan","text":"Generate a plan for a user query. Source code in packages/meeseeks_core/src/meeseeks_core/task_master.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 def generate_action_plan ( user_query : str , model_name : str | None = None , tool_registry : ToolRegistry | None = None , session_summary : str | None = None , recent_events : list [ EventRecord ] | None = None , selected_events : list [ EventRecord ] | None = None , * , mode : str = \"act\" , ) -> Plan : \"\"\"Generate a plan for a user query.\"\"\" tool_registry = tool_registry or load_registry () resolved_model = cast ( str , model_name or get_config_value ( \"llm\" , \"action_plan_model\" ) or get_config_value ( \"llm\" , \"default_model\" , default = \"gpt-5.2\" ), ) context = _build_context_snapshot ( session_summary , recent_events , selected_events , resolved_model , ) return Planner ( tool_registry ) . generate ( user_query , resolved_model , context = context , mode = mode )","title":"generate_action_plan"},{"location":"reference/#meeseeks_core.task_master.orchestrate_session","text":"Run the plan-act-observe orchestration loop. Source code in packages/meeseeks_core/src/meeseeks_core/task_master.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 def orchestrate_session ( user_query : str , model_name : str | None = None , max_iters : int = 3 , initial_plan : Plan | None = None , return_state : bool = False , session_id : str | None = None , session_store : SessionStore | None = None , tool_registry : ToolRegistry | None = None , permission_policy : PermissionPolicy | None = None , approval_callback : Callable [[ ActionStep ], bool ] | None = None , hook_manager : HookManager | None = None , mode : str | None = None , should_cancel : Callable [[], bool ] | None = None , ) -> TaskQueue | tuple [ TaskQueue , OrchestrationState ]: \"\"\"Run the plan-act-observe orchestration loop.\"\"\" return Orchestrator ( model_name = model_name , session_store = session_store , tool_registry = tool_registry , permission_policy = permission_policy , approval_callback = approval_callback , hook_manager = hook_manager , ) . run ( user_query , max_iters = max_iters , initial_plan = initial_plan , return_state = return_state , session_id = session_id , mode = mode , should_cancel = should_cancel , )","title":"orchestrate_session"},{"location":"reference/#meeseeks_core.task_master.run_action_plan","text":"Execute a task queue with permissions and hooks. Source code in packages/meeseeks_core/src/meeseeks_core/task_master.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 def run_action_plan ( task_queue : TaskQueue , tool_registry : ToolRegistry | None = None , event_logger : Callable [[ Event ], None ] | None = None , permission_policy : PermissionPolicy | None = None , approval_callback : Callable [[ ActionStep ], bool ] | None = None , hook_manager : HookManager | None = None , model_name : str | None = None , * , mode : str = \"act\" , ) -> TaskQueue : \"\"\"Execute a task queue with permissions and hooks.\"\"\" tool_registry = tool_registry or load_registry () permission_policy = permission_policy or load_permission_policy () approval_callback = approval_callback or approval_callback_from_config () hook_manager = hook_manager or default_hook_manager () runner = ActionPlanRunner ( tool_registry = tool_registry , permission_policy = permission_policy , approval_callback = approval_callback , hook_manager = hook_manager , event_logger = event_logger , reflector = StepReflector ( model_name ), mode = mode , ) return runner . run ( task_queue )","title":"run_action_plan"},{"location":"reference/#meeseeks_core.action_runner","text":"Execute action plans with permissions, hooks, and reflection.","title":"action_runner"},{"location":"reference/#meeseeks_core.action_runner.ActionPlanRunner","text":"Execute TaskQueue steps with lifecycle hooks. Source code in packages/meeseeks_core/src/meeseeks_core/action_runner.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 class ActionPlanRunner : \"\"\"Execute TaskQueue steps with lifecycle hooks.\"\"\" def __init__ ( self , tool_registry : ToolRegistry | None = None , permission_policy : PermissionPolicy | None = None , approval_callback : Callable [[ ActionStep ], bool ] | None = None , hook_manager : HookManager | None = None , reflector : StepReflector | None = None , event_logger : EventLogger | None = None , allowed_tool_ids : set [ str ] | None = None , should_cancel : Callable [[], bool ] | None = None , mode : str = \"act\" , ) -> None : \"\"\"Initialize the action plan runner.\"\"\" self . _tool_registry = tool_registry or load_registry () self . _permission_policy = permission_policy or load_permission_policy () self . _approval_callback = approval_callback or approval_callback_from_config () self . _hook_manager = hook_manager or default_hook_manager () self . _reflector = reflector self . _event_logger = event_logger self . _allowed_tool_ids = allowed_tool_ids self . _should_cancel = should_cancel self . _mode = mode def run ( self , task_queue : TaskQueue ) -> TaskQueue : \"\"\"Run all steps in the task queue.\"\"\" task_queue . last_error = None for idx , action_step in enumerate ( task_queue . action_steps ): if self . _should_cancel is not None and self . _should_cancel (): self . _record_failure ( action_step , \"canceled\" , task_queue ) break logging . debug ( \"Processing ActionStep: {} \" , action_step ) if ( self . _allowed_tool_ids is not None and action_step . tool_id not in self . _allowed_tool_ids ): reason = \"tool not allowed in plan mode\" self . _record_failure ( action_step , reason , task_queue ) self . _emit_tool_result ( action_step , None , error = reason ) break if not self . _ensure_permission ( action_step ): self . _record_failure ( action_step , \"permission denied\" , task_queue ) self . _emit_tool_result ( action_step , None , error = \"Permission denied\" ) continue action_step = self . _hook_manager . run_pre_tool_use ( action_step ) task_queue . action_steps [ idx ] = action_step tool = self . _tool_registry . get ( action_step . tool_id ) if tool is None : self . _record_failure ( action_step , \"tool not available\" , task_queue ) continue spec = self . _tool_registry . get_spec ( action_step . tool_id ) if spec is not None : schema_error = self . _coerce_mcp_tool_input ( action_step , spec ) if schema_error : self . _record_failure ( action_step , schema_error , task_queue ) self . _emit_tool_result ( action_step , None , error = schema_error ) continue try : outcome = self . _execute_step ( action_step ) except Exception as exc : self . _handle_tool_error ( action_step , exc , task_queue ) continue if outcome . reflection is not None and outcome . reflection . status != \"ok\" : status = outcome . reflection . status reason = f \"step reflection requested { status } \" if outcome . reflection . notes : reason = f \" { reason } : { outcome . reflection . notes } \" self . _record_reflection_failure ( action_step , reason , task_queue ) self . _emit_tool_result ( action_step , outcome . content , error = reason ) if outcome . reflection . revised_argument : action_step . tool_input = outcome . reflection . revised_argument self . _emit_event ( { \"type\" : \"step_reflection\" , \"payload\" : { \"tool_id\" : action_step . tool_id , \"operation\" : action_step . operation , \"tool_input\" : action_step . tool_input , \"status\" : outcome . reflection . status , \"notes\" : outcome . reflection . notes , }, } ) task_queue . action_steps [ idx ] = action_step break self . _emit_tool_result ( action_step , outcome . content ) summaries = [ summary for step in task_queue . action_steps if ( summary := self . _format_step_summary ( step )) ] task_queue . task_result = \" \\n \" . join ( summaries ) . strip () return task_queue def _ensure_permission ( self , action_step : ActionStep ) -> bool : decision = self . _permission_policy . decide ( action_step ) decision = self . _hook_manager . run_permission_request ( action_step , decision ) decision_logged = False logging . debug ( \"Permission check: tool= {} action= {} decision= {} callback_present= {} \" , action_step . tool_id , action_step . operation , decision . value if isinstance ( decision , PermissionDecision ) else decision , self . _approval_callback is not None , ) if decision == PermissionDecision . ASK : approved = self . _approval_callback ( action_step ) if self . _approval_callback else False logging . debug ( \"Permission prompt result: tool= {} action= {} approved= {} \" , action_step . tool_id , action_step . operation , approved , ) decision = PermissionDecision . ALLOW if approved else PermissionDecision . DENY self . _emit_event ( { \"type\" : \"permission\" , \"payload\" : { \"tool_id\" : action_step . tool_id , \"operation\" : action_step . operation , \"tool_input\" : action_step . tool_input , \"decision\" : decision . value , }, } ) decision_logged = True if decision == PermissionDecision . DENY : mock = get_mock_speaker () message = f \"Permission denied for { action_step . tool_id } : { action_step . operation } .\" action_step . result = mock ( content = message ) if not decision_logged : self . _emit_event ( { \"type\" : \"permission\" , \"payload\" : { \"tool_id\" : action_step . tool_id , \"operation\" : action_step . operation , \"tool_input\" : action_step . tool_input , \"decision\" : decision . value , }, } ) return False return True def _execute_step ( self , action_step : ActionStep ) -> StepOutcome : tool = self . _tool_registry . get ( action_step . tool_id ) if tool is None : raise RuntimeError ( \"Tool unavailable during execution\" ) action_result = tool . run ( action_step ) action_result = self . _hook_manager . run_post_tool_use ( action_step , action_result ) action_step . result = action_result content = getattr ( action_result , \"content\" , None ) if content is None : content = \"\" if action_result is None else str ( action_result ) reflection = None if self . _reflector is not None : reflection = self . _reflector . reflect ( action_step , content ) return StepOutcome ( content = str ( content ), reflection = reflection ) def _handle_tool_error ( self , action_step : ActionStep , exc : Exception , task_queue : TaskQueue ) -> None : logging . error ( \"Error processing action step: {} \" , exc ) self . _record_failure ( action_step , str ( exc ), task_queue ) spec = self . _tool_registry . get_spec ( action_step . tool_id ) is_mcp = spec is not None and spec . kind == \"mcp\" if not isinstance ( exc , ToolInputError ) and not is_mcp : self . _tool_registry . disable ( action_step . tool_id , f \"Runtime error: { exc } \" ) self . _emit_tool_result ( action_step , None , error = str ( exc )) mock = get_mock_speaker () self . _hook_manager . run_post_tool_use ( action_step , mock ( content = f \"Tool error: { exc } \" )) def _record_failure ( self , step : ActionStep , reason : str , task_queue : TaskQueue ) -> None : note = f \" { step . tool_id } ( { step . operation } ) failed\" if reason : note = f \" { note } : { reason } \" task_queue . last_error = note if step . result is None and reason : mock = get_mock_speaker () step . result = mock ( content = f \"ERROR: { reason } \" ) def _record_reflection_failure ( self , step : ActionStep , reason : str , task_queue : TaskQueue ) -> None : note = f \" { step . tool_id } ( { step . operation } ) needs revision\" if reason : note = f \" { note } : { reason } \" task_queue . last_error = note def _emit_tool_result ( self , action_step : ActionStep , result : str | None , * , error : str | None = None ) -> None : summary = self . _summarize_result ( result , error ) payload : ToolResultPayload = { \"tool_id\" : action_step . tool_id , \"operation\" : action_step . operation , \"tool_input\" : action_step . tool_input , \"result\" : result , \"success\" : error is None , \"summary\" : summary , } if error : payload [ \"error\" ] = error self . _emit_event ({ \"type\" : \"tool_result\" , \"payload\" : payload }) def _emit_event ( self , event : Event ) -> None : if self . _event_logger is not None : self . _event_logger ( event ) @staticmethod def _coerce_mcp_tool_input ( action_step : ActionStep , spec : ToolSpec ) -> str | None : if spec . kind != \"mcp\" : return None schema = spec . metadata . get ( \"schema\" ) if spec . metadata else None if not isinstance ( schema , dict ): return None required = schema . get ( \"required\" ) or [] properties = schema . get ( \"properties\" ) or {} if not isinstance ( properties , dict ): properties = {} expected_fields = list ( required ) or list ( properties . keys ()) argument = action_step . tool_input if isinstance ( argument , str ): stripped = argument . strip () if stripped . startswith ( \"{\" ) and stripped . endswith ( \"}\" ): try : parsed = json . loads ( stripped ) except json . JSONDecodeError : parsed = None if isinstance ( parsed , dict ): action_step . tool_input = parsed argument = parsed if isinstance ( argument , str ): if expected_fields : preferred_fields = [ \"query\" , \"question\" , \"input\" , \"text\" , \"q\" ] target_field = None if len ( expected_fields ) == 1 : target_field = expected_fields [ 0 ] else : for preferred in preferred_fields : if preferred in expected_fields : target_field = preferred break if target_field : action_step . tool_input = { target_field : argument } return None fields = \", \" . join ( expected_fields ) if expected_fields else \"schema-defined fields\" return f \"Expected JSON object with fields: { fields } .\" if isinstance ( argument , dict ): if required : missing = [ name for name in required if name not in argument ] if missing : if len ( required ) == 1 and len ( argument ) == 1 : required_field = required [ 0 ] value = next ( iter ( argument . values ())) prop = properties . get ( required_field , {}) if ( isinstance ( prop , dict ) and prop . get ( \"type\" ) == \"array\" and isinstance ( value , str ) ): items = prop . get ( \"items\" ) if isinstance ( items , dict ) and items . get ( \"type\" ) == \"string\" : value = [ value ] if ( isinstance ( prop , dict ) and prop . get ( \"type\" ) == \"string\" and isinstance ( value , list ) and len ( value ) == 1 ): value = value [ 0 ] action_step . tool_input = { required_field : value } return None return f \"Missing required fields: { ', ' . join ( missing ) } .\" return None return \"Unsupported tool_input type for MCP tool.\" @staticmethod def _summarize_result ( result : str | None , error : str | None ) -> str : if error : return f \"ERROR: { error } \" if result is None : return \"\" text = str ( result ) . strip () if len ( text ) <= 500 : return text return text [: 497 ] + \"...\" @classmethod def _format_step_summary ( cls , step : ActionStep ) -> str : if step . result is None : return \"\" content = getattr ( step . result , \"content\" , step . result ) summary = cls . _summarize_result ( str ( content ), None ) if not summary : return \"\" return f \" { step . tool_id } : { step . operation } -> { summary } \"","title":"ActionPlanRunner"},{"location":"reference/#meeseeks_core.action_runner.ActionPlanRunner.__init__","text":"Initialize the action plan runner. Source code in packages/meeseeks_core/src/meeseeks_core/action_runner.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def __init__ ( self , tool_registry : ToolRegistry | None = None , permission_policy : PermissionPolicy | None = None , approval_callback : Callable [[ ActionStep ], bool ] | None = None , hook_manager : HookManager | None = None , reflector : StepReflector | None = None , event_logger : EventLogger | None = None , allowed_tool_ids : set [ str ] | None = None , should_cancel : Callable [[], bool ] | None = None , mode : str = \"act\" , ) -> None : \"\"\"Initialize the action plan runner.\"\"\" self . _tool_registry = tool_registry or load_registry () self . _permission_policy = permission_policy or load_permission_policy () self . _approval_callback = approval_callback or approval_callback_from_config () self . _hook_manager = hook_manager or default_hook_manager () self . _reflector = reflector self . _event_logger = event_logger self . _allowed_tool_ids = allowed_tool_ids self . _should_cancel = should_cancel self . _mode = mode","title":"__init__"},{"location":"reference/#meeseeks_core.action_runner.ActionPlanRunner.run","text":"Run all steps in the task queue. Source code in packages/meeseeks_core/src/meeseeks_core/action_runner.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 def run ( self , task_queue : TaskQueue ) -> TaskQueue : \"\"\"Run all steps in the task queue.\"\"\" task_queue . last_error = None for idx , action_step in enumerate ( task_queue . action_steps ): if self . _should_cancel is not None and self . _should_cancel (): self . _record_failure ( action_step , \"canceled\" , task_queue ) break logging . debug ( \"Processing ActionStep: {} \" , action_step ) if ( self . _allowed_tool_ids is not None and action_step . tool_id not in self . _allowed_tool_ids ): reason = \"tool not allowed in plan mode\" self . _record_failure ( action_step , reason , task_queue ) self . _emit_tool_result ( action_step , None , error = reason ) break if not self . _ensure_permission ( action_step ): self . _record_failure ( action_step , \"permission denied\" , task_queue ) self . _emit_tool_result ( action_step , None , error = \"Permission denied\" ) continue action_step = self . _hook_manager . run_pre_tool_use ( action_step ) task_queue . action_steps [ idx ] = action_step tool = self . _tool_registry . get ( action_step . tool_id ) if tool is None : self . _record_failure ( action_step , \"tool not available\" , task_queue ) continue spec = self . _tool_registry . get_spec ( action_step . tool_id ) if spec is not None : schema_error = self . _coerce_mcp_tool_input ( action_step , spec ) if schema_error : self . _record_failure ( action_step , schema_error , task_queue ) self . _emit_tool_result ( action_step , None , error = schema_error ) continue try : outcome = self . _execute_step ( action_step ) except Exception as exc : self . _handle_tool_error ( action_step , exc , task_queue ) continue if outcome . reflection is not None and outcome . reflection . status != \"ok\" : status = outcome . reflection . status reason = f \"step reflection requested { status } \" if outcome . reflection . notes : reason = f \" { reason } : { outcome . reflection . notes } \" self . _record_reflection_failure ( action_step , reason , task_queue ) self . _emit_tool_result ( action_step , outcome . content , error = reason ) if outcome . reflection . revised_argument : action_step . tool_input = outcome . reflection . revised_argument self . _emit_event ( { \"type\" : \"step_reflection\" , \"payload\" : { \"tool_id\" : action_step . tool_id , \"operation\" : action_step . operation , \"tool_input\" : action_step . tool_input , \"status\" : outcome . reflection . status , \"notes\" : outcome . reflection . notes , }, } ) task_queue . action_steps [ idx ] = action_step break self . _emit_tool_result ( action_step , outcome . content ) summaries = [ summary for step in task_queue . action_steps if ( summary := self . _format_step_summary ( step )) ] task_queue . task_result = \" \\n \" . join ( summaries ) . strip () return task_queue","title":"run"},{"location":"reference/#meeseeks_core.action_runner.StepOutcome","text":"Result of executing a tool step. Source code in packages/meeseeks_core/src/meeseeks_core/action_runner.py 29 30 31 32 33 34 @dataclass class StepOutcome : \"\"\"Result of executing a tool step.\"\"\" content : str reflection : StepReflection | None","title":"StepOutcome"},{"location":"reference/#meeseeks_core.planning","text":"Prompt construction and planning helpers.","title":"planning"},{"location":"reference/#meeseeks_core.planning.PlanUpdate","text":"Bases: BaseModel Updated remaining plan steps. Source code in packages/meeseeks_core/src/meeseeks_core/planning.py 106 107 108 109 class PlanUpdate ( BaseModel ): \"\"\"Updated remaining plan steps.\"\"\" steps : list [ PlanStep ] = Field ( default_factory = list )","title":"PlanUpdate"},{"location":"reference/#meeseeks_core.planning.PlanUpdater","text":"Update remaining plan steps after executing a step. Source code in packages/meeseeks_core/src/meeseeks_core/planning.py 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 class PlanUpdater : \"\"\"Update remaining plan steps after executing a step.\"\"\" def __init__ ( self , tool_registry : ToolRegistry | None ) -> None : \"\"\"Initialize the plan updater.\"\"\" self . _tool_registry = tool_registry def update ( self , user_query : str , model_name : str , * , completed_step : PlanStep , last_result : str | None , remaining_steps : list [ PlanStep ], context : ContextSnapshot | None = None , ) -> list [ PlanStep ]: \"\"\"Return updated remaining steps.\"\"\" parser = PydanticOutputParser ( pydantic_object = PlanUpdate ) # type: ignore[type-var] system_prompt = get_system_prompt ( \"plan-updater\" ) remaining_lines = [ f \"- { step . title } : { step . description } \" for step in remaining_steps ] remaining_text = \" \\n \" . join ( remaining_lines ) or \"(none)\" prompt = ChatPromptTemplate ( messages = [ SystemMessage ( content = system_prompt ), HumanMessagePromptTemplate . from_template ( \"User request: \\n {user_query} \\n\\n \" \"Completed step: \\n - {title} \\n - {description} \\n\\n \" \"Latest result: \\n {result} \\n\\n \" \"Remaining steps: \\n {remaining} \\n\\n \" \" {format_instructions} \" ), ], partial_variables = { \"format_instructions\" : parser . get_format_instructions ()}, input_variables = [ \"user_query\" , \"title\" , \"description\" , \"result\" , \"remaining\" ], ) model = build_chat_model ( model_name = model_name , openai_api_base = get_config_value ( \"llm\" , \"api_base\" ), api_key = get_config_value ( \"llm\" , \"api_key\" ), ) update = ( prompt | model | parser ) . invoke ( { \"user_query\" : user_query . strip (), \"title\" : completed_step . title , \"description\" : completed_step . description , \"result\" : last_result or \"\" , \"remaining\" : remaining_text , } ) return update . steps","title":"PlanUpdater"},{"location":"reference/#meeseeks_core.planning.PlanUpdater.__init__","text":"Initialize the plan updater. Source code in packages/meeseeks_core/src/meeseeks_core/planning.py 516 517 518 def __init__ ( self , tool_registry : ToolRegistry | None ) -> None : \"\"\"Initialize the plan updater.\"\"\" self . _tool_registry = tool_registry","title":"__init__"},{"location":"reference/#meeseeks_core.planning.PlanUpdater.update","text":"Return updated remaining steps. Source code in packages/meeseeks_core/src/meeseeks_core/planning.py 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 def update ( self , user_query : str , model_name : str , * , completed_step : PlanStep , last_result : str | None , remaining_steps : list [ PlanStep ], context : ContextSnapshot | None = None , ) -> list [ PlanStep ]: \"\"\"Return updated remaining steps.\"\"\" parser = PydanticOutputParser ( pydantic_object = PlanUpdate ) # type: ignore[type-var] system_prompt = get_system_prompt ( \"plan-updater\" ) remaining_lines = [ f \"- { step . title } : { step . description } \" for step in remaining_steps ] remaining_text = \" \\n \" . join ( remaining_lines ) or \"(none)\" prompt = ChatPromptTemplate ( messages = [ SystemMessage ( content = system_prompt ), HumanMessagePromptTemplate . from_template ( \"User request: \\n {user_query} \\n\\n \" \"Completed step: \\n - {title} \\n - {description} \\n\\n \" \"Latest result: \\n {result} \\n\\n \" \"Remaining steps: \\n {remaining} \\n\\n \" \" {format_instructions} \" ), ], partial_variables = { \"format_instructions\" : parser . get_format_instructions ()}, input_variables = [ \"user_query\" , \"title\" , \"description\" , \"result\" , \"remaining\" ], ) model = build_chat_model ( model_name = model_name , openai_api_base = get_config_value ( \"llm\" , \"api_base\" ), api_key = get_config_value ( \"llm\" , \"api_key\" ), ) update = ( prompt | model | parser ) . invoke ( { \"user_query\" : user_query . strip (), \"title\" : completed_step . title , \"description\" : completed_step . description , \"result\" : last_result or \"\" , \"remaining\" : remaining_text , } ) return update . steps","title":"update"},{"location":"reference/#meeseeks_core.planning.Planner","text":"Generate action plans via LLM. Source code in packages/meeseeks_core/src/meeseeks_core/planning.py 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 class Planner : \"\"\"Generate action plans via LLM.\"\"\" def __init__ ( self , tool_registry : ToolRegistry | None ) -> None : \"\"\"Initialize the planner.\"\"\" self . _tool_registry = tool_registry self . _prompt_builder = PromptBuilder ( tool_registry ) @staticmethod def _build_example_messages ( available_tool_ids : list [ str ], * , mode : str ) -> list [ BaseMessage ]: if mode != \"plan\" : return [] def wrap ( text : str ) -> str : return f \" { EXAMPLE_TAG_OPEN }{ text }{ EXAMPLE_TAG_CLOSE } \" return [ HumanMessage ( content = wrap ( \"Turn on strip lights and heater.\" )), AIMessage ( content = wrap ( get_task_master_examples ( example_id = 0 , available_tools = available_tool_ids ) ) ), HumanMessage ( content = wrap ( \"What is the weather today?\" )), AIMessage ( content = wrap ( get_task_master_examples ( example_id = 1 , available_tools = available_tool_ids ) ) ), ] def generate ( self , user_query : str , model_name : str , context : ContextSnapshot | None = None , * , tool_specs : list [ ToolSpec ] | None = None , mode : str = \"act\" , ) -> Plan : \"\"\"Generate a plan from the user query.\"\"\" if self . _tool_registry is None : raise ValueError ( \"Tool registry is required for planning.\" ) user_id = \"meeseeks-task-master\" session_id = f \"action-queue-id- { os . getpid () } - { os . urandom ( 4 ) . hex () } \" langfuse_handler = build_langfuse_handler ( user_id = user_id , session_id = session_id , trace_name = user_id , version = get_config_value ( \"runtime\" , \"version\" , default = \"Not Specified\" ), release = get_config_value ( \"runtime\" , \"envmode\" , default = \"Not Specified\" ), ) model = build_chat_model ( model_name = model_name , openai_api_base = get_config_value ( \"llm\" , \"api_base\" ), api_key = get_config_value ( \"llm\" , \"api_key\" ), ) parser = PydanticOutputParser ( pydantic_object = Plan ) component_status = self . _resolve_component_status () if tool_specs is not None : specs = tool_specs elif mode == \"plan\" : specs = self . _tool_registry . list_specs () else : specs = self . _tool_registry . list_specs_for_mode ( mode ) if mode == \"act\" and tool_specs is None : specs = self . _filter_specs_by_intent ( specs , user_query ) available_tool_ids = [ spec . tool_id for spec in specs ] system_prompt = self . _prompt_builder . build ( get_system_prompt (), context , component_status = component_status if mode == \"act\" else None , mode = mode , tool_specs = specs , include_tool_schemas = False , include_tool_guidance = False , ) example_messages = self . _build_example_messages ( available_tool_ids , mode = mode ) if mode == \"act\" : instruction = \"## Generate the minimal plan for the user query\" else : instruction = \"## Generate a plan for the user query\" prompt = ChatPromptTemplate ( messages = [ SystemMessage ( content = system_prompt ), * example_messages , HumanMessagePromptTemplate . from_template ( \"## Format Instructions \\n {format_instructions} \\n \" f \" { instruction } \\n{{ user_query }} \" ), ], partial_variables = { \"format_instructions\" : parser . get_format_instructions ()}, input_variables = [ \"user_query\" ], ) logging . info ( \"Generating action plan <model=' {} '; user_query=' {} '>\" , model_name , user_query , ) logging . info ( \"Input prompt token length is ` {} `.\" , num_tokens_from_string ( str ( prompt ))) config : dict [ str , object ] = {} if langfuse_handler is not None : config [ \"callbacks\" ] = [ langfuse_handler ] metadata = getattr ( langfuse_handler , \"langfuse_metadata\" , None ) if isinstance ( metadata , dict ) and metadata : config [ \"metadata\" ] = metadata with langfuse_trace_span ( \"action-plan\" ) as span : if span is not None : try : span . update_trace ( input = { \"user_query\" : user_query . strip ()}) except Exception : pass action_plan = ( prompt | model | parser ) . invoke ( { \"user_query\" : user_query . strip ()}, config = config or None , ) if span is not None : try : span . update_trace ( output = { \"step_count\" : len ( action_plan . steps or [])}) except Exception : pass action_plan . human_message = user_query return action_plan @staticmethod def _infer_intent_capabilities ( user_query : str ) -> set [ str ]: lowered = user_query . lower () requested : set [ str ] = set () for intent , keywords in INTENT_KEYWORDS . items (): if any ( keyword in lowered for keyword in keywords ): requested |= INTENT_CAPABILITIES [ intent ] return requested @staticmethod def _spec_capabilities ( spec ) -> set [ str ]: metadata = spec . metadata or {} capabilities = metadata . get ( \"capabilities\" ) if isinstance ( capabilities , list ): return { str ( item ) for item in capabilities if isinstance ( item , str )} tool_id = spec . tool_id . lower () inferred : set [ str ] = set () if \"internet_search\" in tool_id or \"web_search\" in tool_id or \"searxng\" in tool_id : inferred . add ( \"web_search\" ) if \"web_url_read\" in tool_id or \"web_url\" in tool_id : inferred . add ( \"web_read\" ) if \"aider_read_file\" in tool_id or \"aider_list_dir\" in tool_id : inferred . add ( \"file_read\" ) if \"aider_edit_block\" in tool_id : inferred . add ( \"file_write\" ) if \"shell\" in tool_id : inferred . add ( \"shell_exec\" ) if \"home_assistant\" in tool_id : inferred . add ( \"home_assistant\" ) return inferred def _filter_specs_by_intent ( self , specs , user_query : str ): requested = self . _infer_intent_capabilities ( user_query ) if not requested : return specs filtered = [ spec for spec in specs if self . _spec_capabilities ( spec ) . intersection ( requested )] return filtered or specs def _resolve_component_status ( self ) -> list [ ComponentStatus ]: return [ resolve_langfuse_status ()]","title":"Planner"},{"location":"reference/#meeseeks_core.planning.Planner.__init__","text":"Initialize the planner. Source code in packages/meeseeks_core/src/meeseeks_core/planning.py 216 217 218 219 def __init__ ( self , tool_registry : ToolRegistry | None ) -> None : \"\"\"Initialize the planner.\"\"\" self . _tool_registry = tool_registry self . _prompt_builder = PromptBuilder ( tool_registry )","title":"__init__"},{"location":"reference/#meeseeks_core.planning.Planner.generate","text":"Generate a plan from the user query. Source code in packages/meeseeks_core/src/meeseeks_core/planning.py 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 def generate ( self , user_query : str , model_name : str , context : ContextSnapshot | None = None , * , tool_specs : list [ ToolSpec ] | None = None , mode : str = \"act\" , ) -> Plan : \"\"\"Generate a plan from the user query.\"\"\" if self . _tool_registry is None : raise ValueError ( \"Tool registry is required for planning.\" ) user_id = \"meeseeks-task-master\" session_id = f \"action-queue-id- { os . getpid () } - { os . urandom ( 4 ) . hex () } \" langfuse_handler = build_langfuse_handler ( user_id = user_id , session_id = session_id , trace_name = user_id , version = get_config_value ( \"runtime\" , \"version\" , default = \"Not Specified\" ), release = get_config_value ( \"runtime\" , \"envmode\" , default = \"Not Specified\" ), ) model = build_chat_model ( model_name = model_name , openai_api_base = get_config_value ( \"llm\" , \"api_base\" ), api_key = get_config_value ( \"llm\" , \"api_key\" ), ) parser = PydanticOutputParser ( pydantic_object = Plan ) component_status = self . _resolve_component_status () if tool_specs is not None : specs = tool_specs elif mode == \"plan\" : specs = self . _tool_registry . list_specs () else : specs = self . _tool_registry . list_specs_for_mode ( mode ) if mode == \"act\" and tool_specs is None : specs = self . _filter_specs_by_intent ( specs , user_query ) available_tool_ids = [ spec . tool_id for spec in specs ] system_prompt = self . _prompt_builder . build ( get_system_prompt (), context , component_status = component_status if mode == \"act\" else None , mode = mode , tool_specs = specs , include_tool_schemas = False , include_tool_guidance = False , ) example_messages = self . _build_example_messages ( available_tool_ids , mode = mode ) if mode == \"act\" : instruction = \"## Generate the minimal plan for the user query\" else : instruction = \"## Generate a plan for the user query\" prompt = ChatPromptTemplate ( messages = [ SystemMessage ( content = system_prompt ), * example_messages , HumanMessagePromptTemplate . from_template ( \"## Format Instructions \\n {format_instructions} \\n \" f \" { instruction } \\n{{ user_query }} \" ), ], partial_variables = { \"format_instructions\" : parser . get_format_instructions ()}, input_variables = [ \"user_query\" ], ) logging . info ( \"Generating action plan <model=' {} '; user_query=' {} '>\" , model_name , user_query , ) logging . info ( \"Input prompt token length is ` {} `.\" , num_tokens_from_string ( str ( prompt ))) config : dict [ str , object ] = {} if langfuse_handler is not None : config [ \"callbacks\" ] = [ langfuse_handler ] metadata = getattr ( langfuse_handler , \"langfuse_metadata\" , None ) if isinstance ( metadata , dict ) and metadata : config [ \"metadata\" ] = metadata with langfuse_trace_span ( \"action-plan\" ) as span : if span is not None : try : span . update_trace ( input = { \"user_query\" : user_query . strip ()}) except Exception : pass action_plan = ( prompt | model | parser ) . invoke ( { \"user_query\" : user_query . strip ()}, config = config or None , ) if span is not None : try : span . update_trace ( output = { \"step_count\" : len ( action_plan . steps or [])}) except Exception : pass action_plan . human_message = user_query return action_plan","title":"generate"},{"location":"reference/#meeseeks_core.planning.PromptBuilder","text":"Build system prompts with contextual sections. Source code in packages/meeseeks_core/src/meeseeks_core/planning.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 class PromptBuilder : \"\"\"Build system prompts with contextual sections.\"\"\" def __init__ ( self , tool_registry : ToolRegistry | None ) -> None : \"\"\"Initialize prompt builder dependencies.\"\"\" self . _tool_registry = tool_registry def build ( self , base_prompt : str , context : ContextSnapshot | None , component_status : Iterable [ ComponentStatus ] | None = None , * , mode : str = \"act\" , tool_specs = None , include_tool_schemas : bool = True , include_tool_guidance : bool = True , ) -> str : \"\"\"Build an augmented system prompt string.\"\"\" sections = [ base_prompt ] if context and context . summary : sections . append ( f \"Session summary: \\n { context . summary } \" ) if context and context . selected_events : rendered = render_event_lines ( context . selected_events ) if rendered : sections . append ( \"Relevant earlier context: \\n \" + rendered ) if context and context . recent_events : rendered = render_event_lines ( context . recent_events ) if rendered : sections . append ( \"Recent conversation: \\n \" + rendered ) if self . _tool_registry is not None : specs = tool_specs or self . _tool_registry . list_specs () if specs : tool_lines = \" \\n \" . join ( f \"- { spec . tool_id } : { spec . description } \" for spec in specs ) sections . append ( f \"Available tools: \\n { tool_lines } \" ) if mode == \"act\" : if include_tool_schemas : schema_lines = self . _render_schema_lines ( specs ) if schema_lines : sections . append ( \"Tool input schemas: \\n \" + \" \\n \" . join ( schema_lines )) if include_tool_guidance : tool_prompts = self . _render_tool_prompts ( specs , local_only = True ) if tool_prompts : sections . append ( \"Tool guidance: \\n \" + \" \\n\\n \" . join ( tool_prompts )) if component_status : sections . append ( \"Component status: \\n \" + format_component_status ( component_status )) return \" \\n\\n \" . join ( sections ) @staticmethod def _render_schema_lines ( specs ) -> list [ str ]: lines : list [ str ] = [] for spec in specs : if spec . kind != \"mcp\" : continue schema = spec . metadata . get ( \"schema\" ) if spec . metadata else None if not isinstance ( schema , dict ): continue required = schema . get ( \"required\" ) or [] properties = schema . get ( \"properties\" ) or {} if not isinstance ( properties , dict ): properties = {} field_names = list ( required ) or list ( properties . keys ()) if not field_names : continue parts : list [ str ] = [] for name in field_names : if not isinstance ( name , str ): continue prop = properties . get ( name , {}) if not isinstance ( prop , dict ): prop = {} piece = name prop_type = prop . get ( \"type\" ) if isinstance ( prop_type , str ): piece += f \": { prop_type } \" description = prop . get ( \"description\" ) if isinstance ( description , str ) and description : piece += f \" - { description } \" parts . append ( piece ) if parts : lines . append ( f \"- { spec . tool_id } : \" + \"; \" . join ( parts )) return lines @staticmethod def _render_tool_prompts ( specs , * , local_only : bool = False ) -> list [ str ]: prompts : list [ str ] = [] for spec in specs : if not spec . prompt_path : continue if local_only and spec . kind != \"local\" : continue try : tool_prompt = get_system_prompt ( spec . prompt_path ) except OSError as exc : logging . warning ( \"Failed to load tool prompt for {} : {} \" , spec . tool_id , exc ) continue if tool_prompt : prompts . append ( tool_prompt ) return prompts","title":"PromptBuilder"},{"location":"reference/#meeseeks_core.planning.PromptBuilder.__init__","text":"Initialize prompt builder dependencies. Source code in packages/meeseeks_core/src/meeseeks_core/planning.py 115 116 117 def __init__ ( self , tool_registry : ToolRegistry | None ) -> None : \"\"\"Initialize prompt builder dependencies.\"\"\" self . _tool_registry = tool_registry","title":"__init__"},{"location":"reference/#meeseeks_core.planning.PromptBuilder.build","text":"Build an augmented system prompt string. Source code in packages/meeseeks_core/src/meeseeks_core/planning.py 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 def build ( self , base_prompt : str , context : ContextSnapshot | None , component_status : Iterable [ ComponentStatus ] | None = None , * , mode : str = \"act\" , tool_specs = None , include_tool_schemas : bool = True , include_tool_guidance : bool = True , ) -> str : \"\"\"Build an augmented system prompt string.\"\"\" sections = [ base_prompt ] if context and context . summary : sections . append ( f \"Session summary: \\n { context . summary } \" ) if context and context . selected_events : rendered = render_event_lines ( context . selected_events ) if rendered : sections . append ( \"Relevant earlier context: \\n \" + rendered ) if context and context . recent_events : rendered = render_event_lines ( context . recent_events ) if rendered : sections . append ( \"Recent conversation: \\n \" + rendered ) if self . _tool_registry is not None : specs = tool_specs or self . _tool_registry . list_specs () if specs : tool_lines = \" \\n \" . join ( f \"- { spec . tool_id } : { spec . description } \" for spec in specs ) sections . append ( f \"Available tools: \\n { tool_lines } \" ) if mode == \"act\" : if include_tool_schemas : schema_lines = self . _render_schema_lines ( specs ) if schema_lines : sections . append ( \"Tool input schemas: \\n \" + \" \\n \" . join ( schema_lines )) if include_tool_guidance : tool_prompts = self . _render_tool_prompts ( specs , local_only = True ) if tool_prompts : sections . append ( \"Tool guidance: \\n \" + \" \\n\\n \" . join ( tool_prompts )) if component_status : sections . append ( \"Component status: \\n \" + format_component_status ( component_status )) return \" \\n\\n \" . join ( sections )","title":"build"},{"location":"reference/#meeseeks_core.planning.ResponseSynthesizer","text":"Synthesize a response from tool outputs. Source code in packages/meeseeks_core/src/meeseeks_core/planning.py 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 class ResponseSynthesizer : \"\"\"Synthesize a response from tool outputs.\"\"\" def __init__ ( self , tool_registry : ToolRegistry | None ) -> None : \"\"\"Initialize the response synthesizer.\"\"\" self . _prompt_builder = PromptBuilder ( tool_registry ) def synthesize ( self , user_query : str , tool_outputs : list [ str ], model_name : str | None , context : ContextSnapshot | None , ) -> str : \"\"\"Synthesize a response from tool outputs.\"\"\" model_name = model_name or get_config_value ( \"llm\" , \"default_model\" , default = \"gpt-5.2\" ) system_prompt = self . _prompt_builder . build ( get_system_prompt ( \"response-synthesizer\" ), context , mode = \"synthesize\" , ) prompt = ChatPromptTemplate ( messages = [ SystemMessage ( content = system_prompt ), HumanMessagePromptTemplate . from_template ( \"User request: {user_query} \\n\\n Tool outputs: \\n {tool_outputs} \\n\\n \" \"Respond to the user using the tool outputs.\" ), ], input_variables = [ \"user_query\" , \"tool_outputs\" ], ) model = build_chat_model ( model_name = model_name , openai_api_base = get_config_value ( \"llm\" , \"api_base\" ), api_key = get_config_value ( \"llm\" , \"api_key\" ), ) handler = build_langfuse_handler ( user_id = \"meeseeks-response\" , session_id = f \"response- { os . getpid () } - { os . urandom ( 4 ) . hex () } \" , trace_name = \"meeseeks-response\" , version = get_config_value ( \"runtime\" , \"version\" , default = \"Not Specified\" ), release = get_config_value ( \"runtime\" , \"envmode\" , default = \"Not Specified\" ), ) config : dict [ str , object ] = {} if handler is not None : config [ \"callbacks\" ] = [ handler ] metadata = getattr ( handler , \"langfuse_metadata\" , None ) if isinstance ( metadata , dict ) and metadata : config [ \"metadata\" ] = metadata with langfuse_trace_span ( \"response-synthesize\" ) as span : if span is not None : try : span . update_trace ( input = { \"user_query\" : user_query . strip (), \"tool_output_count\" : len ( tool_outputs ), } ) except Exception : pass output = ( prompt | model ) . invoke ( { \"user_query\" : user_query . strip (), \"tool_outputs\" : \" \\n \" . join ( f \"- { item } \" for item in tool_outputs ), }, config = config or None , ) if span is not None : try : span . update_trace ( output = { \"response\" : str ( getattr ( output , \"content\" , output ))}) except Exception : pass content = getattr ( output , \"content\" , output ) return str ( content ) . strip ()","title":"ResponseSynthesizer"},{"location":"reference/#meeseeks_core.planning.ResponseSynthesizer.__init__","text":"Initialize the response synthesizer. Source code in packages/meeseeks_core/src/meeseeks_core/planning.py 569 570 571 def __init__ ( self , tool_registry : ToolRegistry | None ) -> None : \"\"\"Initialize the response synthesizer.\"\"\" self . _prompt_builder = PromptBuilder ( tool_registry )","title":"__init__"},{"location":"reference/#meeseeks_core.planning.ResponseSynthesizer.synthesize","text":"Synthesize a response from tool outputs. Source code in packages/meeseeks_core/src/meeseeks_core/planning.py 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 def synthesize ( self , user_query : str , tool_outputs : list [ str ], model_name : str | None , context : ContextSnapshot | None , ) -> str : \"\"\"Synthesize a response from tool outputs.\"\"\" model_name = model_name or get_config_value ( \"llm\" , \"default_model\" , default = \"gpt-5.2\" ) system_prompt = self . _prompt_builder . build ( get_system_prompt ( \"response-synthesizer\" ), context , mode = \"synthesize\" , ) prompt = ChatPromptTemplate ( messages = [ SystemMessage ( content = system_prompt ), HumanMessagePromptTemplate . from_template ( \"User request: {user_query} \\n\\n Tool outputs: \\n {tool_outputs} \\n\\n \" \"Respond to the user using the tool outputs.\" ), ], input_variables = [ \"user_query\" , \"tool_outputs\" ], ) model = build_chat_model ( model_name = model_name , openai_api_base = get_config_value ( \"llm\" , \"api_base\" ), api_key = get_config_value ( \"llm\" , \"api_key\" ), ) handler = build_langfuse_handler ( user_id = \"meeseeks-response\" , session_id = f \"response- { os . getpid () } - { os . urandom ( 4 ) . hex () } \" , trace_name = \"meeseeks-response\" , version = get_config_value ( \"runtime\" , \"version\" , default = \"Not Specified\" ), release = get_config_value ( \"runtime\" , \"envmode\" , default = \"Not Specified\" ), ) config : dict [ str , object ] = {} if handler is not None : config [ \"callbacks\" ] = [ handler ] metadata = getattr ( handler , \"langfuse_metadata\" , None ) if isinstance ( metadata , dict ) and metadata : config [ \"metadata\" ] = metadata with langfuse_trace_span ( \"response-synthesize\" ) as span : if span is not None : try : span . update_trace ( input = { \"user_query\" : user_query . strip (), \"tool_output_count\" : len ( tool_outputs ), } ) except Exception : pass output = ( prompt | model ) . invoke ( { \"user_query\" : user_query . strip (), \"tool_outputs\" : \" \\n \" . join ( f \"- { item } \" for item in tool_outputs ), }, config = config or None , ) if span is not None : try : span . update_trace ( output = { \"response\" : str ( getattr ( output , \"content\" , output ))}) except Exception : pass content = getattr ( output , \"content\" , output ) return str ( content ) . strip ()","title":"synthesize"},{"location":"reference/#meeseeks_core.planning.StepDecision","text":"Bases: BaseModel Decision on how to execute a single plan step. Source code in packages/meeseeks_core/src/meeseeks_core/planning.py 97 98 99 100 101 102 103 class StepDecision ( BaseModel ): \"\"\"Decision on how to execute a single plan step.\"\"\" decision : str = Field ( description = \"tool or respond\" ) tool_id : str | None = None args : object | None = None response : str | None = None","title":"StepDecision"},{"location":"reference/#meeseeks_core.planning.StepExecutor","text":"Decide how to execute a single plan step. Source code in packages/meeseeks_core/src/meeseeks_core/planning.py 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 class StepExecutor : \"\"\"Decide how to execute a single plan step.\"\"\" def __init__ ( self , tool_registry : ToolRegistry | None ) -> None : \"\"\"Initialize the step executor.\"\"\" self . _tool_registry = tool_registry def decide ( self , user_query : str , step : PlanStep , model_name : str , * , allowed_tools : list [ ToolSpec ], context : ContextSnapshot | None = None , ) -> StepDecision : \"\"\"Return a decision for executing the step.\"\"\" if self . _tool_registry is None : raise ValueError ( \"Tool registry is required for step execution.\" ) parser = PydanticOutputParser ( pydantic_object = StepDecision ) # type: ignore[type-var] system_prompt = get_system_prompt ( \"step-executor\" ) tools_text = _render_tool_catalog ( allowed_tools , include_schema = True ) prompt = ChatPromptTemplate ( messages = [ SystemMessage ( content = ( f \" { system_prompt } \\n\\n Allowed tools: \\n { tools_text } \" if tools_text else system_prompt ) ), HumanMessagePromptTemplate . from_template ( \"User request: \\n {user_query} \\n\\n \" \"Plan step: \\n - {title} \\n - {description} \\n\\n \" \" {format_instructions} \" ), ], partial_variables = { \"format_instructions\" : parser . get_format_instructions ()}, input_variables = [ \"user_query\" , \"title\" , \"description\" ], ) model = build_chat_model ( model_name = model_name , openai_api_base = get_config_value ( \"llm\" , \"api_base\" ), api_key = get_config_value ( \"llm\" , \"api_key\" ), ) decision = ( prompt | model | parser ) . invoke ( { \"user_query\" : user_query . strip (), \"title\" : step . title , \"description\" : step . description , } ) return decision","title":"StepExecutor"},{"location":"reference/#meeseeks_core.planning.StepExecutor.__init__","text":"Initialize the step executor. Source code in packages/meeseeks_core/src/meeseeks_core/planning.py 461 462 463 def __init__ ( self , tool_registry : ToolRegistry | None ) -> None : \"\"\"Initialize the step executor.\"\"\" self . _tool_registry = tool_registry","title":"__init__"},{"location":"reference/#meeseeks_core.planning.StepExecutor.decide","text":"Return a decision for executing the step. Source code in packages/meeseeks_core/src/meeseeks_core/planning.py 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 def decide ( self , user_query : str , step : PlanStep , model_name : str , * , allowed_tools : list [ ToolSpec ], context : ContextSnapshot | None = None , ) -> StepDecision : \"\"\"Return a decision for executing the step.\"\"\" if self . _tool_registry is None : raise ValueError ( \"Tool registry is required for step execution.\" ) parser = PydanticOutputParser ( pydantic_object = StepDecision ) # type: ignore[type-var] system_prompt = get_system_prompt ( \"step-executor\" ) tools_text = _render_tool_catalog ( allowed_tools , include_schema = True ) prompt = ChatPromptTemplate ( messages = [ SystemMessage ( content = ( f \" { system_prompt } \\n\\n Allowed tools: \\n { tools_text } \" if tools_text else system_prompt ) ), HumanMessagePromptTemplate . from_template ( \"User request: \\n {user_query} \\n\\n \" \"Plan step: \\n - {title} \\n - {description} \\n\\n \" \" {format_instructions} \" ), ], partial_variables = { \"format_instructions\" : parser . get_format_instructions ()}, input_variables = [ \"user_query\" , \"title\" , \"description\" ], ) model = build_chat_model ( model_name = model_name , openai_api_base = get_config_value ( \"llm\" , \"api_base\" ), api_key = get_config_value ( \"llm\" , \"api_key\" ), ) decision = ( prompt | model | parser ) . invoke ( { \"user_query\" : user_query . strip (), \"title\" : step . title , \"description\" : step . description , } ) return decision","title":"decide"},{"location":"reference/#meeseeks_core.planning.ToolSelection","text":"Bases: BaseModel Tool selection decision for a user query. Source code in packages/meeseeks_core/src/meeseeks_core/planning.py 89 90 91 92 93 94 class ToolSelection ( BaseModel ): \"\"\"Tool selection decision for a user query.\"\"\" tool_required : bool = Field ( default = False ) tool_ids : list [ str ] = Field ( default_factory = list ) rationale : str | None = None","title":"ToolSelection"},{"location":"reference/#meeseeks_core.planning.ToolSelector","text":"Select tools needed to satisfy a request. Source code in packages/meeseeks_core/src/meeseeks_core/planning.py 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 class ToolSelector : \"\"\"Select tools needed to satisfy a request.\"\"\" def __init__ ( self , tool_registry : ToolRegistry | None ) -> None : \"\"\"Initialize the tool selector.\"\"\" self . _tool_registry = tool_registry def select ( self , user_query : str , model_name : str , * , tool_specs : list [ ToolSpec ], context : ContextSnapshot | None = None , ) -> ToolSelection : \"\"\"Return a tool selection decision.\"\"\" if self . _tool_registry is None : raise ValueError ( \"Tool registry is required for tool selection.\" ) parser = PydanticOutputParser ( pydantic_object = ToolSelection ) # type: ignore[type-var] system_prompt = get_system_prompt ( \"tool-selector\" ) tools_text = _render_tool_catalog ( tool_specs , include_schema = False ) prompt = ChatPromptTemplate ( messages = [ SystemMessage ( content = ( f \" { system_prompt } \\n\\n Available tools: \\n { tools_text } \" if tools_text else system_prompt ) ), HumanMessagePromptTemplate . from_template ( \"User request: \\n {user_query} \\n\\n {format_instructions} \" ), ], partial_variables = { \"format_instructions\" : parser . get_format_instructions ()}, input_variables = [ \"user_query\" ], ) try : model = build_chat_model ( model_name = model_name , openai_api_base = get_config_value ( \"llm\" , \"api_base\" ), api_key = get_config_value ( \"llm\" , \"api_key\" ), ) selection = ( prompt | model | parser ) . invoke ({ \"user_query\" : user_query . strip ()}) if selection . tool_required and selection . tool_ids : specs_by_id = { spec . tool_id : spec for spec in tool_specs } selected_caps : set [ str ] = set () for tool_id in selection . tool_ids : spec = specs_by_id . get ( tool_id ) if spec is not None : selected_caps |= Planner . _spec_capabilities ( spec ) if \"web_search\" in selected_caps : for spec in tool_specs : if \"web_read\" in Planner . _spec_capabilities ( spec ): if spec . tool_id not in selection . tool_ids : selection . tool_ids . append ( spec . tool_id ) return selection except Exception as exc : # pragma: no cover - defensive fallback logging . warning ( \"Tool selector unavailable, falling back to all tools: {} \" , exc ) return ToolSelection ( tool_required = bool ( tool_specs ), tool_ids = [ spec . tool_id for spec in tool_specs ], rationale = \"fallback\" , )","title":"ToolSelector"},{"location":"reference/#meeseeks_core.planning.ToolSelector.__init__","text":"Initialize the tool selector. Source code in packages/meeseeks_core/src/meeseeks_core/planning.py 395 396 397 def __init__ ( self , tool_registry : ToolRegistry | None ) -> None : \"\"\"Initialize the tool selector.\"\"\" self . _tool_registry = tool_registry","title":"__init__"},{"location":"reference/#meeseeks_core.planning.ToolSelector.select","text":"Return a tool selection decision. Source code in packages/meeseeks_core/src/meeseeks_core/planning.py 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 def select ( self , user_query : str , model_name : str , * , tool_specs : list [ ToolSpec ], context : ContextSnapshot | None = None , ) -> ToolSelection : \"\"\"Return a tool selection decision.\"\"\" if self . _tool_registry is None : raise ValueError ( \"Tool registry is required for tool selection.\" ) parser = PydanticOutputParser ( pydantic_object = ToolSelection ) # type: ignore[type-var] system_prompt = get_system_prompt ( \"tool-selector\" ) tools_text = _render_tool_catalog ( tool_specs , include_schema = False ) prompt = ChatPromptTemplate ( messages = [ SystemMessage ( content = ( f \" { system_prompt } \\n\\n Available tools: \\n { tools_text } \" if tools_text else system_prompt ) ), HumanMessagePromptTemplate . from_template ( \"User request: \\n {user_query} \\n\\n {format_instructions} \" ), ], partial_variables = { \"format_instructions\" : parser . get_format_instructions ()}, input_variables = [ \"user_query\" ], ) try : model = build_chat_model ( model_name = model_name , openai_api_base = get_config_value ( \"llm\" , \"api_base\" ), api_key = get_config_value ( \"llm\" , \"api_key\" ), ) selection = ( prompt | model | parser ) . invoke ({ \"user_query\" : user_query . strip ()}) if selection . tool_required and selection . tool_ids : specs_by_id = { spec . tool_id : spec for spec in tool_specs } selected_caps : set [ str ] = set () for tool_id in selection . tool_ids : spec = specs_by_id . get ( tool_id ) if spec is not None : selected_caps |= Planner . _spec_capabilities ( spec ) if \"web_search\" in selected_caps : for spec in tool_specs : if \"web_read\" in Planner . _spec_capabilities ( spec ): if spec . tool_id not in selection . tool_ids : selection . tool_ids . append ( spec . tool_id ) return selection except Exception as exc : # pragma: no cover - defensive fallback logging . warning ( \"Tool selector unavailable, falling back to all tools: {} \" , exc ) return ToolSelection ( tool_required = bool ( tool_specs ), tool_ids = [ spec . tool_id for spec in tool_specs ], rationale = \"fallback\" , )","title":"select"},{"location":"reference/#meeseeks_core.reflection","text":"Step reflection helpers.","title":"reflection"},{"location":"reference/#meeseeks_core.reflection.StepReflection","text":"Bases: BaseModel Model output for step-level reflection. Source code in packages/meeseeks_core/src/meeseeks_core/reflection.py 23 24 25 26 27 28 class StepReflection ( BaseModel ): \"\"\"Model output for step-level reflection.\"\"\" status : Literal [ \"ok\" , \"retry\" , \"revise\" ] = Field ( default = \"ok\" ) notes : str | None = None revised_argument : str | None = None","title":"StepReflection"},{"location":"reference/#meeseeks_core.reflection.StepReflector","text":"Reflect on tool results when objectives are provided. Source code in packages/meeseeks_core/src/meeseeks_core/reflection.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 class StepReflector : \"\"\"Reflect on tool results when objectives are provided.\"\"\" def __init__ ( self , model_name : str | None ) -> None : \"\"\"Initialize the step reflector.\"\"\" self . _model_name = model_name def reflect ( self , action_step : ActionStep , result_text : str ) -> StepReflection | None : \"\"\"Return a reflection decision for a step.\"\"\" if not ( action_step . objective or action_step . expected_output or action_step . execution_checklist ): return None if not get_config_value ( \"reflection\" , \"enabled\" , default = True ): return None reflection_model = ( get_config_value ( \"reflection\" , \"model\" ) or self . _model_name or get_config_value ( \"llm\" , \"action_plan_model\" ) or get_config_value ( \"llm\" , \"default_model\" ) ) if not reflection_model : return None parser = PydanticOutputParser ( pydantic_object = StepReflection ) # type: ignore[type-var] prompt = ChatPromptTemplate ( messages = [ SystemMessage ( content = ( \"Reflect on whether the tool result satisfies the step objective. \" \"Return status 'ok' if complete, 'retry' if the step should be \" \"re-executed, or 'revise' if the tool input needs adjustment.\" ) ), HumanMessagePromptTemplate . from_template ( \"Step title: {title} \\n \" \"Objective: {objective} \\n \" \"Checklist: {checklist} \\n \" \"Expected output: {expected} \\n \" \"Tool result: {result} \\n\\n \" \" {format_instructions} \" ), ], partial_variables = { \"format_instructions\" : parser . get_format_instructions ()}, input_variables = [ \"title\" , \"objective\" , \"checklist\" , \"expected\" , \"result\" ], ) try : model = build_chat_model ( model_name = reflection_model , openai_api_base = get_config_value ( \"llm\" , \"api_base\" ), api_key = get_config_value ( \"llm\" , \"api_key\" ), ) except Exception as exc : logging . warning ( \"Step reflection unavailable: {} \" , exc ) return None handler = build_langfuse_handler ( user_id = \"meeseeks-reflection\" , session_id = f \"reflection- { os . getpid () } - { os . urandom ( 4 ) . hex () } \" , trace_name = \"meeseeks-reflection\" , version = get_config_value ( \"runtime\" , \"version\" , default = \"Not Specified\" ), release = get_config_value ( \"runtime\" , \"envmode\" , default = \"Not Specified\" ), ) config : dict [ str , object ] = {} if handler is not None : config [ \"callbacks\" ] = [ handler ] metadata = getattr ( handler , \"langfuse_metadata\" , None ) if isinstance ( metadata , dict ) and metadata : config [ \"metadata\" ] = metadata try : with langfuse_trace_span ( \"step-reflection\" ) as span : if span is not None : try : span . update_trace ( input = { \"title\" : action_step . title or action_step . tool_id , \"objective\" : action_step . objective or format_tool_input ( action_step . tool_input ), } ) except Exception : pass reflection = ( prompt | model | parser ) . invoke ( { \"title\" : action_step . title or action_step . tool_id , \"objective\" : action_step . objective or format_tool_input ( action_step . tool_input ), \"checklist\" : \"; \" . join ( action_step . execution_checklist or []), \"expected\" : action_step . expected_output or \"Not specified\" , \"result\" : result_text , }, config = config or None , ) if span is not None : try : span . update_trace ( output = { \"status\" : getattr ( reflection , \"status\" , None ), \"notes\" : getattr ( reflection , \"notes\" , None ), } ) except Exception : pass return reflection except Exception as exc : # pragma: no cover - defensive logging . warning ( \"Step reflection failed: {} \" , exc ) return None","title":"StepReflector"},{"location":"reference/#meeseeks_core.reflection.StepReflector.__init__","text":"Initialize the step reflector. Source code in packages/meeseeks_core/src/meeseeks_core/reflection.py 34 35 36 def __init__ ( self , model_name : str | None ) -> None : \"\"\"Initialize the step reflector.\"\"\" self . _model_name = model_name","title":"__init__"},{"location":"reference/#meeseeks_core.reflection.StepReflector.reflect","text":"Return a reflection decision for a step. Source code in packages/meeseeks_core/src/meeseeks_core/reflection.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 def reflect ( self , action_step : ActionStep , result_text : str ) -> StepReflection | None : \"\"\"Return a reflection decision for a step.\"\"\" if not ( action_step . objective or action_step . expected_output or action_step . execution_checklist ): return None if not get_config_value ( \"reflection\" , \"enabled\" , default = True ): return None reflection_model = ( get_config_value ( \"reflection\" , \"model\" ) or self . _model_name or get_config_value ( \"llm\" , \"action_plan_model\" ) or get_config_value ( \"llm\" , \"default_model\" ) ) if not reflection_model : return None parser = PydanticOutputParser ( pydantic_object = StepReflection ) # type: ignore[type-var] prompt = ChatPromptTemplate ( messages = [ SystemMessage ( content = ( \"Reflect on whether the tool result satisfies the step objective. \" \"Return status 'ok' if complete, 'retry' if the step should be \" \"re-executed, or 'revise' if the tool input needs adjustment.\" ) ), HumanMessagePromptTemplate . from_template ( \"Step title: {title} \\n \" \"Objective: {objective} \\n \" \"Checklist: {checklist} \\n \" \"Expected output: {expected} \\n \" \"Tool result: {result} \\n\\n \" \" {format_instructions} \" ), ], partial_variables = { \"format_instructions\" : parser . get_format_instructions ()}, input_variables = [ \"title\" , \"objective\" , \"checklist\" , \"expected\" , \"result\" ], ) try : model = build_chat_model ( model_name = reflection_model , openai_api_base = get_config_value ( \"llm\" , \"api_base\" ), api_key = get_config_value ( \"llm\" , \"api_key\" ), ) except Exception as exc : logging . warning ( \"Step reflection unavailable: {} \" , exc ) return None handler = build_langfuse_handler ( user_id = \"meeseeks-reflection\" , session_id = f \"reflection- { os . getpid () } - { os . urandom ( 4 ) . hex () } \" , trace_name = \"meeseeks-reflection\" , version = get_config_value ( \"runtime\" , \"version\" , default = \"Not Specified\" ), release = get_config_value ( \"runtime\" , \"envmode\" , default = \"Not Specified\" ), ) config : dict [ str , object ] = {} if handler is not None : config [ \"callbacks\" ] = [ handler ] metadata = getattr ( handler , \"langfuse_metadata\" , None ) if isinstance ( metadata , dict ) and metadata : config [ \"metadata\" ] = metadata try : with langfuse_trace_span ( \"step-reflection\" ) as span : if span is not None : try : span . update_trace ( input = { \"title\" : action_step . title or action_step . tool_id , \"objective\" : action_step . objective or format_tool_input ( action_step . tool_input ), } ) except Exception : pass reflection = ( prompt | model | parser ) . invoke ( { \"title\" : action_step . title or action_step . tool_id , \"objective\" : action_step . objective or format_tool_input ( action_step . tool_input ), \"checklist\" : \"; \" . join ( action_step . execution_checklist or []), \"expected\" : action_step . expected_output or \"Not specified\" , \"result\" : result_text , }, config = config or None , ) if span is not None : try : span . update_trace ( output = { \"status\" : getattr ( reflection , \"status\" , None ), \"notes\" : getattr ( reflection , \"notes\" , None ), } ) except Exception : pass return reflection except Exception as exc : # pragma: no cover - defensive logging . warning ( \"Step reflection failed: {} \" , exc ) return None","title":"reflect"},{"location":"reference/#meeseeks_core.session_runtime","text":"Shared session runtime utilities for CLI and API.","title":"session_runtime"},{"location":"reference/#meeseeks_core.session_runtime.RunHandle","text":"Active orchestration thread tracking. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 41 42 43 44 45 46 47 @dataclass ( frozen = True ) class RunHandle : \"\"\"Active orchestration thread tracking.\"\"\" thread : threading . Thread cancel_event : threading . Event started_at : str","title":"RunHandle"},{"location":"reference/#meeseeks_core.session_runtime.RunRegistry","text":"Track active orchestration threads per session. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 class RunRegistry : \"\"\"Track active orchestration threads per session.\"\"\" def __init__ ( self ) -> None : \"\"\"Initialize the run registry.\"\"\" self . _lock = threading . Lock () self . _runs : dict [ str , RunHandle ] = {} def start ( self , session_id : str , target : Callable [[ threading . Event ], None ], ) -> bool : \"\"\"Start a new run for the session if one is not already active.\"\"\" with self . _lock : existing = self . _runs . get ( session_id ) if existing and existing . thread . is_alive (): return False cancel_event = threading . Event () thread = threading . Thread ( target = self . _wrap_run , args = ( session_id , cancel_event , target ), daemon = True , ) self . _runs [ session_id ] = RunHandle ( thread = thread , cancel_event = cancel_event , started_at = _utc_now (), ) thread . start () return True def _wrap_run ( self , session_id : str , cancel_event : threading . Event , target : Callable [[ threading . Event ], None ], ) -> None : try : target ( cancel_event ) finally : with self . _lock : handle = self . _runs . get ( session_id ) if handle and handle . thread . ident == threading . current_thread () . ident : self . _runs . pop ( session_id , None ) def cancel ( self , session_id : str ) -> bool : \"\"\"Request cancellation for an active session run.\"\"\" with self . _lock : handle = self . _runs . get ( session_id ) if not handle : return False handle . cancel_event . set () return True def is_running ( self , session_id : str ) -> bool : \"\"\"Return True if the session has an active run.\"\"\" with self . _lock : handle = self . _runs . get ( session_id ) return bool ( handle and handle . thread . is_alive ()) def get_cancel_event ( self , session_id : str ) -> threading . Event | None : \"\"\"Return the cancel event for a session, if present.\"\"\" with self . _lock : handle = self . _runs . get ( session_id ) return handle . cancel_event if handle else None","title":"RunRegistry"},{"location":"reference/#meeseeks_core.session_runtime.RunRegistry.__init__","text":"Initialize the run registry. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 53 54 55 56 def __init__ ( self ) -> None : \"\"\"Initialize the run registry.\"\"\" self . _lock = threading . Lock () self . _runs : dict [ str , RunHandle ] = {}","title":"__init__"},{"location":"reference/#meeseeks_core.session_runtime.RunRegistry.cancel","text":"Request cancellation for an active session run. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 96 97 98 99 100 101 102 103 def cancel ( self , session_id : str ) -> bool : \"\"\"Request cancellation for an active session run.\"\"\" with self . _lock : handle = self . _runs . get ( session_id ) if not handle : return False handle . cancel_event . set () return True","title":"cancel"},{"location":"reference/#meeseeks_core.session_runtime.RunRegistry.get_cancel_event","text":"Return the cancel event for a session, if present. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 111 112 113 114 115 def get_cancel_event ( self , session_id : str ) -> threading . Event | None : \"\"\"Return the cancel event for a session, if present.\"\"\" with self . _lock : handle = self . _runs . get ( session_id ) return handle . cancel_event if handle else None","title":"get_cancel_event"},{"location":"reference/#meeseeks_core.session_runtime.RunRegistry.is_running","text":"Return True if the session has an active run. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 105 106 107 108 109 def is_running ( self , session_id : str ) -> bool : \"\"\"Return True if the session has an active run.\"\"\" with self . _lock : handle = self . _runs . get ( session_id ) return bool ( handle and handle . thread . is_alive ())","title":"is_running"},{"location":"reference/#meeseeks_core.session_runtime.RunRegistry.start","text":"Start a new run for the session if one is not already active. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def start ( self , session_id : str , target : Callable [[ threading . Event ], None ], ) -> bool : \"\"\"Start a new run for the session if one is not already active.\"\"\" with self . _lock : existing = self . _runs . get ( session_id ) if existing and existing . thread . is_alive (): return False cancel_event = threading . Event () thread = threading . Thread ( target = self . _wrap_run , args = ( session_id , cancel_event , target ), daemon = True , ) self . _runs [ session_id ] = RunHandle ( thread = thread , cancel_event = cancel_event , started_at = _utc_now (), ) thread . start () return True","title":"start"},{"location":"reference/#meeseeks_core.session_runtime.SessionRuntime","text":"Shared orchestration runtime surface for CLI and API. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 class SessionRuntime : \"\"\"Shared orchestration runtime surface for CLI and API.\"\"\" def __init__ ( self , * , session_store : SessionStore | None = None , run_registry : RunRegistry | None = None , ) -> None : \"\"\"Initialize the runtime with session storage and optional run registry.\"\"\" self . _session_store = session_store or SessionStore () self . _run_registry = run_registry or RunRegistry () @property def session_store ( self ) -> SessionStore : \"\"\"Expose the underlying session store.\"\"\" return self . _session_store def resolve_session ( self , * , session_id : str | None = None , session_tag : str | None = None , fork_from : str | None = None , ) -> str : \"\"\"Resolve session identifiers, tags, and forks to a session id.\"\"\" if fork_from : source_session_id = self . _session_store . resolve_tag ( fork_from ) or fork_from session_id = self . _session_store . fork_session ( source_session_id ) if session_tag and not session_id : resolved = self . _session_store . resolve_tag ( session_tag ) session_id = resolved if resolved else None if not session_id : session_id = self . _session_store . create_session () if session_tag : self . _session_store . tag_session ( session_id , session_tag ) assert session_id is not None return session_id def append_context_event ( self , session_id : str , context : dict [ str , object ]) -> None : \"\"\"Append a context event to the session transcript.\"\"\" if not context : return self . _session_store . append_event ( session_id , { \"type\" : \"context\" , \"payload\" : context }) def summarize_session ( self , session_id : str , * , events : list [ EventRecord ] | None = None , ) -> dict [ str , object ]: \"\"\"Return a summarized view of a session.\"\"\" if events is None : events = self . _session_store . load_transcript ( session_id ) created_at = events [ 0 ][ \"ts\" ] if events else None title = None status = \"idle\" done_reason = None context : dict [ str , object ] | None = None has_user_event = False for event in events : if event . get ( \"type\" ) == \"context\" : payload = event . get ( \"payload\" ) if isinstance ( payload , dict ): context = payload if title is None and event . get ( \"type\" ) == \"user\" : has_user_event = True payload = event . get ( \"payload\" , {}) if isinstance ( payload , dict ): title = payload . get ( \"text\" ) if event . get ( \"type\" ) == \"completion\" : payload = event . get ( \"payload\" , {}) if isinstance ( payload , dict ): done_reason = payload . get ( \"done_reason\" ) status = \"completed\" if payload . get ( \"done\" ) else \"incomplete\" running = self . is_running ( session_id ) if running : status = \"running\" if not has_user_event and not running : created_at = None if not title : title = f \"Session { session_id [: 8 ] } \" return { \"session_id\" : session_id , \"title\" : title , \"created_at\" : created_at , \"status\" : status , \"done_reason\" : done_reason , \"running\" : running , \"context\" : context or {}, \"archived\" : self . _session_store . is_archived ( session_id ), } def list_sessions ( self , * , include_archived : bool = False ) -> list [ dict [ str , object ]]: \"\"\"List sessions with summary metadata.\"\"\" summaries : list [ dict [ str , object ]] = [] for session_id in self . _session_store . list_sessions (): events = self . _session_store . load_transcript ( session_id ) summary = self . summarize_session ( session_id , events = events ) has_visible_event = any ( event . get ( \"type\" ) not in { \"session\" , \"context\" } for event in events ) if not has_visible_event and not summary . get ( \"running\" ): continue if summary . get ( \"created_at\" ) is None and not summary . get ( \"running\" ): continue if not include_archived and summary . get ( \"archived\" ): continue summaries . append ( summary ) return summaries def load_events ( self , session_id : str , after : str | None = None ) -> list [ EventRecord ]: \"\"\"Load events for a session with optional timestamp filtering.\"\"\" events = self . _session_store . load_transcript ( session_id ) return _filter_events ( events , after ) def start_async ( self , * , session_id : str , user_query : str , model_name : str | None = None , max_iters : int = 3 , initial_plan : Plan | None = None , tool_registry = None , permission_policy = None , approval_callback = None , hook_manager = None , mode : str | None = None , ) -> bool : \"\"\"Start an asynchronous orchestration run for the session.\"\"\" def _run ( cancel_event : threading . Event ) -> None : self . run_sync ( user_query = user_query , session_id = session_id , model_name = model_name , max_iters = max_iters , initial_plan = initial_plan , tool_registry = tool_registry , permission_policy = permission_policy , approval_callback = approval_callback , hook_manager = hook_manager , mode = mode , should_cancel = cancel_event . is_set , ) return self . _run_registry . start ( session_id , target = _run ) def run_sync ( self , * , user_query : str , session_id : str , model_name : str | None = None , max_iters : int = 3 , initial_plan : Plan | None = None , tool_registry = None , permission_policy = None , approval_callback = None , hook_manager = None , mode : str | None = None , should_cancel : Callable [[], bool ] | None = None , ) -> TaskQueue : \"\"\"Run an orchestration request synchronously.\"\"\" return orchestrate_session ( user_query = user_query , model_name = model_name , max_iters = max_iters , initial_plan = initial_plan , session_id = session_id , session_store = self . _session_store , tool_registry = tool_registry , permission_policy = permission_policy , approval_callback = approval_callback , hook_manager = hook_manager , mode = mode , should_cancel = should_cancel , ) def cancel ( self , session_id : str ) -> bool : \"\"\"Cancel an active run if present.\"\"\" return self . _run_registry . cancel ( session_id ) def is_running ( self , session_id : str ) -> bool : \"\"\"Return True if session has an active run.\"\"\" return self . _run_registry . is_running ( session_id )","title":"SessionRuntime"},{"location":"reference/#meeseeks_core.session_runtime.SessionRuntime.session_store","text":"Expose the underlying session store.","title":"session_store"},{"location":"reference/#meeseeks_core.session_runtime.SessionRuntime.__init__","text":"Initialize the runtime with session storage and optional run registry. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 135 136 137 138 139 140 141 142 143 def __init__ ( self , * , session_store : SessionStore | None = None , run_registry : RunRegistry | None = None , ) -> None : \"\"\"Initialize the runtime with session storage and optional run registry.\"\"\" self . _session_store = session_store or SessionStore () self . _run_registry = run_registry or RunRegistry ()","title":"__init__"},{"location":"reference/#meeseeks_core.session_runtime.SessionRuntime.append_context_event","text":"Append a context event to the session transcript. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 171 172 173 174 175 def append_context_event ( self , session_id : str , context : dict [ str , object ]) -> None : \"\"\"Append a context event to the session transcript.\"\"\" if not context : return self . _session_store . append_event ( session_id , { \"type\" : \"context\" , \"payload\" : context })","title":"append_context_event"},{"location":"reference/#meeseeks_core.session_runtime.SessionRuntime.cancel","text":"Cancel an active run if present. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 312 313 314 def cancel ( self , session_id : str ) -> bool : \"\"\"Cancel an active run if present.\"\"\" return self . _run_registry . cancel ( session_id )","title":"cancel"},{"location":"reference/#meeseeks_core.session_runtime.SessionRuntime.is_running","text":"Return True if session has an active run. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 316 317 318 def is_running ( self , session_id : str ) -> bool : \"\"\"Return True if session has an active run.\"\"\" return self . _run_registry . is_running ( session_id )","title":"is_running"},{"location":"reference/#meeseeks_core.session_runtime.SessionRuntime.list_sessions","text":"List sessions with summary metadata. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 def list_sessions ( self , * , include_archived : bool = False ) -> list [ dict [ str , object ]]: \"\"\"List sessions with summary metadata.\"\"\" summaries : list [ dict [ str , object ]] = [] for session_id in self . _session_store . list_sessions (): events = self . _session_store . load_transcript ( session_id ) summary = self . summarize_session ( session_id , events = events ) has_visible_event = any ( event . get ( \"type\" ) not in { \"session\" , \"context\" } for event in events ) if not has_visible_event and not summary . get ( \"running\" ): continue if summary . get ( \"created_at\" ) is None and not summary . get ( \"running\" ): continue if not include_archived and summary . get ( \"archived\" ): continue summaries . append ( summary ) return summaries","title":"list_sessions"},{"location":"reference/#meeseeks_core.session_runtime.SessionRuntime.load_events","text":"Load events for a session with optional timestamp filtering. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 243 244 245 246 def load_events ( self , session_id : str , after : str | None = None ) -> list [ EventRecord ]: \"\"\"Load events for a session with optional timestamp filtering.\"\"\" events = self . _session_store . load_transcript ( session_id ) return _filter_events ( events , after )","title":"load_events"},{"location":"reference/#meeseeks_core.session_runtime.SessionRuntime.resolve_session","text":"Resolve session identifiers, tags, and forks to a session id. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 def resolve_session ( self , * , session_id : str | None = None , session_tag : str | None = None , fork_from : str | None = None , ) -> str : \"\"\"Resolve session identifiers, tags, and forks to a session id.\"\"\" if fork_from : source_session_id = self . _session_store . resolve_tag ( fork_from ) or fork_from session_id = self . _session_store . fork_session ( source_session_id ) if session_tag and not session_id : resolved = self . _session_store . resolve_tag ( session_tag ) session_id = resolved if resolved else None if not session_id : session_id = self . _session_store . create_session () if session_tag : self . _session_store . tag_session ( session_id , session_tag ) assert session_id is not None return session_id","title":"resolve_session"},{"location":"reference/#meeseeks_core.session_runtime.SessionRuntime.run_sync","text":"Run an orchestration request synchronously. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 def run_sync ( self , * , user_query : str , session_id : str , model_name : str | None = None , max_iters : int = 3 , initial_plan : Plan | None = None , tool_registry = None , permission_policy = None , approval_callback = None , hook_manager = None , mode : str | None = None , should_cancel : Callable [[], bool ] | None = None , ) -> TaskQueue : \"\"\"Run an orchestration request synchronously.\"\"\" return orchestrate_session ( user_query = user_query , model_name = model_name , max_iters = max_iters , initial_plan = initial_plan , session_id = session_id , session_store = self . _session_store , tool_registry = tool_registry , permission_policy = permission_policy , approval_callback = approval_callback , hook_manager = hook_manager , mode = mode , should_cancel = should_cancel , )","title":"run_sync"},{"location":"reference/#meeseeks_core.session_runtime.SessionRuntime.start_async","text":"Start an asynchronous orchestration run for the session. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 def start_async ( self , * , session_id : str , user_query : str , model_name : str | None = None , max_iters : int = 3 , initial_plan : Plan | None = None , tool_registry = None , permission_policy = None , approval_callback = None , hook_manager = None , mode : str | None = None , ) -> bool : \"\"\"Start an asynchronous orchestration run for the session.\"\"\" def _run ( cancel_event : threading . Event ) -> None : self . run_sync ( user_query = user_query , session_id = session_id , model_name = model_name , max_iters = max_iters , initial_plan = initial_plan , tool_registry = tool_registry , permission_policy = permission_policy , approval_callback = approval_callback , hook_manager = hook_manager , mode = mode , should_cancel = cancel_event . is_set , ) return self . _run_registry . start ( session_id , target = _run )","title":"start_async"},{"location":"reference/#meeseeks_core.session_runtime.SessionRuntime.summarize_session","text":"Return a summarized view of a session. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 def summarize_session ( self , session_id : str , * , events : list [ EventRecord ] | None = None , ) -> dict [ str , object ]: \"\"\"Return a summarized view of a session.\"\"\" if events is None : events = self . _session_store . load_transcript ( session_id ) created_at = events [ 0 ][ \"ts\" ] if events else None title = None status = \"idle\" done_reason = None context : dict [ str , object ] | None = None has_user_event = False for event in events : if event . get ( \"type\" ) == \"context\" : payload = event . get ( \"payload\" ) if isinstance ( payload , dict ): context = payload if title is None and event . get ( \"type\" ) == \"user\" : has_user_event = True payload = event . get ( \"payload\" , {}) if isinstance ( payload , dict ): title = payload . get ( \"text\" ) if event . get ( \"type\" ) == \"completion\" : payload = event . get ( \"payload\" , {}) if isinstance ( payload , dict ): done_reason = payload . get ( \"done_reason\" ) status = \"completed\" if payload . get ( \"done\" ) else \"incomplete\" running = self . is_running ( session_id ) if running : status = \"running\" if not has_user_event and not running : created_at = None if not title : title = f \"Session { session_id [: 8 ] } \" return { \"session_id\" : session_id , \"title\" : title , \"created_at\" : created_at , \"status\" : status , \"done_reason\" : done_reason , \"running\" : running , \"context\" : context or {}, \"archived\" : self . _session_store . is_archived ( session_id ), }","title":"summarize_session"},{"location":"reference/#meeseeks_core.session_runtime.parse_core_command","text":"Return the core command token if present. Source code in packages/meeseeks_core/src/meeseeks_core/session_runtime.py 33 34 35 36 37 38 def parse_core_command ( text : str ) -> str | None : \"\"\"Return the core command token if present.\"\"\" if not text : return None command = text . strip () . lower () . split ()[ 0 ] return command if command in CORE_COMMANDS else None","title":"parse_core_command"},{"location":"reference/#meeseeks_core.session_store","text":"Session transcript storage and management.","title":"session_store"},{"location":"reference/#meeseeks_core.session_store.SessionPaths","text":"Resolved filesystem paths for a session. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 @dataclass ( frozen = True ) class SessionPaths : \"\"\"Resolved filesystem paths for a session.\"\"\" root : str session_id : str @property def session_dir ( self ) -> str : \"\"\"Directory for session artifacts.\"\"\" return os . path . join ( self . root , self . session_id ) @property def transcript_path ( self ) -> str : \"\"\"Path to the JSONL transcript file.\"\"\" return os . path . join ( self . session_dir , \"transcript.jsonl\" ) @property def summary_path ( self ) -> str : \"\"\"Path to the summary JSON file.\"\"\" return os . path . join ( self . session_dir , \"summary.json\" )","title":"SessionPaths"},{"location":"reference/#meeseeks_core.session_store.SessionPaths.session_dir","text":"Directory for session artifacts.","title":"session_dir"},{"location":"reference/#meeseeks_core.session_store.SessionPaths.summary_path","text":"Path to the summary JSON file.","title":"summary_path"},{"location":"reference/#meeseeks_core.session_store.SessionPaths.transcript_path","text":"Path to the JSONL transcript file.","title":"transcript_path"},{"location":"reference/#meeseeks_core.session_store.SessionStore","text":"Filesystem-backed storage for session transcripts and summaries. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 class SessionStore : \"\"\"Filesystem-backed storage for session transcripts and summaries.\"\"\" def __init__ ( self , root_dir : str | None = None ) -> None : \"\"\"Initialize the store and ensure the root directory exists.\"\"\" if root_dir is None : root_dir = get_config_value ( \"runtime\" , \"session_dir\" , default = \"./data/sessions\" ) self . root_dir = os . path . abspath ( root_dir ) os . makedirs ( self . root_dir , exist_ok = True ) def _index_path ( self ) -> str : \"\"\"Return the path for the session index file.\"\"\" return os . path . join ( self . root_dir , \"index.json\" ) def _load_index ( self ) -> dict [ str , dict [ str , str ]]: \"\"\"Load the session index from disk or return defaults.\"\"\" index_path = self . _index_path () if not os . path . exists ( index_path ): return { \"tags\" : {}, \"archived\" : {}} with open ( index_path , encoding = \"utf-8\" ) as handle : return json . load ( handle ) def _save_index ( self , data : dict [ str , dict [ str , str ]]) -> None : \"\"\"Persist the session index to disk.\"\"\" with open ( self . _index_path (), \"w\" , encoding = \"utf-8\" ) as handle : json . dump ( data , handle , indent = 2 ) def create_session ( self ) -> str : \"\"\"Create a new session directory and return its identifier.\"\"\" session_id = uuid . uuid4 () . hex paths = self . _paths ( session_id ) os . makedirs ( paths . session_dir , exist_ok = True ) return session_id def _paths ( self , session_id : str ) -> SessionPaths : \"\"\"Build filesystem paths for a session.\"\"\" return SessionPaths ( root = self . root_dir , session_id = session_id ) def append_event ( self , session_id : str , event : Event ) -> None : \"\"\"Append a single event record to the session transcript.\"\"\" paths = self . _paths ( session_id ) os . makedirs ( paths . session_dir , exist_ok = True ) payload : EventRecord = { \"ts\" : _utc_now (), ** event } with open ( paths . transcript_path , \"a\" , encoding = \"utf-8\" ) as handle : handle . write ( json . dumps ( payload ) + \" \\n \" ) def load_transcript ( self , session_id : str ) -> list [ EventRecord ]: \"\"\"Load all transcript events for a session.\"\"\" paths = self . _paths ( session_id ) if not os . path . exists ( paths . transcript_path ): return [] events : list [ EventRecord ] = [] with open ( paths . transcript_path , encoding = \"utf-8\" ) as handle : for line in handle : line = line . strip () if not line : continue try : events . append ( json . loads ( line )) except json . JSONDecodeError : logging . warning ( \"Skipping malformed transcript line.\" ) return events def load_recent_events ( self , session_id : str , limit : int = 8 , include_types : set [ str ] | None = None , ) -> list [ EventRecord ]: \"\"\"Load the most recent events, optionally filtered by type.\"\"\" events = self . load_transcript ( session_id ) if include_types : events = [ event for event in events if event . get ( \"type\" ) in include_types ] if limit <= 0 : return [] return events [ - limit :] def save_summary ( self , session_id : str , summary : str ) -> None : \"\"\"Persist a summary for a session.\"\"\" paths = self . _paths ( session_id ) os . makedirs ( paths . session_dir , exist_ok = True ) with open ( paths . summary_path , \"w\" , encoding = \"utf-8\" ) as handle : json . dump ({ \"summary\" : summary , \"updated_at\" : _utc_now ()}, handle , indent = 2 ) def load_summary ( self , session_id : str ) -> str | None : \"\"\"Load a previously saved summary, if present.\"\"\" paths = self . _paths ( session_id ) if not os . path . exists ( paths . summary_path ): return None with open ( paths . summary_path , encoding = \"utf-8\" ) as handle : data = json . load ( handle ) return data . get ( \"summary\" ) def list_sessions ( self ) -> list [ str ]: \"\"\"List all session IDs present in the root directory.\"\"\" if not os . path . exists ( self . root_dir ): return [] return sorted ( name for name in os . listdir ( self . root_dir ) if os . path . isdir ( os . path . join ( self . root_dir , name )) ) def fork_session ( self , source_session_id : str ) -> str : \"\"\"Create a new session by copying events and summary from another.\"\"\" events = self . load_transcript ( source_session_id ) summary = self . load_summary ( source_session_id ) new_session_id = self . create_session () for event in events : self . append_event ( new_session_id , event ) if summary : self . save_summary ( new_session_id , summary ) return new_session_id def tag_session ( self , session_id : str , tag : str ) -> None : \"\"\"Associate a tag with a session ID for quick lookup.\"\"\" index = self . _load_index () index . setdefault ( \"tags\" , {})[ tag ] = session_id self . _save_index ( index ) def resolve_tag ( self , tag : str ) -> str | None : \"\"\"Resolve a tag to a session ID, if present.\"\"\" index = self . _load_index () return index . get ( \"tags\" , {}) . get ( tag ) def list_tags ( self ) -> dict [ str , str ]: \"\"\"Return a mapping of tags to session IDs.\"\"\" index = self . _load_index () return dict ( index . get ( \"tags\" , {})) def archive_session ( self , session_id : str ) -> None : \"\"\"Mark a session as archived.\"\"\" index = self . _load_index () archived = index . setdefault ( \"archived\" , {}) archived [ session_id ] = _utc_now () self . _save_index ( index ) def unarchive_session ( self , session_id : str ) -> None : \"\"\"Remove archived status from a session.\"\"\" index = self . _load_index () archived = index . get ( \"archived\" , {}) if session_id in archived : archived . pop ( session_id , None ) index [ \"archived\" ] = archived self . _save_index ( index ) def is_archived ( self , session_id : str ) -> bool : \"\"\"Return True if a session is archived.\"\"\" index = self . _load_index () archived = index . get ( \"archived\" , {}) return session_id in archived","title":"SessionStore"},{"location":"reference/#meeseeks_core.session_store.SessionStore.__init__","text":"Initialize the store and ensure the root directory exists. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 50 51 52 53 54 55 def __init__ ( self , root_dir : str | None = None ) -> None : \"\"\"Initialize the store and ensure the root directory exists.\"\"\" if root_dir is None : root_dir = get_config_value ( \"runtime\" , \"session_dir\" , default = \"./data/sessions\" ) self . root_dir = os . path . abspath ( root_dir ) os . makedirs ( self . root_dir , exist_ok = True )","title":"__init__"},{"location":"reference/#meeseeks_core.session_store.SessionStore.append_event","text":"Append a single event record to the session transcript. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 85 86 87 88 89 90 91 def append_event ( self , session_id : str , event : Event ) -> None : \"\"\"Append a single event record to the session transcript.\"\"\" paths = self . _paths ( session_id ) os . makedirs ( paths . session_dir , exist_ok = True ) payload : EventRecord = { \"ts\" : _utc_now (), ** event } with open ( paths . transcript_path , \"a\" , encoding = \"utf-8\" ) as handle : handle . write ( json . dumps ( payload ) + \" \\n \" )","title":"append_event"},{"location":"reference/#meeseeks_core.session_store.SessionStore.archive_session","text":"Mark a session as archived. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 177 178 179 180 181 182 def archive_session ( self , session_id : str ) -> None : \"\"\"Mark a session as archived.\"\"\" index = self . _load_index () archived = index . setdefault ( \"archived\" , {}) archived [ session_id ] = _utc_now () self . _save_index ( index )","title":"archive_session"},{"location":"reference/#meeseeks_core.session_store.SessionStore.create_session","text":"Create a new session directory and return its identifier. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 74 75 76 77 78 79 def create_session ( self ) -> str : \"\"\"Create a new session directory and return its identifier.\"\"\" session_id = uuid . uuid4 () . hex paths = self . _paths ( session_id ) os . makedirs ( paths . session_dir , exist_ok = True ) return session_id","title":"create_session"},{"location":"reference/#meeseeks_core.session_store.SessionStore.fork_session","text":"Create a new session by copying events and summary from another. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 150 151 152 153 154 155 156 157 158 159 def fork_session ( self , source_session_id : str ) -> str : \"\"\"Create a new session by copying events and summary from another.\"\"\" events = self . load_transcript ( source_session_id ) summary = self . load_summary ( source_session_id ) new_session_id = self . create_session () for event in events : self . append_event ( new_session_id , event ) if summary : self . save_summary ( new_session_id , summary ) return new_session_id","title":"fork_session"},{"location":"reference/#meeseeks_core.session_store.SessionStore.is_archived","text":"Return True if a session is archived. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 193 194 195 196 197 def is_archived ( self , session_id : str ) -> bool : \"\"\"Return True if a session is archived.\"\"\" index = self . _load_index () archived = index . get ( \"archived\" , {}) return session_id in archived","title":"is_archived"},{"location":"reference/#meeseeks_core.session_store.SessionStore.list_sessions","text":"List all session IDs present in the root directory. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 140 141 142 143 144 145 146 147 148 def list_sessions ( self ) -> list [ str ]: \"\"\"List all session IDs present in the root directory.\"\"\" if not os . path . exists ( self . root_dir ): return [] return sorted ( name for name in os . listdir ( self . root_dir ) if os . path . isdir ( os . path . join ( self . root_dir , name )) )","title":"list_sessions"},{"location":"reference/#meeseeks_core.session_store.SessionStore.list_tags","text":"Return a mapping of tags to session IDs. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 172 173 174 175 def list_tags ( self ) -> dict [ str , str ]: \"\"\"Return a mapping of tags to session IDs.\"\"\" index = self . _load_index () return dict ( index . get ( \"tags\" , {}))","title":"list_tags"},{"location":"reference/#meeseeks_core.session_store.SessionStore.load_recent_events","text":"Load the most recent events, optionally filtered by type. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 110 111 112 113 114 115 116 117 118 119 120 121 122 def load_recent_events ( self , session_id : str , limit : int = 8 , include_types : set [ str ] | None = None , ) -> list [ EventRecord ]: \"\"\"Load the most recent events, optionally filtered by type.\"\"\" events = self . load_transcript ( session_id ) if include_types : events = [ event for event in events if event . get ( \"type\" ) in include_types ] if limit <= 0 : return [] return events [ - limit :]","title":"load_recent_events"},{"location":"reference/#meeseeks_core.session_store.SessionStore.load_summary","text":"Load a previously saved summary, if present. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 131 132 133 134 135 136 137 138 def load_summary ( self , session_id : str ) -> str | None : \"\"\"Load a previously saved summary, if present.\"\"\" paths = self . _paths ( session_id ) if not os . path . exists ( paths . summary_path ): return None with open ( paths . summary_path , encoding = \"utf-8\" ) as handle : data = json . load ( handle ) return data . get ( \"summary\" )","title":"load_summary"},{"location":"reference/#meeseeks_core.session_store.SessionStore.load_transcript","text":"Load all transcript events for a session. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 def load_transcript ( self , session_id : str ) -> list [ EventRecord ]: \"\"\"Load all transcript events for a session.\"\"\" paths = self . _paths ( session_id ) if not os . path . exists ( paths . transcript_path ): return [] events : list [ EventRecord ] = [] with open ( paths . transcript_path , encoding = \"utf-8\" ) as handle : for line in handle : line = line . strip () if not line : continue try : events . append ( json . loads ( line )) except json . JSONDecodeError : logging . warning ( \"Skipping malformed transcript line.\" ) return events","title":"load_transcript"},{"location":"reference/#meeseeks_core.session_store.SessionStore.resolve_tag","text":"Resolve a tag to a session ID, if present. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 167 168 169 170 def resolve_tag ( self , tag : str ) -> str | None : \"\"\"Resolve a tag to a session ID, if present.\"\"\" index = self . _load_index () return index . get ( \"tags\" , {}) . get ( tag )","title":"resolve_tag"},{"location":"reference/#meeseeks_core.session_store.SessionStore.save_summary","text":"Persist a summary for a session. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 124 125 126 127 128 129 def save_summary ( self , session_id : str , summary : str ) -> None : \"\"\"Persist a summary for a session.\"\"\" paths = self . _paths ( session_id ) os . makedirs ( paths . session_dir , exist_ok = True ) with open ( paths . summary_path , \"w\" , encoding = \"utf-8\" ) as handle : json . dump ({ \"summary\" : summary , \"updated_at\" : _utc_now ()}, handle , indent = 2 )","title":"save_summary"},{"location":"reference/#meeseeks_core.session_store.SessionStore.tag_session","text":"Associate a tag with a session ID for quick lookup. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 161 162 163 164 165 def tag_session ( self , session_id : str , tag : str ) -> None : \"\"\"Associate a tag with a session ID for quick lookup.\"\"\" index = self . _load_index () index . setdefault ( \"tags\" , {})[ tag ] = session_id self . _save_index ( index )","title":"tag_session"},{"location":"reference/#meeseeks_core.session_store.SessionStore.unarchive_session","text":"Remove archived status from a session. Source code in packages/meeseeks_core/src/meeseeks_core/session_store.py 184 185 186 187 188 189 190 191 def unarchive_session ( self , session_id : str ) -> None : \"\"\"Remove archived status from a session.\"\"\" index = self . _load_index () archived = index . get ( \"archived\" , {}) if session_id in archived : archived . pop ( session_id , None ) index [ \"archived\" ] = archived self . _save_index ( index )","title":"unarchive_session"},{"location":"reference/#meeseeks_core.context","text":"Context selection and rendering helpers.","title":"context"},{"location":"reference/#meeseeks_core.context.ContextBuilder","text":"Build short-term and selected context for a session. Source code in packages/meeseeks_core/src/meeseeks_core/context.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 class ContextBuilder : \"\"\"Build short-term and selected context for a session.\"\"\" def __init__ ( self , session_store : SessionStore ) -> None : \"\"\"Initialize the context builder.\"\"\" self . _session_store = session_store def build ( self , session_id : str , user_query : str , model_name : str | None , ) -> ContextSnapshot : \"\"\"Build a context snapshot for planning and synthesis.\"\"\" events = self . _session_store . load_transcript ( session_id ) summary = self . _session_store . load_summary ( session_id ) context_events = [ event for event in events if event . get ( \"type\" ) in { \"user\" , \"assistant\" , \"tool_result\" , \"step_reflection\" , } ] recent_limit = int ( get_config_value ( \"context\" , \"recent_event_limit\" , default = 8 )) recent_events = context_events [ - recent_limit :] if recent_limit > 0 else [] candidate_events = context_events [: - recent_limit ] if recent_limit > 0 else context_events budget = get_token_budget ( events , summary , model_name ) selected_events : list [ EventRecord ] | None = None selection_threshold = float ( get_config_value ( \"context\" , \"selection_threshold\" , default = 0.8 )) if ( bool ( get_config_value ( \"context\" , \"selection_enabled\" , default = True )) and candidate_events and budget . utilization >= selection_threshold ): selected_events = self . _select_context_events ( candidate_events , user_query = user_query , model_name = model_name , ) return ContextSnapshot ( summary = summary , recent_events = recent_events , selected_events = selected_events , events = events , budget = budget , ) def _select_context_events ( self , events : list [ EventRecord ], user_query : str , model_name : str | None , ) -> list [ EventRecord ]: if not events : return [] selector_model = ( get_config_value ( \"context\" , \"context_selector_model\" ) or model_name or get_config_value ( \"llm\" , \"action_plan_model\" ) or get_config_value ( \"llm\" , \"default_model\" ) ) if not selector_model : return events parser = PydanticOutputParser ( pydantic_object = ContextSelection ) # type: ignore[type-var] prompt = ChatPromptTemplate ( messages = [ SystemMessage ( content = ( \"You select which prior events are still relevant to the user's \" \"current request. Keep only events that directly help answer the \" \"current query. If unsure, keep the event.\" ) ), HumanMessagePromptTemplate . from_template ( \"User query: \\n {user_query} \\n\\n \" \"Candidate events: \\n {candidates} \\n\\n \" \"Return keep_ids and drop_ids. \\n {format_instructions} \" ), ], partial_variables = { \"format_instructions\" : parser . get_format_instructions ()}, input_variables = [ \"user_query\" , \"candidates\" ], ) lines : list [ str ] = [] for idx , event in enumerate ( events , start = 1 ): text = event_payload_text ( event ) if not text : continue lines . append ( f \" { idx } . { event . get ( 'type' , 'event' ) } : { text } \" ) candidates_text = \" \\n \" . join ( lines ) . strip () if not candidates_text : return events model = build_chat_model ( model_name = selector_model , openai_api_base = get_config_value ( \"llm\" , \"api_base\" ), api_key = get_config_value ( \"llm\" , \"api_key\" ), ) handler = build_langfuse_handler ( user_id = \"meeseeks-context\" , session_id = f \"context- { os . getpid () } - { os . urandom ( 4 ) . hex () } \" , trace_name = \"meeseeks-context\" , version = get_config_value ( \"runtime\" , \"version\" , default = \"Not Specified\" ), release = get_config_value ( \"runtime\" , \"envmode\" , default = \"Not Specified\" ), ) config : dict [ str , object ] = {} if handler is not None : config [ \"callbacks\" ] = [ handler ] metadata = getattr ( handler , \"langfuse_metadata\" , None ) if isinstance ( metadata , dict ) and metadata : config [ \"metadata\" ] = metadata try : with langfuse_trace_span ( \"context-select\" ) as span : if span is not None : try : span . update_trace ( input = { \"user_query\" : user_query . strip (), \"candidate_count\" : len ( lines ), } ) except Exception : pass selection = ( prompt | model | parser ) . invoke ( { \"user_query\" : user_query . strip (), \"candidates\" : candidates_text }, config = config or None , ) if span is not None : try : span . update_trace ( output = { \"keep_ids\" : selection . keep_ids , \"drop_ids\" : selection . drop_ids , } ) except Exception : pass except Exception as exc : # pragma: no cover - defensive logging . warning ( \"Context selection failed: {} \" , exc ) return events [ - 3 :] keep_ids = set ( selection . keep_ids or []) if not keep_ids : return events [ - 3 :] kept : list [ EventRecord ] = [] for idx , event in enumerate ( events , start = 1 ): if idx in keep_ids : kept . append ( event ) return kept or events [ - 3 :]","title":"ContextBuilder"},{"location":"reference/#meeseeks_core.context.ContextBuilder.__init__","text":"Initialize the context builder. Source code in packages/meeseeks_core/src/meeseeks_core/context.py 70 71 72 def __init__ ( self , session_store : SessionStore ) -> None : \"\"\"Initialize the context builder.\"\"\" self . _session_store = session_store","title":"__init__"},{"location":"reference/#meeseeks_core.context.ContextBuilder.build","text":"Build a context snapshot for planning and synthesis. Source code in packages/meeseeks_core/src/meeseeks_core/context.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 def build ( self , session_id : str , user_query : str , model_name : str | None , ) -> ContextSnapshot : \"\"\"Build a context snapshot for planning and synthesis.\"\"\" events = self . _session_store . load_transcript ( session_id ) summary = self . _session_store . load_summary ( session_id ) context_events = [ event for event in events if event . get ( \"type\" ) in { \"user\" , \"assistant\" , \"tool_result\" , \"step_reflection\" , } ] recent_limit = int ( get_config_value ( \"context\" , \"recent_event_limit\" , default = 8 )) recent_events = context_events [ - recent_limit :] if recent_limit > 0 else [] candidate_events = context_events [: - recent_limit ] if recent_limit > 0 else context_events budget = get_token_budget ( events , summary , model_name ) selected_events : list [ EventRecord ] | None = None selection_threshold = float ( get_config_value ( \"context\" , \"selection_threshold\" , default = 0.8 )) if ( bool ( get_config_value ( \"context\" , \"selection_enabled\" , default = True )) and candidate_events and budget . utilization >= selection_threshold ): selected_events = self . _select_context_events ( candidate_events , user_query = user_query , model_name = model_name , ) return ContextSnapshot ( summary = summary , recent_events = recent_events , selected_events = selected_events , events = events , budget = budget , )","title":"build"},{"location":"reference/#meeseeks_core.context.ContextSelection","text":"Bases: BaseModel Model output for selecting context events. Source code in packages/meeseeks_core/src/meeseeks_core/context.py 25 26 27 28 29 class ContextSelection ( BaseModel ): \"\"\"Model output for selecting context events.\"\"\" keep_ids : list [ int ] = Field ( default_factory = list ) drop_ids : list [ int ] = Field ( default_factory = list )","title":"ContextSelection"},{"location":"reference/#meeseeks_core.context.ContextSnapshot","text":"Context snapshot for planning and synthesis. Source code in packages/meeseeks_core/src/meeseeks_core/context.py 32 33 34 35 36 37 38 39 40 @dataclass ( frozen = True ) class ContextSnapshot : \"\"\"Context snapshot for planning and synthesis.\"\"\" summary : str | None recent_events : list [ EventRecord ] selected_events : list [ EventRecord ] | None events : list [ EventRecord ] budget : TokenBudget","title":"ContextSnapshot"},{"location":"reference/#meeseeks_core.context.event_payload_text","text":"Return a readable payload string for an event. Source code in packages/meeseeks_core/src/meeseeks_core/context.py 43 44 45 46 47 48 49 50 51 52 53 def event_payload_text ( event : EventRecord ) -> str : \"\"\"Return a readable payload string for an event.\"\"\" payload = event . get ( \"payload\" , \"\" ) if isinstance ( payload , dict ): if \"tool_input\" in payload : payload = dict ( payload ) payload [ \"tool_input\" ] = format_tool_input ( payload . get ( \"tool_input\" )) return str ( payload . get ( \"text\" ) or payload . get ( \"message\" ) or payload . get ( \"result\" ) or payload ) return str ( payload )","title":"event_payload_text"},{"location":"reference/#meeseeks_core.context.render_event_lines","text":"Render events into bullet lines for prompts. Source code in packages/meeseeks_core/src/meeseeks_core/context.py 56 57 58 59 60 61 62 63 64 def render_event_lines ( events : list [ EventRecord ]) -> str : \"\"\"Render events into bullet lines for prompts.\"\"\" lines : list [ str ] = [] for event in events : text = event_payload_text ( event ) if not text : continue lines . append ( f \"- { event . get ( 'type' , 'event' ) } : { text } \" ) return \" \\n \" . join ( lines ) . strip ()","title":"render_event_lines"},{"location":"reference/#meeseeks_core.compaction","text":"Transcript compaction utilities.","title":"compaction"},{"location":"reference/#meeseeks_core.compaction.should_compact","text":"Return True when the event list meets the compaction threshold. Parameters: Name Type Description Default events Iterable [ EventRecord ] Iterable of event records to count. required threshold int Minimum number of events that triggers compaction. 50 Returns: Type Description bool True when compaction should run. Source code in packages/meeseeks_core/src/meeseeks_core/compaction.py 40 41 42 43 44 45 46 47 48 49 50 def should_compact ( events : Iterable [ EventRecord ], threshold : int = 50 ) -> bool : \"\"\"Return True when the event list meets the compaction threshold. Args: events: Iterable of event records to count. threshold: Minimum number of events that triggers compaction. Returns: True when compaction should run. \"\"\" return len ( list ( events )) >= threshold","title":"should_compact"},{"location":"reference/#meeseeks_core.compaction.summarize_events","text":"Generate a lightweight summary of recent events. Parameters: Name Type Description Default events Iterable [ EventRecord ] Iterable of event records to summarize. required max_items int Maximum number of recent events to include. 20 Returns: Type Description str Concise summary string of recent events. Source code in packages/meeseeks_core/src/meeseeks_core/compaction.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def summarize_events ( events : Iterable [ EventRecord ], max_items : int = 20 ) -> str : \"\"\"Generate a lightweight summary of recent events. Args: events: Iterable of event records to summarize. max_items: Maximum number of recent events to include. Returns: Concise summary string of recent events. \"\"\" snippets : list [ str ] = [] for event in list ( events )[ - max_items :]: event_type = event . get ( \"type\" , \"event\" ) payload_value : object = event . get ( \"payload\" , \"\" ) if isinstance ( payload_value , dict ): payload_data = dict ( payload_value ) payload_value = ( payload_data . get ( \"text\" ) or payload_data . get ( \"message\" ) or str ( payload_data ) ) if payload_value : snippets . append ( f \" { event_type } : { payload_value } \" ) else : snippets . append ( f \" { event_type } .\" ) return \" | \" . join ( snippets ) . strip ()","title":"summarize_events"},{"location":"reference/#meeseeks_core.token_budget","text":"Token budgeting utilities.","title":"token_budget"},{"location":"reference/#meeseeks_core.token_budget.TokenBudget","text":"Token accounting snapshot used to decide compaction. Source code in packages/meeseeks_core/src/meeseeks_core/token_budget.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @dataclass ( frozen = True ) class TokenBudget : \"\"\"Token accounting snapshot used to decide compaction.\"\"\" total_tokens : int summary_tokens : int event_tokens : int context_window : int remaining_tokens : int utilization : float threshold : float @property def needs_compact ( self ) -> bool : \"\"\"Return True when utilization exceeds the configured threshold.\"\"\" return self . utilization >= self . threshold","title":"TokenBudget"},{"location":"reference/#meeseeks_core.token_budget.TokenBudget.needs_compact","text":"Return True when utilization exceeds the configured threshold.","title":"needs_compact"},{"location":"reference/#meeseeks_core.token_budget.estimate_event_tokens","text":"Estimate total tokens for a sequence of events. Source code in packages/meeseeks_core/src/meeseeks_core/token_budget.py 84 85 86 87 88 89 90 def estimate_event_tokens ( events : Iterable [ EventRecord ]) -> int : \"\"\"Estimate total tokens for a sequence of events.\"\"\" texts = [ _event_to_text ( event ) for event in events ] joined = \" \\n \" . join ( text for text in texts if text ) if not joined : return 0 return num_tokens_from_string ( joined )","title":"estimate_event_tokens"},{"location":"reference/#meeseeks_core.token_budget.estimate_summary_tokens","text":"Estimate token usage for the stored summary. Source code in packages/meeseeks_core/src/meeseeks_core/token_budget.py 93 94 95 96 97 def estimate_summary_tokens ( summary : str | None ) -> int : \"\"\"Estimate token usage for the stored summary.\"\"\" if not summary : return 0 return num_tokens_from_string ( summary )","title":"estimate_summary_tokens"},{"location":"reference/#meeseeks_core.token_budget.get_context_window","text":"Resolve the context window for a model name or default. Source code in packages/meeseeks_core/src/meeseeks_core/token_budget.py 58 59 60 61 62 63 64 65 66 67 68 69 def get_context_window ( model_name : str | None ) -> int : \"\"\"Resolve the context window for a model name or default.\"\"\" default_window = int ( get_config_value ( \"token_budget\" , \"default_context_window\" , default = 128000 )) if not model_name : return default_window overrides = _load_context_overrides () if model_name in overrides : return overrides [ model_name ] parsed = _parse_context_from_model ( model_name ) if parsed : return parsed return default_window","title":"get_context_window"},{"location":"reference/#meeseeks_core.token_budget.get_token_budget","text":"Calculate token utilization and remaining context budget. Source code in packages/meeseeks_core/src/meeseeks_core/token_budget.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 def get_token_budget ( events : Iterable [ EventRecord ], summary : str | None , model_name : str | None , threshold : float | None = None , ) -> TokenBudget : \"\"\"Calculate token utilization and remaining context budget.\"\"\" event_tokens = estimate_event_tokens ( events ) summary_tokens = estimate_summary_tokens ( summary ) total_tokens = event_tokens + summary_tokens context_window = get_context_window ( model_name ) remaining_tokens = max ( context_window - total_tokens , 0 ) if threshold is None : threshold = float ( get_config_value ( \"token_budget\" , \"auto_compact_threshold\" , default = 0.8 )) utilization = total_tokens / context_window if context_window else 0.0 return TokenBudget ( total_tokens = total_tokens , summary_tokens = summary_tokens , event_tokens = event_tokens , context_window = context_window , remaining_tokens = remaining_tokens , utilization = utilization , threshold = threshold , )","title":"get_token_budget"},{"location":"reference/#meeseeks_core.tool_registry","text":"Tool registry and manifest loading for Meeseeks.","title":"tool_registry"},{"location":"reference/#meeseeks_core.tool_registry.ToolRegistry","text":"Registry of configured tools and their instantiated runners. Source code in packages/meeseeks_core/src/meeseeks_core/tool_registry.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 class ToolRegistry : \"\"\"Registry of configured tools and their instantiated runners.\"\"\" def __init__ ( self ) -> None : \"\"\"Initialize an empty registry.\"\"\" self . _tools : dict [ str , ToolSpec ] = {} self . _instances : dict [ str , ToolRunner ] = {} def disable ( self , tool_id : str , reason : str ) -> None : \"\"\"Disable a tool and store a reason for later reporting.\"\"\" spec = self . _tools . get ( tool_id ) if spec is None : return metadata = dict ( spec . metadata ) metadata [ \"disabled_reason\" ] = reason self . _tools [ tool_id ] = ToolSpec ( tool_id = spec . tool_id , name = spec . name , description = spec . description , factory = spec . factory , enabled = False , kind = spec . kind , prompt_path = spec . prompt_path , metadata = metadata , ) if tool_id in self . _instances : self . _instances . pop ( tool_id , None ) set_available_tools ( [ current_id for current_id , current_spec in self . _tools . items () if current_spec . enabled ] ) def register ( self , spec : ToolSpec ) -> None : \"\"\"Register a tool specification and update action validation.\"\"\" self . _tools [ spec . tool_id ] = spec set_available_tools ( [ tool_id for tool_id , tool_spec in self . _tools . items () if tool_spec . enabled ] ) def get ( self , tool_id : str ) -> ToolRunner | None : \"\"\"Return an enabled tool runner, instantiating it if needed.\"\"\" spec = self . _tools . get ( tool_id ) if spec is None or not spec . enabled : return None if tool_id not in self . _instances : try : self . _instances [ tool_id ] = spec . factory () except Exception as exc : # pragma: no cover - defensive reason = f \"Initialization failed: { exc } \" logging . warning ( \"Disabling tool {} : {} \" , tool_id , reason ) self . disable ( tool_id , reason ) return None return self . _instances [ tool_id ] def get_spec ( self , tool_id : str ) -> ToolSpec | None : \"\"\"Return the tool specification, even if disabled.\"\"\" return self . _tools . get ( tool_id ) def list_specs ( self , include_disabled : bool = False ) -> list [ ToolSpec ]: \"\"\"List tool specifications, optionally including disabled tools.\"\"\" specs = list ( self . _tools . values ()) if include_disabled : return specs return [ spec for spec in specs if spec . enabled ] def list_specs_for_mode ( self , mode : str , * , include_disabled : bool = False ) -> list [ ToolSpec ]: \"\"\"List specs filtered by orchestration mode.\"\"\" specs = self . list_specs ( include_disabled = include_disabled ) if mode != \"plan\" : return specs return [ spec for spec in specs if spec . is_plan_safe ()] def tool_catalog ( self ) -> list [ dict [ str , str ]]: \"\"\"Return a serialized catalog of registered tool metadata.\"\"\" return [ { \"tool_id\" : spec . tool_id , \"name\" : spec . name , \"description\" : spec . description , } for spec in self . list_specs () ]","title":"ToolRegistry"},{"location":"reference/#meeseeks_core.tool_registry.ToolRegistry.__init__","text":"Initialize an empty registry. Source code in packages/meeseeks_core/src/meeseeks_core/tool_registry.py 65 66 67 68 def __init__ ( self ) -> None : \"\"\"Initialize an empty registry.\"\"\" self . _tools : dict [ str , ToolSpec ] = {} self . _instances : dict [ str , ToolRunner ] = {}","title":"__init__"},{"location":"reference/#meeseeks_core.tool_registry.ToolRegistry.disable","text":"Disable a tool and store a reason for later reporting. Source code in packages/meeseeks_core/src/meeseeks_core/tool_registry.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 def disable ( self , tool_id : str , reason : str ) -> None : \"\"\"Disable a tool and store a reason for later reporting.\"\"\" spec = self . _tools . get ( tool_id ) if spec is None : return metadata = dict ( spec . metadata ) metadata [ \"disabled_reason\" ] = reason self . _tools [ tool_id ] = ToolSpec ( tool_id = spec . tool_id , name = spec . name , description = spec . description , factory = spec . factory , enabled = False , kind = spec . kind , prompt_path = spec . prompt_path , metadata = metadata , ) if tool_id in self . _instances : self . _instances . pop ( tool_id , None ) set_available_tools ( [ current_id for current_id , current_spec in self . _tools . items () if current_spec . enabled ] )","title":"disable"},{"location":"reference/#meeseeks_core.tool_registry.ToolRegistry.get","text":"Return an enabled tool runner, instantiating it if needed. Source code in packages/meeseeks_core/src/meeseeks_core/tool_registry.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 def get ( self , tool_id : str ) -> ToolRunner | None : \"\"\"Return an enabled tool runner, instantiating it if needed.\"\"\" spec = self . _tools . get ( tool_id ) if spec is None or not spec . enabled : return None if tool_id not in self . _instances : try : self . _instances [ tool_id ] = spec . factory () except Exception as exc : # pragma: no cover - defensive reason = f \"Initialization failed: { exc } \" logging . warning ( \"Disabling tool {} : {} \" , tool_id , reason ) self . disable ( tool_id , reason ) return None return self . _instances [ tool_id ]","title":"get"},{"location":"reference/#meeseeks_core.tool_registry.ToolRegistry.get_spec","text":"Return the tool specification, even if disabled. Source code in packages/meeseeks_core/src/meeseeks_core/tool_registry.py 115 116 117 def get_spec ( self , tool_id : str ) -> ToolSpec | None : \"\"\"Return the tool specification, even if disabled.\"\"\" return self . _tools . get ( tool_id )","title":"get_spec"},{"location":"reference/#meeseeks_core.tool_registry.ToolRegistry.list_specs","text":"List tool specifications, optionally including disabled tools. Source code in packages/meeseeks_core/src/meeseeks_core/tool_registry.py 119 120 121 122 123 124 def list_specs ( self , include_disabled : bool = False ) -> list [ ToolSpec ]: \"\"\"List tool specifications, optionally including disabled tools.\"\"\" specs = list ( self . _tools . values ()) if include_disabled : return specs return [ spec for spec in specs if spec . enabled ]","title":"list_specs"},{"location":"reference/#meeseeks_core.tool_registry.ToolRegistry.list_specs_for_mode","text":"List specs filtered by orchestration mode. Source code in packages/meeseeks_core/src/meeseeks_core/tool_registry.py 126 127 128 129 130 131 def list_specs_for_mode ( self , mode : str , * , include_disabled : bool = False ) -> list [ ToolSpec ]: \"\"\"List specs filtered by orchestration mode.\"\"\" specs = self . list_specs ( include_disabled = include_disabled ) if mode != \"plan\" : return specs return [ spec for spec in specs if spec . is_plan_safe ()]","title":"list_specs_for_mode"},{"location":"reference/#meeseeks_core.tool_registry.ToolRegistry.register","text":"Register a tool specification and update action validation. Source code in packages/meeseeks_core/src/meeseeks_core/tool_registry.py 93 94 95 96 97 98 def register ( self , spec : ToolSpec ) -> None : \"\"\"Register a tool specification and update action validation.\"\"\" self . _tools [ spec . tool_id ] = spec set_available_tools ( [ tool_id for tool_id , tool_spec in self . _tools . items () if tool_spec . enabled ] )","title":"register"},{"location":"reference/#meeseeks_core.tool_registry.ToolRegistry.tool_catalog","text":"Return a serialized catalog of registered tool metadata. Source code in packages/meeseeks_core/src/meeseeks_core/tool_registry.py 133 134 135 136 137 138 139 140 141 142 def tool_catalog ( self ) -> list [ dict [ str , str ]]: \"\"\"Return a serialized catalog of registered tool metadata.\"\"\" return [ { \"tool_id\" : spec . tool_id , \"name\" : spec . name , \"description\" : spec . description , } for spec in self . list_specs () ]","title":"tool_catalog"},{"location":"reference/#meeseeks_core.tool_registry.ToolRunner","text":"Bases: Protocol Source code in packages/meeseeks_core/src/meeseeks_core/tool_registry.py 32 33 34 35 36 37 38 39 40 41 class ToolRunner ( Protocol ): def run ( self , action_step : ActionStep ) -> MockSpeaker : # pragma: no cover \"\"\"Execute an action step and return a speaker response. Args: action_step: Action step payload to execute. Returns: MockSpeaker response from the tool. \"\"\"","title":"ToolRunner"},{"location":"reference/#meeseeks_core.tool_registry.ToolRunner.run","text":"Execute an action step and return a speaker response. Parameters: Name Type Description Default action_step ActionStep Action step payload to execute. required Returns: Type Description MockSpeaker MockSpeaker response from the tool. Source code in packages/meeseeks_core/src/meeseeks_core/tool_registry.py 33 34 35 36 37 38 39 40 41 def run ( self , action_step : ActionStep ) -> MockSpeaker : # pragma: no cover \"\"\"Execute an action step and return a speaker response. Args: action_step: Action step payload to execute. Returns: MockSpeaker response from the tool. \"\"\"","title":"run"},{"location":"reference/#meeseeks_core.tool_registry.ToolSpec","text":"Metadata describing a tool available to the assistant. Source code in packages/meeseeks_core/src/meeseeks_core/tool_registry.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 @dataclass ( frozen = True ) class ToolSpec : \"\"\"Metadata describing a tool available to the assistant.\"\"\" tool_id : str name : str description : str factory : Callable [[], ToolRunner ] enabled : bool = True kind : str = \"local\" prompt_path : str | None = None metadata : dict [ str , JsonValue ] = field ( default_factory = dict ) def is_plan_safe ( self ) -> bool : \"\"\"Return True if the tool is safe to use in plan mode.\"\"\" return bool ( self . metadata . get ( \"plan_safe\" ))","title":"ToolSpec"},{"location":"reference/#meeseeks_core.tool_registry.ToolSpec.is_plan_safe","text":"Return True if the tool is safe to use in plan mode. Source code in packages/meeseeks_core/src/meeseeks_core/tool_registry.py 57 58 59 def is_plan_safe ( self ) -> bool : \"\"\"Return True if the tool is safe to use in plan mode.\"\"\" return bool ( self . metadata . get ( \"plan_safe\" ))","title":"is_plan_safe"},{"location":"reference/#meeseeks_core.tool_registry.load_registry","text":"Load tool registry, auto-discovering MCP tools when configured. Source code in packages/meeseeks_core/src/meeseeks_core/tool_registry.py 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 def load_registry ( manifest_path : str | None = None ) -> ToolRegistry : \"\"\"Load tool registry, auto-discovering MCP tools when configured.\"\"\" if manifest_path is None : mcp_config_path = get_mcp_config_path () if mcp_config_path and os . path . exists ( mcp_config_path ): manifest_path = _ensure_auto_manifest ( mcp_config_path ) if not manifest_path : return _default_registry () manifest_path = os . path . abspath ( manifest_path ) if not os . path . exists ( manifest_path ): logging . warning ( \"Tool manifest not found: {} \" , manifest_path ) return _default_registry () try : with open ( manifest_path , encoding = \"utf-8\" ) as handle : manifest = json . load ( handle ) except Exception as exc : # pragma: no cover - defensive logging . error ( \"Failed to load tool manifest: {} \" , exc ) return _default_registry () registry = ToolRegistry () for tool in manifest . get ( \"tools\" , []): kind = tool . get ( \"kind\" , \"local\" ) prompt_path = tool . get ( \"prompt\" ) if kind == \"local\" : module_path = tool . get ( \"module\" ) class_name = tool . get ( \"class\" ) if not module_path or not class_name : logging . warning ( \"Skipping tool with missing module/class: {} \" , tool ) continue factory = _import_factory ( module_path , class_name ) else : mcp_module = _load_mcp_support () if mcp_module is None : logging . warning ( \"Skipping MCP tool because MCP support is not installed: {} \" , tool , ) continue MCPToolRunner = mcp_module . MCPToolRunner server_name = tool . get ( \"server\" ) tool_name = tool . get ( \"tool\" ) if not server_name or not tool_name : logging . warning ( \"Skipping MCP tool with missing server/tool: {} \" , tool ) continue def _mcp_factory ( server_name : str = server_name , tool_name : str = tool_name , ) -> ToolRunner : return MCPToolRunner ( server_name = server_name , tool_name = tool_name ) factory = _mcp_factory spec = ToolSpec ( tool_id = tool . get ( \"tool_id\" , \"\" ), name = tool . get ( \"name\" , tool . get ( \"tool_id\" , \"\" )), description = tool . get ( \"description\" , \"\" ), factory = factory , enabled = tool . get ( \"enabled\" , True ), kind = kind , prompt_path = prompt_path , metadata = { key : value for key , value in tool . items () if key not in { \"tool_id\" , \"name\" , \"description\" , \"module\" , \"class\" , \"enabled\" , \"kind\" , \"prompt\" , } }, ) if not spec . tool_id : logging . warning ( \"Skipping tool with empty tool_id: {} \" , tool ) continue registry . register ( spec ) if not registry . list_specs ( include_disabled = True ): return _default_registry () builtin_registry = _default_registry () existing_ids = { spec . tool_id for spec in registry . list_specs ( include_disabled = True )} for spec in builtin_registry . list_specs ( include_disabled = True ): if spec . tool_id in existing_ids : continue registry . register ( spec ) existing_ids . add ( spec . tool_id ) set_available_tools ([ spec . tool_id for spec in registry . list_specs ()]) return registry","title":"load_registry"},{"location":"reference/#meeseeks_core.classes","text":"Core data models and tool abstractions for Meeseeks orchestration.","title":"classes"},{"location":"reference/#meeseeks_core.classes.AbstractTool","text":"Bases: ABC Base tool with shared initialization helpers. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 class AbstractTool ( abc . ABC ): \"\"\"Base tool with shared initialization helpers.\"\"\" def __init__ ( self , name : str , description : str , model_name : str | None = None , use_llm : bool = True , ) -> None : \"\"\"Initialize tool configuration.\"\"\" tool_model = get_config_value ( \"llm\" , \"tool_model\" ) default_model = get_config_value ( \"llm\" , \"default_model\" , default = \"gpt-5.2\" ) self . model_name = cast ( str , model_name or tool_model or default_model , ) self . name = name self . description = description self . use_llm = use_llm self . _id = f \" { name . lower () . replace ( ' ' , '_' ) } _tool\" session_id = f \" { self . _id } -tool-id- { get_unique_timestamp () } \" logging . info ( f \"Tool created <name= { name } ; session_id= { session_id } ;>\" ) self . langfuse_handler = build_langfuse_handler ( user_id = f \"meeseeks- { name } \" , session_id = session_id , trace_name = f \"meeseeks- { self . _id } \" , version = get_config_value ( \"runtime\" , \"version\" , default = \"Not Specified\" ), release = get_config_value ( \"runtime\" , \"envmode\" , default = \"Not Specified\" ), ) self . model = None if self . use_llm : self . model = build_chat_model ( model_name = self . model_name , openai_api_base = get_config_value ( \"llm\" , \"api_base\" ), api_key = get_config_value ( \"llm\" , \"api_key\" ), ) root_cache_dir = get_config_value ( \"runtime\" , \"cache_dir\" , default = \".cache\" ) if not root_cache_dir : raise ValueError ( \"runtime.cache_dir is not set.\" ) self . cache_dir = os . path . abspath ( os . path . join ( str ( root_cache_dir ), self . _id )) logging . debug ( \" {} cache directory is {} .\" , self . _id , self . cache_dir ) def _save_json ( self , data : object , filename : str ) -> None : \"\"\"Persist JSON data under the cache directory.\"\"\" if not os . path . exists ( self . cache_dir ): os . makedirs ( self . cache_dir ) filename = os . path . join ( self . cache_dir , filename ) with open ( filename , \"w\" , encoding = \"utf-8\" ) as f : json . dump ( data , f , indent = 4 ) logging . info ( f \"Data saved to { filename } .\" ) def _load_rag_json ( self , filename : str ) -> list [ Document ]: \"\"\"Load JSON content as documents.\"\"\" logging . debug ( \"RAG directory is {} .\" , self . cache_dir ) logging . info ( f \"Loading ` { filename } ` as JSON.\" ) filename = os . path . join ( self . cache_dir , filename ) filename = os . path . abspath ( filename ) loader = JSONLoader ( file_path = filename , jq_schema = \".\" , text_content = False ) data = loader . load () return data def _load_rag_documents ( self , filenames : list [ str ]) -> list [ Document ]: \"\"\"Load and concatenate multiple JSON files.\"\"\" rag_documents : list [ Document ] = [] for rag_file in filenames : data = self . _load_rag_json ( rag_file ) rag_documents . extend ( data ) return rag_documents def set_state ( self , action_step : ActionStep | None = None ) -> MockSpeaker : \"\"\"Perform a state-changing action.\"\"\" MockSpeaker = get_mock_speaker () return MockSpeaker ( content = \"Not implemented yet.\" ) def get_state ( self , action_step : ActionStep | None = None ) -> MockSpeaker : \"\"\"Perform a read-only action.\"\"\" MockSpeaker = get_mock_speaker () return MockSpeaker ( content = \"Not implemented yet.\" ) def run ( self , action_step : ActionStep ) -> MockSpeaker : \"\"\"Execute the action based on the operation.\"\"\" if action_step . operation == \"set\" : return self . set_state ( action_step ) if action_step . operation == \"get\" : return self . get_state ( action_step ) raise ValueError ( f \"Invalid operation: { action_step . operation } \" )","title":"AbstractTool"},{"location":"reference/#meeseeks_core.classes.AbstractTool.__init__","text":"Initialize tool configuration. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 def __init__ ( self , name : str , description : str , model_name : str | None = None , use_llm : bool = True , ) -> None : \"\"\"Initialize tool configuration.\"\"\" tool_model = get_config_value ( \"llm\" , \"tool_model\" ) default_model = get_config_value ( \"llm\" , \"default_model\" , default = \"gpt-5.2\" ) self . model_name = cast ( str , model_name or tool_model or default_model , ) self . name = name self . description = description self . use_llm = use_llm self . _id = f \" { name . lower () . replace ( ' ' , '_' ) } _tool\" session_id = f \" { self . _id } -tool-id- { get_unique_timestamp () } \" logging . info ( f \"Tool created <name= { name } ; session_id= { session_id } ;>\" ) self . langfuse_handler = build_langfuse_handler ( user_id = f \"meeseeks- { name } \" , session_id = session_id , trace_name = f \"meeseeks- { self . _id } \" , version = get_config_value ( \"runtime\" , \"version\" , default = \"Not Specified\" ), release = get_config_value ( \"runtime\" , \"envmode\" , default = \"Not Specified\" ), ) self . model = None if self . use_llm : self . model = build_chat_model ( model_name = self . model_name , openai_api_base = get_config_value ( \"llm\" , \"api_base\" ), api_key = get_config_value ( \"llm\" , \"api_key\" ), ) root_cache_dir = get_config_value ( \"runtime\" , \"cache_dir\" , default = \".cache\" ) if not root_cache_dir : raise ValueError ( \"runtime.cache_dir is not set.\" ) self . cache_dir = os . path . abspath ( os . path . join ( str ( root_cache_dir ), self . _id )) logging . debug ( \" {} cache directory is {} .\" , self . _id , self . cache_dir )","title":"__init__"},{"location":"reference/#meeseeks_core.classes.AbstractTool.get_state","text":"Perform a read-only action. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 231 232 233 234 def get_state ( self , action_step : ActionStep | None = None ) -> MockSpeaker : \"\"\"Perform a read-only action.\"\"\" MockSpeaker = get_mock_speaker () return MockSpeaker ( content = \"Not implemented yet.\" )","title":"get_state"},{"location":"reference/#meeseeks_core.classes.AbstractTool.run","text":"Execute the action based on the operation. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 236 237 238 239 240 241 242 def run ( self , action_step : ActionStep ) -> MockSpeaker : \"\"\"Execute the action based on the operation.\"\"\" if action_step . operation == \"set\" : return self . set_state ( action_step ) if action_step . operation == \"get\" : return self . get_state ( action_step ) raise ValueError ( f \"Invalid operation: { action_step . operation } \" )","title":"run"},{"location":"reference/#meeseeks_core.classes.AbstractTool.set_state","text":"Perform a state-changing action. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 226 227 228 229 def set_state ( self , action_step : ActionStep | None = None ) -> MockSpeaker : \"\"\"Perform a state-changing action.\"\"\" MockSpeaker = get_mock_speaker () return MockSpeaker ( content = \"Not implemented yet.\" )","title":"set_state"},{"location":"reference/#meeseeks_core.classes.ActionStep","text":"Bases: BaseModel Action step with validation metadata. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 class ActionStep ( BaseModel ): \"\"\"Action step with validation metadata.\"\"\" title : str | None = Field ( default = None , description = \"Short header summarizing the task for this step.\" , ) objective : str | None = Field ( default = None , description = \"Brief objective explaining why this step is needed.\" , ) execution_checklist : list [ str ] = Field ( default_factory = list , description = \"Short checklist of execution details for this step.\" , ) expected_output : str | None = Field ( default = None , description = \"Optional description of what success looks like.\" , ) tool_id : str = Field ( description = ( \"Specify the tool_id that should execute the action. \" \"Use only tool IDs listed under Available tools.\" ) ) operation : str = Field ( description = \"Specify the execution type (get/set or execute).\" ) tool_input : ToolInput = Field ( description = ( \"Provide details for the action. If 'task', specify the task to perform. \" \"If 'talk', include the message to speak to the user.\" ) ) result : object | None = Field ( alias = \"_result\" , default = None , description = \"Private field to persist the action status and other data.\" , ) class Config : \"\"\"Allow both alias and field-name population.\"\"\" allow_population_by_field_name = True extra = \"forbid\"","title":"ActionStep"},{"location":"reference/#meeseeks_core.classes.ActionStep.Config","text":"Allow both alias and field-name population. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 70 71 72 73 74 class Config : \"\"\"Allow both alias and field-name population.\"\"\" allow_population_by_field_name = True extra = \"forbid\"","title":"Config"},{"location":"reference/#meeseeks_core.classes.OrchestrationState","text":"Bases: BaseModel State for the orchestration loop. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 143 144 145 146 147 148 149 150 151 152 153 class OrchestrationState ( BaseModel ): \"\"\"State for the orchestration loop.\"\"\" goal : str session_id : str | None = None plan : list [ PlanStep ] = Field ( default_factory = list ) tool_results : list [ str ] = Field ( default_factory = list ) open_questions : list [ str ] = Field ( default_factory = list ) done : bool = False done_reason : str | None = None summary : str | None = None","title":"OrchestrationState"},{"location":"reference/#meeseeks_core.classes.Plan","text":"Bases: BaseModel Plan with human-readable steps. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 84 85 86 87 88 89 90 91 92 class Plan ( BaseModel ): \"\"\"Plan with human-readable steps.\"\"\" human_message : str | None = Field ( alias = \"_human_message\" , default = None , description = \"Human message associated with the plan.\" , ) steps : list [ PlanStep ] = Field ( default_factory = list )","title":"Plan"},{"location":"reference/#meeseeks_core.classes.PlanStep","text":"Bases: BaseModel High-level plan step produced by the planner. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 77 78 79 80 81 class PlanStep ( BaseModel ): \"\"\"High-level plan step produced by the planner.\"\"\" title : str = Field ( description = \"Short title for the step.\" ) description : str = Field ( description = \"One-paragraph description of the step.\" )","title":"PlanStep"},{"location":"reference/#meeseeks_core.classes.TaskQueue","text":"Bases: BaseModel Queue of executed tool steps and results. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 class TaskQueue ( BaseModel ): \"\"\"Queue of executed tool steps and results.\"\"\" human_message : str | None = Field ( alias = \"_human_message\" , default = None , description = \"Human message associated with the task queue.\" , ) plan_steps : list [ PlanStep ] = Field ( default_factory = list ) action_steps : list [ ActionStep ] = Field ( default_factory = list ) task_result : str | None = Field ( alias = \"_task_result\" , default = None , description = \"Store the result for the entire task queue\" ) last_error : str | None = Field ( alias = \"_last_error\" , default = None , description = \"Short description of the most recent tool failure.\" , ) @validator ( \"action_steps\" , allow_reuse = True ) # pylint: disable=E0213,W0613 def validate_actions ( cls , field : list [ ActionStep ]) -> list [ ActionStep ]: \"\"\"Normalize and validate action steps.\"\"\" for action in field : action . tool_id = action . tool_id . lower () action . operation = action . operation . lower () error_msg_list = [] if action . tool_id not in AVAILABLE_TOOLS : error_msg_list . append ( f \"` { action . tool_id } ` is not a valid Assistant tool.\" ) if action . operation not in [ \"get\" , \"set\" , \"execute\" ]: error_msg = f \"` { action . operation } ` is not a valid operation.\" error_msg_list . append ( error_msg ) if action . tool_input is None : error_msg_list . append ( \"Tool input cannot be None.\" ) if error_msg_list : for msg in error_msg_list : logging . error ( msg ) return field","title":"TaskQueue"},{"location":"reference/#meeseeks_core.classes.TaskQueue.validate_actions","text":"Normalize and validate action steps. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 @validator ( \"action_steps\" , allow_reuse = True ) # pylint: disable=E0213,W0613 def validate_actions ( cls , field : list [ ActionStep ]) -> list [ ActionStep ]: \"\"\"Normalize and validate action steps.\"\"\" for action in field : action . tool_id = action . tool_id . lower () action . operation = action . operation . lower () error_msg_list = [] if action . tool_id not in AVAILABLE_TOOLS : error_msg_list . append ( f \"` { action . tool_id } ` is not a valid Assistant tool.\" ) if action . operation not in [ \"get\" , \"set\" , \"execute\" ]: error_msg = f \"` { action . operation } ` is not a valid operation.\" error_msg_list . append ( error_msg ) if action . tool_input is None : error_msg_list . append ( \"Tool input cannot be None.\" ) if error_msg_list : for msg in error_msg_list : logging . error ( msg ) return field","title":"validate_actions"},{"location":"reference/#meeseeks_core.classes.create_plan","text":"Create a Plan from serialized step data. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 260 261 262 263 264 265 266 267 268 269 270 271 def create_plan ( step_data : list [ dict [ str , str ]] | None = None , is_example : bool = True , ) -> Plan : \"\"\"Create a Plan from serialized step data.\"\"\" if step_data is None : raise ValueError ( \"Step data cannot be None.\" ) steps = [ PlanStep ( ** step ) for step in step_data ] plan = Plan ( steps = steps ) if is_example : del plan . human_message return plan","title":"create_plan"},{"location":"reference/#meeseeks_core.classes.create_task_queue","text":"Create a TaskQueue from serialized action data. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 245 246 247 248 249 250 251 252 253 254 255 256 257 def create_task_queue ( action_data : list [ ActionStepPayload ] | None = None , is_example : bool = True , ) -> TaskQueue : \"\"\"Create a TaskQueue from serialized action data.\"\"\" if action_data is None : raise ValueError ( \"Action data cannot be None.\" ) action_steps = [ ActionStep ( ** action ) for action in action_data ] task_queue = TaskQueue ( action_steps = action_steps ) if is_example : del task_queue . human_message return task_queue","title":"create_task_queue"},{"location":"reference/#meeseeks_core.classes.get_task_master_examples","text":"Return serialized example plan data. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 def get_task_master_examples ( example_id : int = 0 , available_tools : Sequence [ str ] | None = None , ) -> str : \"\"\"Return serialized example plan data.\"\"\" if available_tools is None : available_tools = AVAILABLE_TOOLS include_home_assistant = \"home_assistant_tool\" in available_tools if include_home_assistant : examples : list [ list [ dict [ str , str ]]] = [ [ { \"title\" : \"Turn on strip lights\" , \"description\" : \"Use Home Assistant to switch on the strip lights.\" , }, { \"title\" : \"Turn on heater\" , \"description\" : \"Use Home Assistant to switch on the heater.\" , }, ], [ { \"title\" : \"Check weather\" , \"description\" : \"Use Home Assistant to retrieve today's weather details.\" , }, ], ] else : examples = [[], []] if example_id not in range ( 0 , len ( examples )): raise ValueError ( f \"Invalid example ID: { example_id } \" ) return create_plan ( step_data = examples [ example_id ], is_example = True ) . json ()","title":"get_task_master_examples"},{"location":"reference/#meeseeks_core.classes.set_available_tools","text":"Update available tool IDs for validation. Source code in packages/meeseeks_core/src/meeseeks_core/classes.py 26 27 28 29 def set_available_tools ( tool_ids : list [ str ]) -> None : \"\"\"Update available tool IDs for validation.\"\"\" global AVAILABLE_TOOLS AVAILABLE_TOOLS = tool_ids","title":"set_available_tools"},{"location":"reference/#meeseeks_core.types","text":"Shared type definitions for core components.","title":"types"},{"location":"reference/#meeseeks_core.types.ActionPlanPayload","text":"Bases: TypedDict Payload describing an action plan. Source code in packages/meeseeks_core/src/meeseeks_core/types.py 21 22 23 24 class ActionPlanPayload ( TypedDict ): \"\"\"Payload describing an action plan.\"\"\" steps : list [ PlanStepPayload ]","title":"ActionPlanPayload"},{"location":"reference/#meeseeks_core.types.ActionStepPayload","text":"Bases: TypedDict Serialized tool call data sent to/from execution. Source code in packages/meeseeks_core/src/meeseeks_core/types.py 27 28 29 30 31 32 33 34 35 36 class ActionStepPayload ( TypedDict ): \"\"\"Serialized tool call data sent to/from execution.\"\"\" tool_id : str operation : str tool_input : ToolInput title : NotRequired [ str ] objective : NotRequired [ str ] execution_checklist : NotRequired [ list [ str ]] expected_output : NotRequired [ str ]","title":"ActionStepPayload"},{"location":"reference/#meeseeks_core.types.AssistantPayload","text":"Bases: TypedDict Payload describing an assistant response. Source code in packages/meeseeks_core/src/meeseeks_core/types.py 66 67 68 69 class AssistantPayload ( TypedDict ): \"\"\"Payload describing an assistant response.\"\"\" text : str","title":"AssistantPayload"},{"location":"reference/#meeseeks_core.types.CompletionPayload","text":"Bases: TypedDict Payload describing overall completion state. Source code in packages/meeseeks_core/src/meeseeks_core/types.py 72 73 74 75 76 77 78 79 class CompletionPayload ( TypedDict ): \"\"\"Payload describing overall completion state.\"\"\" done : bool done_reason : str | None task_result : str | None error : NotRequired [ str ] last_error : NotRequired [ str ]","title":"CompletionPayload"},{"location":"reference/#meeseeks_core.types.Event","text":"Bases: TypedDict Base event payload stored in transcripts. Source code in packages/meeseeks_core/src/meeseeks_core/types.py 93 94 95 96 97 class Event ( TypedDict ): \"\"\"Base event payload stored in transcripts.\"\"\" type : str payload : EventPayload","title":"Event"},{"location":"reference/#meeseeks_core.types.EventRecord","text":"Bases: Event Event payload with a persisted timestamp. Source code in packages/meeseeks_core/src/meeseeks_core/types.py 100 101 102 103 class EventRecord ( Event ): \"\"\"Event payload with a persisted timestamp.\"\"\" ts : str","title":"EventRecord"},{"location":"reference/#meeseeks_core.types.PermissionPayload","text":"Bases: TypedDict Payload emitted for permission decisions. Source code in packages/meeseeks_core/src/meeseeks_core/types.py 39 40 41 42 43 44 45 class PermissionPayload ( TypedDict ): \"\"\"Payload emitted for permission decisions.\"\"\" tool_id : str operation : str tool_input : str decision : str","title":"PermissionPayload"},{"location":"reference/#meeseeks_core.types.PlanStepPayload","text":"Bases: TypedDict Payload describing a single plan step. Source code in packages/meeseeks_core/src/meeseeks_core/types.py 14 15 16 17 18 class PlanStepPayload ( TypedDict ): \"\"\"Payload describing a single plan step.\"\"\" title : str description : str","title":"PlanStepPayload"},{"location":"reference/#meeseeks_core.types.ToolResultPayload","text":"Bases: TypedDict Payload describing the outcome of a tool invocation. Source code in packages/meeseeks_core/src/meeseeks_core/types.py 48 49 50 51 52 53 54 55 56 57 class ToolResultPayload ( TypedDict ): \"\"\"Payload describing the outcome of a tool invocation.\"\"\" tool_id : str operation : str tool_input : ToolInput result : str | None success : NotRequired [ bool ] summary : NotRequired [ str ] error : NotRequired [ str ]","title":"ToolResultPayload"},{"location":"reference/#meeseeks_core.types.UserPayload","text":"Bases: TypedDict Payload describing a user message. Source code in packages/meeseeks_core/src/meeseeks_core/types.py 60 61 62 63 class UserPayload ( TypedDict ): \"\"\"Payload describing a user message.\"\"\" text : str","title":"UserPayload"},{"location":"reference/#meeseeks_core.config","text":"Central JSON configuration for Meeseeks.","title":"config"},{"location":"reference/#meeseeks_core.config.AppConfig","text":"Bases: BaseModel Typed configuration for the Meeseeks runtime. Source code in packages/meeseeks_core/src/meeseeks_core/config.py 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 class AppConfig ( BaseModel ): \"\"\"Typed configuration for the Meeseeks runtime.\"\"\" runtime : RuntimeConfig = Field ( default_factory = _runtime_config_default ) llm : LLMConfig = Field ( default_factory = _llm_config_default ) context : ContextConfig = Field ( default_factory = _context_config_default ) token_budget : TokenBudgetConfig = Field ( default_factory = _token_budget_config_default ) reflection : ReflectionConfig = Field ( default_factory = _reflection_config_default ) langfuse : LangfuseConfig = Field ( default_factory = _langfuse_config_default ) home_assistant : HomeAssistantConfig = Field ( default_factory = _home_assistant_config_default ) permissions : PermissionsConfig = Field ( default_factory = _permissions_config_default ) cli : CLIConfig = Field ( default_factory = _cli_config_default ) chat : ChatConfig = Field ( default_factory = _chat_config_default ) api : APIConfig = Field ( default_factory = _api_config_default ) class Config : \"\"\"Pydantic configuration settings.\"\"\" extra = \"ignore\" @classmethod def load ( cls , path : str | Path ) -> AppConfig : \"\"\"Load configuration from a JSON file.\"\"\" payload = _load_json ( path ) return cls . parse_obj ( payload ) def to_json ( self , * , indent : int = 2 ) -> str : \"\"\"Serialize config to JSON.\"\"\" return self . json ( indent = indent , exclude_none = True ) def write ( self , path : str | Path , * , indent : int = 2 ) -> None : \"\"\"Write config JSON to disk.\"\"\" target = Path ( path ) target . parent . mkdir ( parents = True , exist_ok = True ) target . write_text ( self . to_json ( indent = indent ) + \" \\n \" , encoding = \"utf-8\" ) async def preflight ( self , * , disable_on_failure : bool = True ) -> dict [ str , dict [ str , Any ]]: \"\"\"Run async validation checks for optional integrations.\"\"\" results : dict [ str , ConfigCheck ] = {} async def _llm_check () -> ConfigCheck : return await asyncio . to_thread ( self . llm . validate_models ) async def _langfuse_check () -> ConfigCheck : enabled , reason , metadata = self . langfuse . evaluate () if not enabled : return ConfigCheck ( name = \"langfuse\" , enabled = False , ok = True , reason = reason , metadata = metadata , ) try : host = self . langfuse . host . rstrip ( \"/\" ) if host : await asyncio . to_thread ( _probe_http , f \" { host } /api/public/health\" ) return ConfigCheck ( name = \"langfuse\" , enabled = True , ok = True ) except ValueError as exc : return ConfigCheck ( name = \"langfuse\" , enabled = True , ok = False , reason = str ( exc )) async def _ha_check () -> ConfigCheck : enabled , reason , metadata = self . home_assistant . evaluate () if not enabled : return ConfigCheck ( name = \"home_assistant\" , enabled = False , ok = True , reason = reason , metadata = metadata , ) try : url = self . home_assistant . url . rstrip ( \"/\" ) headers = { \"Authorization\" : f \"Bearer { self . home_assistant . token } \" } await asyncio . to_thread ( _probe_http , f \" { url } /api/config\" , headers = headers ) return ConfigCheck ( name = \"home_assistant\" , enabled = True , ok = True ) except ValueError as exc : return ConfigCheck ( name = \"home_assistant\" , enabled = True , ok = False , reason = str ( exc )) async def _mcp_check () -> ConfigCheck : config_path = get_mcp_config_path () if not config_path : return ConfigCheck ( name = \"mcp\" , enabled = False , ok = True , reason = \"mcp config disabled\" ) try : from meeseeks_tools.integration import mcp as mcp_module config = mcp_module . _load_mcp_config ( config_path ) tools , failures = await asyncio . to_thread ( mcp_module . discover_mcp_tool_details_with_failures , config ) if failures : return ConfigCheck ( name = \"mcp\" , enabled = True , ok = False , reason = \"mcp discovery failed\" , metadata = { \"failures\" : { k : str ( v ) for k , v in failures . items ()}}, ) return ConfigCheck ( name = \"mcp\" , enabled = True , ok = True , metadata = { \"servers\" : list ( tools . keys ())}, ) except Exception as exc : return ConfigCheck ( name = \"mcp\" , enabled = True , ok = False , reason = str ( exc )) checks = await asyncio . gather ( _llm_check (), _langfuse_check (), _ha_check (), _mcp_check ()) for check in checks : results [ check . name ] = check if disable_on_failure : langfuse_check = results . get ( \"langfuse\" ) if langfuse_check and not langfuse_check . ok and self . langfuse . enabled : self . langfuse . enabled = False ha_check = results . get ( \"home_assistant\" ) if ha_check and not ha_check . ok and self . home_assistant . enabled : self . home_assistant . enabled = False return { name : check . to_dict () for name , check in results . items ()}","title":"AppConfig"},{"location":"reference/#meeseeks_core.config.AppConfig.Config","text":"Pydantic configuration settings. Source code in packages/meeseeks_core/src/meeseeks_core/config.py 416 417 418 419 class Config : \"\"\"Pydantic configuration settings.\"\"\" extra = \"ignore\"","title":"Config"},{"location":"reference/#meeseeks_core.config.AppConfig.load","text":"Load configuration from a JSON file. Source code in packages/meeseeks_core/src/meeseeks_core/config.py 421 422 423 424 425 @classmethod def load ( cls , path : str | Path ) -> AppConfig : \"\"\"Load configuration from a JSON file.\"\"\" payload = _load_json ( path ) return cls . parse_obj ( payload )","title":"load"},{"location":"reference/#meeseeks_core.config.AppConfig.preflight","text":"Run async validation checks for optional integrations. Source code in packages/meeseeks_core/src/meeseeks_core/config.py 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 async def preflight ( self , * , disable_on_failure : bool = True ) -> dict [ str , dict [ str , Any ]]: \"\"\"Run async validation checks for optional integrations.\"\"\" results : dict [ str , ConfigCheck ] = {} async def _llm_check () -> ConfigCheck : return await asyncio . to_thread ( self . llm . validate_models ) async def _langfuse_check () -> ConfigCheck : enabled , reason , metadata = self . langfuse . evaluate () if not enabled : return ConfigCheck ( name = \"langfuse\" , enabled = False , ok = True , reason = reason , metadata = metadata , ) try : host = self . langfuse . host . rstrip ( \"/\" ) if host : await asyncio . to_thread ( _probe_http , f \" { host } /api/public/health\" ) return ConfigCheck ( name = \"langfuse\" , enabled = True , ok = True ) except ValueError as exc : return ConfigCheck ( name = \"langfuse\" , enabled = True , ok = False , reason = str ( exc )) async def _ha_check () -> ConfigCheck : enabled , reason , metadata = self . home_assistant . evaluate () if not enabled : return ConfigCheck ( name = \"home_assistant\" , enabled = False , ok = True , reason = reason , metadata = metadata , ) try : url = self . home_assistant . url . rstrip ( \"/\" ) headers = { \"Authorization\" : f \"Bearer { self . home_assistant . token } \" } await asyncio . to_thread ( _probe_http , f \" { url } /api/config\" , headers = headers ) return ConfigCheck ( name = \"home_assistant\" , enabled = True , ok = True ) except ValueError as exc : return ConfigCheck ( name = \"home_assistant\" , enabled = True , ok = False , reason = str ( exc )) async def _mcp_check () -> ConfigCheck : config_path = get_mcp_config_path () if not config_path : return ConfigCheck ( name = \"mcp\" , enabled = False , ok = True , reason = \"mcp config disabled\" ) try : from meeseeks_tools.integration import mcp as mcp_module config = mcp_module . _load_mcp_config ( config_path ) tools , failures = await asyncio . to_thread ( mcp_module . discover_mcp_tool_details_with_failures , config ) if failures : return ConfigCheck ( name = \"mcp\" , enabled = True , ok = False , reason = \"mcp discovery failed\" , metadata = { \"failures\" : { k : str ( v ) for k , v in failures . items ()}}, ) return ConfigCheck ( name = \"mcp\" , enabled = True , ok = True , metadata = { \"servers\" : list ( tools . keys ())}, ) except Exception as exc : return ConfigCheck ( name = \"mcp\" , enabled = True , ok = False , reason = str ( exc )) checks = await asyncio . gather ( _llm_check (), _langfuse_check (), _ha_check (), _mcp_check ()) for check in checks : results [ check . name ] = check if disable_on_failure : langfuse_check = results . get ( \"langfuse\" ) if langfuse_check and not langfuse_check . ok and self . langfuse . enabled : self . langfuse . enabled = False ha_check = results . get ( \"home_assistant\" ) if ha_check and not ha_check . ok and self . home_assistant . enabled : self . home_assistant . enabled = False return { name : check . to_dict () for name , check in results . items ()}","title":"preflight"},{"location":"reference/#meeseeks_core.config.AppConfig.to_json","text":"Serialize config to JSON. Source code in packages/meeseeks_core/src/meeseeks_core/config.py 427 428 429 def to_json ( self , * , indent : int = 2 ) -> str : \"\"\"Serialize config to JSON.\"\"\" return self . json ( indent = indent , exclude_none = True )","title":"to_json"},{"location":"reference/#meeseeks_core.config.AppConfig.write","text":"Write config JSON to disk. Source code in packages/meeseeks_core/src/meeseeks_core/config.py 431 432 433 434 435 def write ( self , path : str | Path , * , indent : int = 2 ) -> None : \"\"\"Write config JSON to disk.\"\"\" target = Path ( path ) target . parent . mkdir ( parents = True , exist_ok = True ) target . write_text ( self . to_json ( indent = indent ) + \" \\n \" , encoding = \"utf-8\" )","title":"write"},{"location":"reference/#meeseeks_core.config.ConfigCheck","text":"Result of a configuration preflight check. Source code in packages/meeseeks_core/src/meeseeks_core/config.py 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 @dataclass class ConfigCheck : \"\"\"Result of a configuration preflight check.\"\"\" name : str enabled : bool ok : bool reason : str | None = None metadata : dict [ str , Any ] = field ( default_factory = dict ) def to_dict ( self ) -> dict [ str , Any ]: \"\"\"Serialize the check result to a dictionary.\"\"\" return { \"name\" : self . name , \"enabled\" : self . enabled , \"ok\" : self . ok , \"reason\" : self . reason , \"metadata\" : self . metadata , }","title":"ConfigCheck"},{"location":"reference/#meeseeks_core.config.ConfigCheck.to_dict","text":"Serialize the check result to a dictionary. Source code in packages/meeseeks_core/src/meeseeks_core/config.py 576 577 578 579 580 581 582 583 584 def to_dict ( self ) -> dict [ str , Any ]: \"\"\"Serialize the check result to a dictionary.\"\"\" return { \"name\" : self . name , \"enabled\" : self . enabled , \"ok\" : self . ok , \"reason\" : self . reason , \"metadata\" : self . metadata , }","title":"to_dict"},{"location":"reference/#meeseeks_core.config.ensure_app_config","text":"Write the default config file if missing. Source code in packages/meeseeks_core/src/meeseeks_core/config.py 705 706 707 708 709 710 def ensure_app_config ( path : str | Path ) -> None : \"\"\"Write the default config file if missing.\"\"\" target = Path ( path ) if target . exists (): return AppConfig () . write ( target )","title":"ensure_app_config"},{"location":"reference/#meeseeks_core.config.ensure_example_configs","text":"Write example config files if missing. Source code in packages/meeseeks_core/src/meeseeks_core/config.py 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 def ensure_example_configs ( app_path : str | Path | None = None , mcp_path : str | Path | None = None , ) -> None : \"\"\"Write example config files if missing.\"\"\" app_target = Path ( app_path ) if app_path else _APP_EXAMPLE_PATH if not app_target . exists (): app_target . parent . mkdir ( parents = True , exist_ok = True ) app_target . write_text ( json . dumps ( _example_app_payload (), indent = 2 ) + \" \\n \" , encoding = \"utf-8\" ) mcp_target = Path ( mcp_path ) if mcp_path else _MCP_EXAMPLE_PATH if not mcp_target . exists (): mcp_target . parent . mkdir ( parents = True , exist_ok = True ) mcp_target . write_text ( json . dumps ( { \"servers\" : { \"codex_tools\" : { \"transport\" : \"streamable_http\" , \"url\" : \"http://127.0.0.1:6783/mcp/Codex-Tools-Personal\" , \"headers\" : { \"Authorization\" : \"Bearer YOUR_MCP_TOKEN\" }, } } }, indent = 2 , ) + \" \\n \" , encoding = \"utf-8\" , )","title":"ensure_example_configs"},{"location":"reference/#meeseeks_core.config.get_app_config_path","text":"Return the configured app JSON path. Source code in packages/meeseeks_core/src/meeseeks_core/config.py 647 648 649 def get_app_config_path () -> str : \"\"\"Return the configured app JSON path.\"\"\" return str ( _APP_CONFIG_PATH_OVERRIDE or _APP_CONFIG_PATH )","title":"get_app_config_path"},{"location":"reference/#meeseeks_core.config.get_config","text":"Return cached AppConfig instance. Source code in packages/meeseeks_core/src/meeseeks_core/config.py 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 def get_config () -> AppConfig : \"\"\"Return cached AppConfig instance.\"\"\" global _CONFIG_CACHE , _CONFIG_WARNED if _CONFIG_CACHE is not None : return _CONFIG_CACHE config_path = Path ( get_app_config_path ()) if not config_path . exists () and not _CONFIG_WARNED : _logger . warning ( \"Config file not found at %s . Run /config init to scaffold examples.\" , config_path , ) _CONFIG_WARNED = True base_payload = AppConfig () . dict () file_payload = _load_json ( get_app_config_path ()) merged = _deep_merge ( base_payload , file_payload ) if _APP_CONFIG_OVERRIDE : merged = _deep_merge ( merged , _APP_CONFIG_OVERRIDE ) _CONFIG_CACHE = AppConfig . parse_obj ( merged ) return _CONFIG_CACHE","title":"get_config"},{"location":"reference/#meeseeks_core.config.get_config_section","text":"Return a config section as a dictionary. Source code in packages/meeseeks_core/src/meeseeks_core/config.py 695 696 697 698 699 700 701 702 def get_config_section ( * keys : str ) -> dict [ str , Any ]: \"\"\"Return a config section as a dictionary.\"\"\" value = get_config_value ( * keys , default = {}) if isinstance ( value , BaseModel ): return value . dict () if isinstance ( value , dict ): return value return {}","title":"get_config_section"},{"location":"reference/#meeseeks_core.config.get_config_value","text":"Return a nested config value or default. Source code in packages/meeseeks_core/src/meeseeks_core/config.py 680 681 682 683 684 685 686 687 688 689 690 691 692 def get_config_value ( * keys : str , default : Any | None = None ) -> Any : \"\"\"Return a nested config value or default.\"\"\" current : Any = get_config () for key in keys : if isinstance ( current , BaseModel ): current = getattr ( current , key , None ) elif isinstance ( current , dict ): current = current . get ( key ) else : return default if current is None : return default return current","title":"get_config_value"},{"location":"reference/#meeseeks_core.config.get_last_preflight","text":"Return the most recent preflight results if available. Source code in packages/meeseeks_core/src/meeseeks_core/config.py 561 562 563 def get_last_preflight () -> dict [ str , dict [ str , Any ]] | None : \"\"\"Return the most recent preflight results if available.\"\"\" return _LAST_PREFLIGHT","title":"get_last_preflight"},{"location":"reference/#meeseeks_core.config.get_mcp_config_path","text":"Return the configured MCP JSON path. Source code in packages/meeseeks_core/src/meeseeks_core/config.py 652 653 654 655 656 def get_mcp_config_path () -> str : \"\"\"Return the configured MCP JSON path.\"\"\" if _MCP_CONFIG_DISABLED : return \"\" return str ( _MCP_CONFIG_PATH_OVERRIDE or _MCP_CONFIG_PATH )","title":"get_mcp_config_path"},{"location":"reference/#meeseeks_core.config.reset_config","text":"Clear cached configuration and overrides. Source code in packages/meeseeks_core/src/meeseeks_core/config.py 625 626 627 628 629 630 631 632 633 634 def reset_config () -> None : \"\"\"Clear cached configuration and overrides.\"\"\" global _CONFIG_CACHE , _APP_CONFIG_OVERRIDE , _APP_CONFIG_PATH_OVERRIDE , _MCP_CONFIG_PATH_OVERRIDE global _MCP_CONFIG_DISABLED , _CONFIG_WARNED _CONFIG_CACHE = None _APP_CONFIG_OVERRIDE = {} _APP_CONFIG_PATH_OVERRIDE = None _MCP_CONFIG_PATH_OVERRIDE = None _MCP_CONFIG_DISABLED = False _CONFIG_WARNED = False","title":"reset_config"},{"location":"reference/#meeseeks_core.config.set_app_config_path","text":"Override the app config path (tests only). Source code in packages/meeseeks_core/src/meeseeks_core/config.py 607 608 609 610 611 def set_app_config_path ( path : str | Path ) -> None : \"\"\"Override the app config path (tests only).\"\"\" global _APP_CONFIG_PATH_OVERRIDE , _CONFIG_CACHE _APP_CONFIG_PATH_OVERRIDE = Path ( path ) _CONFIG_CACHE = None","title":"set_app_config_path"},{"location":"reference/#meeseeks_core.config.set_config_override","text":"Override config values in-memory (tests/CLI). Source code in packages/meeseeks_core/src/meeseeks_core/config.py 637 638 639 640 641 642 643 644 def set_config_override ( payload : dict [ str , Any ], * , replace : bool = False ) -> None : \"\"\"Override config values in-memory (tests/CLI).\"\"\" global _APP_CONFIG_OVERRIDE , _CONFIG_CACHE if replace : _APP_CONFIG_OVERRIDE = payload else : _APP_CONFIG_OVERRIDE = _deep_merge ( _APP_CONFIG_OVERRIDE , payload ) _CONFIG_CACHE = None","title":"set_config_override"},{"location":"reference/#meeseeks_core.config.set_mcp_config_path","text":"Override the MCP config path (tests only). Source code in packages/meeseeks_core/src/meeseeks_core/config.py 614 615 616 617 618 619 620 621 622 def set_mcp_config_path ( path : str | Path | None ) -> None : \"\"\"Override the MCP config path (tests only).\"\"\" global _MCP_CONFIG_PATH_OVERRIDE , _MCP_CONFIG_DISABLED if path is None or str ( path ) . strip () == \"\" : _MCP_CONFIG_PATH_OVERRIDE = None _MCP_CONFIG_DISABLED = True return _MCP_CONFIG_DISABLED = False _MCP_CONFIG_PATH_OVERRIDE = Path ( path )","title":"set_mcp_config_path"},{"location":"reference/#meeseeks_core.config.start_preflight","text":"Run config preflight checks in a background thread. Source code in packages/meeseeks_core/src/meeseeks_core/config.py 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 def start_preflight ( config : AppConfig | None = None , * , disable_on_failure : bool = True , on_complete : Callable [[ dict [ str , dict [ str , Any ]]], None ] | None = None , ) -> threading . Thread : \"\"\"Run config preflight checks in a background thread.\"\"\" target = config or get_config () def _runner () -> None : global _LAST_PREFLIGHT results = asyncio . run ( target . preflight ( disable_on_failure = disable_on_failure )) _LAST_PREFLIGHT = results failures = { name : info for name , info in results . items () if info . get ( \"enabled\" ) and not info . get ( \"ok\" ) } for name , info in failures . items (): reason = info . get ( \"reason\" ) or \"unknown failure\" _logger . warning ( \"Preflight check failed for %s : %s \" , name , reason ) if on_complete is not None : on_complete ( results ) thread = threading . Thread ( target = _runner , daemon = True ) thread . start () return thread","title":"start_preflight"},{"location":"reference/#meeseeks_core.components","text":"Helpers for optional components and observability integration.","title":"components"},{"location":"reference/#meeseeks_core.components.ComponentStatus","text":"Describe whether a component is enabled and why. Source code in packages/meeseeks_core/src/meeseeks_core/components.py 34 35 36 37 38 39 40 41 @dataclass ( frozen = True ) class ComponentStatus : \"\"\"Describe whether a component is enabled and why.\"\"\" name : str enabled : bool reason : str | None = None metadata : dict [ str , JsonValue ] = field ( default_factory = dict )","title":"ComponentStatus"},{"location":"reference/#meeseeks_core.components.build_langfuse_handler","text":"Create a Langfuse callback handler when configured. Source code in packages/meeseeks_core/src/meeseeks_core/components.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def build_langfuse_handler ( * , user_id : str , session_id : str , trace_name : str , version : str , release : str , trace_context : TraceContext | None = None , ) -> LangfuseCallbackHandler | None : \"\"\"Create a Langfuse callback handler when configured.\"\"\" status = resolve_langfuse_status () if not status . enabled : logging . debug ( \"Langfuse disabled: {} \" , status . reason ) return None config = get_config () . langfuse _ensure_langfuse_client ( config ) from langfuse.langchain import CallbackHandler trace_context = trace_context or _LANGFUSE_TRACE_CONTEXT . get () session_id_value = _LANGFUSE_SESSION_ID . get () or session_id user_id_value = _LANGFUSE_USER_ID . get () or user_id try : handler = CallbackHandler ( public_key = config . public_key or None , trace_context = trace_context ) _attach_langfuse_metadata ( handler , user_id = user_id_value , session_id = session_id_value , trace_name = trace_name , version = version , release = release , ) return handler except Exception as exc : # pragma: no cover - defensive logging . warning ( \"Langfuse initialization failed: {} \" , exc ) return None","title":"build_langfuse_handler"},{"location":"reference/#meeseeks_core.components.format_component_status","text":"Format component statuses for inclusion in prompts. Source code in packages/meeseeks_core/src/meeseeks_core/components.py 101 102 103 104 105 106 107 108 def format_component_status ( statuses : Iterable [ ComponentStatus ]) -> str : \"\"\"Format component statuses for inclusion in prompts.\"\"\" lines : list [ str ] = [] for status in statuses : state = \"enabled\" if status . enabled else \"disabled\" reason = f \" ( { status . reason } )\" if status . reason else \"\" lines . append ( f \"- { status . name } : { state }{ reason } \" ) return \" \\n \" . join ( lines )","title":"format_component_status"},{"location":"reference/#meeseeks_core.components.langfuse_session_context","text":"Bind a stable Langfuse trace context to the current session. Source code in packages/meeseeks_core/src/meeseeks_core/components.py 133 134 135 136 137 138 139 140 141 142 143 144 145 @contextmanager def langfuse_session_context ( session_id : str , * , user_id : str | None = None ) -> Iterator [ None ]: \"\"\"Bind a stable Langfuse trace context to the current session.\"\"\" trace_context = _build_langfuse_trace_context ( session_id ) token_ctx = _LANGFUSE_TRACE_CONTEXT . set ( trace_context ) token_session = _LANGFUSE_SESSION_ID . set ( session_id ) token_user = _LANGFUSE_USER_ID . set ( user_id or session_id ) try : yield finally : _LANGFUSE_TRACE_CONTEXT . reset ( token_ctx ) _LANGFUSE_SESSION_ID . reset ( token_session ) _LANGFUSE_USER_ID . reset ( token_user )","title":"langfuse_session_context"},{"location":"reference/#meeseeks_core.components.langfuse_trace_span","text":"Open a Langfuse span bound to the current session trace context. Source code in packages/meeseeks_core/src/meeseeks_core/components.py 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 @contextmanager def langfuse_trace_span ( name : str ) -> Iterator [ object | None ]: \"\"\"Open a Langfuse span bound to the current session trace context.\"\"\" status = resolve_langfuse_status () if not status . enabled : yield None return trace_context = _LANGFUSE_TRACE_CONTEXT . get () if not trace_context : yield None return try : from langfuse import get_client except Exception : # pragma: no cover - defensive yield None return try : langfuse = get_client () with langfuse . start_as_current_observation ( as_type = \"span\" , name = name , trace_context = trace_context , ) as span : yield span except Exception : # pragma: no cover - defensive yield None","title":"langfuse_trace_span"},{"location":"reference/#meeseeks_core.components.resolve_home_assistant_status","text":"Determine whether the Home Assistant tool is configured. Source code in packages/meeseeks_core/src/meeseeks_core/components.py 90 91 92 93 94 95 96 97 98 def resolve_home_assistant_status () -> ComponentStatus : \"\"\"Determine whether the Home Assistant tool is configured.\"\"\" enabled , reason , metadata = get_config () . home_assistant . evaluate () return ComponentStatus ( name = \"home_assistant_tool\" , enabled = enabled , reason = reason , metadata = metadata , )","title":"resolve_home_assistant_status"},{"location":"reference/#meeseeks_core.components.resolve_langfuse_status","text":"Determine whether Langfuse callbacks are available and configured. Source code in packages/meeseeks_core/src/meeseeks_core/components.py 44 45 46 47 def resolve_langfuse_status () -> ComponentStatus : \"\"\"Determine whether Langfuse callbacks are available and configured.\"\"\" enabled , reason , metadata = get_config () . langfuse . evaluate () return ComponentStatus ( name = \"langfuse\" , enabled = enabled , reason = reason , metadata = metadata )","title":"resolve_langfuse_status"},{"location":"reference/#meeseeks_core.permissions","text":"Permission policies for tool execution.","title":"permissions"},{"location":"reference/#meeseeks_core.permissions.PermissionDecision","text":"Bases: str , Enum Outcomes for a permission check. Source code in packages/meeseeks_core/src/meeseeks_core/permissions.py 23 24 25 26 27 28 class PermissionDecision ( str , Enum ): \"\"\"Outcomes for a permission check.\"\"\" ALLOW = \"allow\" DENY = \"deny\" ASK = \"ask\"","title":"PermissionDecision"},{"location":"reference/#meeseeks_core.permissions.PermissionPolicy","text":"Evaluate permission rules for action steps. Source code in packages/meeseeks_core/src/meeseeks_core/permissions.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 class PermissionPolicy : \"\"\"Evaluate permission rules for action steps.\"\"\" def __init__ ( self , rules : list [ PermissionRule ] | None = None , default_by_operation : dict [ str , PermissionDecision ] | None = None , default_decision : PermissionDecision = PermissionDecision . ASK , ) -> None : \"\"\"Initialize the permission policy.\"\"\" self . _rules = rules or [] self . _default_by_operation = default_by_operation or {} self . _default_decision = default_decision def decide ( self , action_step : ActionStep ) -> PermissionDecision : \"\"\"Return the permission decision for an action step.\"\"\" for rule in self . _rules : if rule . matches ( action_step ): return rule . decision operation_decision = self . _default_by_operation . get ( action_step . operation ) if operation_decision is not None : return operation_decision return self . _default_decision","title":"PermissionPolicy"},{"location":"reference/#meeseeks_core.permissions.PermissionPolicy.__init__","text":"Initialize the permission policy. Source code in packages/meeseeks_core/src/meeseeks_core/permissions.py 49 50 51 52 53 54 55 56 57 58 def __init__ ( self , rules : list [ PermissionRule ] | None = None , default_by_operation : dict [ str , PermissionDecision ] | None = None , default_decision : PermissionDecision = PermissionDecision . ASK , ) -> None : \"\"\"Initialize the permission policy.\"\"\" self . _rules = rules or [] self . _default_by_operation = default_by_operation or {} self . _default_decision = default_decision","title":"__init__"},{"location":"reference/#meeseeks_core.permissions.PermissionPolicy.decide","text":"Return the permission decision for an action step. Source code in packages/meeseeks_core/src/meeseeks_core/permissions.py 60 61 62 63 64 65 66 67 68 def decide ( self , action_step : ActionStep ) -> PermissionDecision : \"\"\"Return the permission decision for an action step.\"\"\" for rule in self . _rules : if rule . matches ( action_step ): return rule . decision operation_decision = self . _default_by_operation . get ( action_step . operation ) if operation_decision is not None : return operation_decision return self . _default_decision","title":"decide"},{"location":"reference/#meeseeks_core.permissions.PermissionRule","text":"Rule describing a tool/action permission decision. Source code in packages/meeseeks_core/src/meeseeks_core/permissions.py 31 32 33 34 35 36 37 38 39 40 41 42 43 @dataclass ( frozen = True ) class PermissionRule : \"\"\"Rule describing a tool/action permission decision.\"\"\" tool_id : str = \"*\" operation : str = \"*\" decision : PermissionDecision = PermissionDecision . ASK def matches ( self , action_step : ActionStep ) -> bool : \"\"\"Return True when the action step matches the rule pattern.\"\"\" return fnmatch ( action_step . tool_id , self . tool_id ) and fnmatch ( action_step . operation , self . operation )","title":"PermissionRule"},{"location":"reference/#meeseeks_core.permissions.PermissionRule.matches","text":"Return True when the action step matches the rule pattern. Source code in packages/meeseeks_core/src/meeseeks_core/permissions.py 39 40 41 42 43 def matches ( self , action_step : ActionStep ) -> bool : \"\"\"Return True when the action step matches the rule pattern.\"\"\" return fnmatch ( action_step . tool_id , self . tool_id ) and fnmatch ( action_step . operation , self . operation )","title":"matches"},{"location":"reference/#meeseeks_core.permissions.approval_callback_from_config","text":"Return an approval callback based on config settings. Source code in packages/meeseeks_core/src/meeseeks_core/permissions.py 149 150 151 152 153 154 155 156 157 def approval_callback_from_config () -> Callable [[ ActionStep ], bool ] | None : \"\"\"Return an approval callback based on config settings.\"\"\" mode_raw = get_config_value ( \"permissions\" , \"approval_mode\" , default = \"\" ) mode = str ( mode_raw or \"\" ) . strip () . lower () if mode in { \"allow\" , \"auto\" , \"approve\" , \"yes\" }: return lambda _ : True if mode in { \"deny\" , \"never\" , \"no\" }: return lambda _ : False return None","title":"approval_callback_from_config"},{"location":"reference/#meeseeks_core.permissions.auto_approve","text":"Approval callback that always approves. Source code in packages/meeseeks_core/src/meeseeks_core/permissions.py 160 161 162 def auto_approve ( _ : ActionStep ) -> bool : \"\"\"Approval callback that always approves.\"\"\" return True","title":"auto_approve"},{"location":"reference/#meeseeks_core.permissions.auto_deny","text":"Approval callback that always denies. Source code in packages/meeseeks_core/src/meeseeks_core/permissions.py 165 166 167 def auto_deny ( _ : ActionStep ) -> bool : \"\"\"Approval callback that always denies.\"\"\" return False","title":"auto_deny"},{"location":"reference/#meeseeks_core.permissions.load_permission_policy","text":"Load permission policy configuration from disk or defaults. Source code in packages/meeseeks_core/src/meeseeks_core/permissions.py 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 def load_permission_policy ( path : str | None = None ) -> PermissionPolicy : \"\"\"Load permission policy configuration from disk or defaults.\"\"\" if path is None : path = get_config_value ( \"permissions\" , \"policy_path\" ) if not path : return _default_policy () if not os . path . exists ( path ): logging . warning ( \"Permission policy file not found: {} \" , path ) return _default_policy () try : payload = _load_policy_data ( path ) except ( json . JSONDecodeError , OSError , tomllib . TOMLDecodeError ) as exc : logging . warning ( \"Failed to load permission policy: {} \" , exc ) return _default_policy () rules : list [ PermissionRule ] = [] for rule_data in payload . get ( \"rules\" , []): decision = _parse_decision ( rule_data . get ( \"decision\" )) if decision is None : continue rules . append ( PermissionRule ( tool_id = str ( rule_data . get ( \"tool_id\" , \"*\" )), operation = str ( rule_data . get ( \"operation\" , \"*\" )), decision = decision , ) ) default_by_operation : dict [ str , PermissionDecision ] = {} for key , value in payload . get ( \"default_by_operation\" , {}) . items (): parsed = _parse_decision ( str ( value )) if parsed is not None : default_by_operation [ str ( key )] = parsed default_decision = _parse_decision ( payload . get ( \"default_decision\" )) if default_decision is None : default_decision = PermissionDecision . ASK return PermissionPolicy ( rules = rules , default_by_operation = default_by_operation , default_decision = default_decision , )","title":"load_permission_policy"},{"location":"reference/#meeseeks_core.hooks","text":"Hook manager for orchestration lifecycle events.","title":"hooks"},{"location":"reference/#meeseeks_core.hooks.HookManager","text":"Container for hook callbacks used during orchestration. Source code in packages/meeseeks_core/src/meeseeks_core/hooks.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 @dataclass class HookManager : \"\"\"Container for hook callbacks used during orchestration.\"\"\" pre_tool_use : list [ Callable [[ ActionStep ], ActionStep ]] = field ( default_factory = list ) post_tool_use : list [ Callable [[ ActionStep , MockSpeaker ], MockSpeaker ]] = field ( default_factory = list ) permission_request : list [ Callable [[ ActionStep , PermissionDecision ], PermissionDecision ]] = ( field ( default_factory = list ) ) pre_compact : list [ Callable [[ list [ EventRecord ]], list [ EventRecord ]]] = field ( default_factory = list ) def run_pre_tool_use ( self , action_step : ActionStep ) -> ActionStep : \"\"\"Apply pre-tool hooks to an action step. Args: action_step: Action step to process. Returns: Updated action step after hooks run. \"\"\" for hook in self . pre_tool_use : action_step = hook ( action_step ) return action_step def run_post_tool_use ( self , action_step : ActionStep , result : MockSpeaker ) -> MockSpeaker : \"\"\"Apply post-tool hooks to a tool result. Args: action_step: Action step that was executed. result: Result returned by the tool. Returns: Updated result after hooks run. \"\"\" for hook in self . post_tool_use : result = hook ( action_step , result ) return result def run_permission_request ( self , action_step : ActionStep , decision : PermissionDecision ) -> PermissionDecision : \"\"\"Apply permission hooks to a decision outcome. Args: action_step: Action step under review. decision: Current decision to modify. Returns: Updated permission decision after hooks run. \"\"\" for hook in self . permission_request : decision = hook ( action_step , decision ) return decision def run_pre_compact ( self , events : Iterable [ EventRecord ]) -> list [ EventRecord ]: \"\"\"Apply compaction hooks to events prior to summarization. Args: events: Iterable of event records. Returns: List of event records after hooks run. \"\"\" event_list : list [ EventRecord ] = list ( events ) for hook in self . pre_compact : event_list = hook ( event_list ) return event_list","title":"HookManager"},{"location":"reference/#meeseeks_core.hooks.HookManager.run_permission_request","text":"Apply permission hooks to a decision outcome. Parameters: Name Type Description Default action_step ActionStep Action step under review. required decision PermissionDecision Current decision to modify. required Returns: Type Description PermissionDecision Updated permission decision after hooks run. Source code in packages/meeseeks_core/src/meeseeks_core/hooks.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 def run_permission_request ( self , action_step : ActionStep , decision : PermissionDecision ) -> PermissionDecision : \"\"\"Apply permission hooks to a decision outcome. Args: action_step: Action step under review. decision: Current decision to modify. Returns: Updated permission decision after hooks run. \"\"\" for hook in self . permission_request : decision = hook ( action_step , decision ) return decision","title":"run_permission_request"},{"location":"reference/#meeseeks_core.hooks.HookManager.run_post_tool_use","text":"Apply post-tool hooks to a tool result. Parameters: Name Type Description Default action_step ActionStep Action step that was executed. required result MockSpeaker Result returned by the tool. required Returns: Type Description MockSpeaker Updated result after hooks run. Source code in packages/meeseeks_core/src/meeseeks_core/hooks.py 43 44 45 46 47 48 49 50 51 52 53 54 55 def run_post_tool_use ( self , action_step : ActionStep , result : MockSpeaker ) -> MockSpeaker : \"\"\"Apply post-tool hooks to a tool result. Args: action_step: Action step that was executed. result: Result returned by the tool. Returns: Updated result after hooks run. \"\"\" for hook in self . post_tool_use : result = hook ( action_step , result ) return result","title":"run_post_tool_use"},{"location":"reference/#meeseeks_core.hooks.HookManager.run_pre_compact","text":"Apply compaction hooks to events prior to summarization. Parameters: Name Type Description Default events Iterable [ EventRecord ] Iterable of event records. required Returns: Type Description list [ EventRecord ] List of event records after hooks run. Source code in packages/meeseeks_core/src/meeseeks_core/hooks.py 73 74 75 76 77 78 79 80 81 82 83 84 85 def run_pre_compact ( self , events : Iterable [ EventRecord ]) -> list [ EventRecord ]: \"\"\"Apply compaction hooks to events prior to summarization. Args: events: Iterable of event records. Returns: List of event records after hooks run. \"\"\" event_list : list [ EventRecord ] = list ( events ) for hook in self . pre_compact : event_list = hook ( event_list ) return event_list","title":"run_pre_compact"},{"location":"reference/#meeseeks_core.hooks.HookManager.run_pre_tool_use","text":"Apply pre-tool hooks to an action step. Parameters: Name Type Description Default action_step ActionStep Action step to process. required Returns: Type Description ActionStep Updated action step after hooks run. Source code in packages/meeseeks_core/src/meeseeks_core/hooks.py 30 31 32 33 34 35 36 37 38 39 40 41 def run_pre_tool_use ( self , action_step : ActionStep ) -> ActionStep : \"\"\"Apply pre-tool hooks to an action step. Args: action_step: Action step to process. Returns: Updated action step after hooks run. \"\"\" for hook in self . pre_tool_use : action_step = hook ( action_step ) return action_step","title":"run_pre_tool_use"},{"location":"reference/#meeseeks_core.hooks.default_hook_manager","text":"Create a hook manager with no custom hooks registered. Returns: Type Description HookManager Empty HookManager instance. Source code in packages/meeseeks_core/src/meeseeks_core/hooks.py 88 89 90 91 92 93 94 def default_hook_manager () -> HookManager : \"\"\"Create a hook manager with no custom hooks registered. Returns: Empty HookManager instance. \"\"\" return HookManager ()","title":"default_hook_manager"},{"location":"reference/#meeseeks_core.common","text":"Common helpers shared across the assistant runtime.","title":"common"},{"location":"reference/#meeseeks_core.common.MockSpeaker","text":"Bases: NamedTuple Simple mock response container used across tools and tests. Source code in packages/meeseeks_core/src/meeseeks_core/common.py 22 23 24 25 class MockSpeaker ( NamedTuple ): \"\"\"Simple mock response container used across tools and tests.\"\"\" content : str","title":"MockSpeaker"},{"location":"reference/#meeseeks_core.common.format_tool_input","text":"Format a tool input for logs and prompts. Source code in packages/meeseeks_core/src/meeseeks_core/common.py 169 170 171 172 173 def format_tool_input ( tool_input : object ) -> str : \"\"\"Format a tool input for logs and prompts.\"\"\" if isinstance ( tool_input , dict ): return json . dumps ( tool_input , ensure_ascii = True ) return str ( tool_input )","title":"format_tool_input"},{"location":"reference/#meeseeks_core.common.get_logger","text":"Get the logger for the module. Source code in packages/meeseeks_core/src/meeseeks_core/common.py 131 132 133 134 135 136 def get_logger ( name : str | None = None ): \"\"\"Get the logger for the module.\"\"\" _configure_logging () if not name : name = __name__ return loguru_logger . bind ( name = name )","title":"get_logger"},{"location":"reference/#meeseeks_core.common.get_mock_speaker","text":"Return a mock speaker for testing. Source code in packages/meeseeks_core/src/meeseeks_core/common.py 28 29 30 def get_mock_speaker () -> type [ MockSpeaker ]: \"\"\"Return a mock speaker for testing.\"\"\" return MockSpeaker","title":"get_mock_speaker"},{"location":"reference/#meeseeks_core.common.get_system_prompt","text":"Get the system prompt for the task queue. Source code in packages/meeseeks_core/src/meeseeks_core/common.py 157 158 159 160 161 162 163 164 165 166 def get_system_prompt ( name : str = \"action-planner\" ) -> str : \"\"\"Get the system prompt for the task queue.\"\"\" logging = get_logger ( name = \"core.common.get_system_prompt\" ) prompt_resource = resources . files ( \"meeseeks_core\" ) . joinpath ( \"prompts\" ) . joinpath ( f \" { name } .txt\" ) with resources . as_file ( prompt_resource ) as system_prompt_path : with open ( system_prompt_path , encoding = \"utf-8\" ) as system_prompt_file : system_prompt = system_prompt_file . read () logging . debug ( \"Getting system prompt from ` {} `\" , system_prompt_path ) del logging return system_prompt . strip ()","title":"get_system_prompt"},{"location":"reference/#meeseeks_core.common.get_unique_timestamp","text":"Get a unique timestamp for the task queue. Source code in packages/meeseeks_core/src/meeseeks_core/common.py 147 148 149 150 151 152 153 154 def get_unique_timestamp () -> int : \"\"\"Get a unique timestamp for the task queue.\"\"\" # Get the number of seconds since epoch (Jan 1, 1970) as a float current_timestamp = int ( time . time ()) # Convert it to string for uniqueness and consistency unique_timestamp = str ( current_timestamp ) # Return the integer version of this string timestamp return int ( \"\" . join ( str ( x ) for x in map ( int , unique_timestamp )))","title":"get_unique_timestamp"},{"location":"reference/#meeseeks_core.common.ha_render_system_prompt","text":"Render the Home Assistant Jinja2 system prompt. Source code in packages/meeseeks_core/src/meeseeks_core/common.py 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 def ha_render_system_prompt ( all_entities : object | None = None , name : str = \"homeassistant-set-state\" , ) -> str : \"\"\"Render the Home Assistant Jinja2 system prompt.\"\"\" if all_entities is not None : all_entities = str ( all_entities ) . strip () logging = get_logger ( name = \"core.common.render_system_prompt\" ) # TODO: Catch and log TemplateNotFound when necessary. template_env = Environment ( loader = PackageLoader ( \"meeseeks_core\" , \"prompts\" )) template = template_env . get_template ( f \" { name } .txt\" ) logging . debug ( \"Render system prompt for ` {} `\" , name ) del logging return template . render ( ALL_ENTITIES = all_entities )","title":"ha_render_system_prompt"},{"location":"reference/#meeseeks_core.common.num_tokens_from_string","text":"Get the number of tokens in a string using a specific model. Source code in packages/meeseeks_core/src/meeseeks_core/common.py 139 140 141 142 143 144 def num_tokens_from_string ( string : str , encoding_name : str = \"cl100k_base\" ) -> int : \"\"\"Get the number of tokens in a string using a specific model.\"\"\" # TODO: Add support for dynamic model selection encoding = tiktoken . get_encoding ( encoding_name ) num_tokens = len ( encoding . encode ( string )) return num_tokens","title":"num_tokens_from_string"},{"location":"reference/#meeseeks_core.common.session_log_context","text":"Context manager that logs all session output to a session log file. Source code in packages/meeseeks_core/src/meeseeks_core/common.py 120 121 122 123 124 125 126 127 128 @contextmanager def session_log_context ( session_id : str , log_dir : str | None = None ): \"\"\"Context manager that logs all session output to a session log file.\"\"\" _ensure_session_log_sink ( session_id , log_dir = log_dir ) try : with loguru_logger . contextualize ( session_id = session_id ): yield finally : _release_session_log_sink ( session_id )","title":"session_log_context"},{"location":"reference/#meeseeks_core.errors","text":"Core error types for tool/runtime coordination.","title":"errors"},{"location":"reference/#meeseeks_core.errors.ToolInputError","text":"Bases: Exception Raised when a tool input is invalid but the tool remains healthy. Source code in packages/meeseeks_core/src/meeseeks_core/errors.py 7 8 class ToolInputError ( Exception ): \"\"\"Raised when a tool input is invalid but the tool remains healthy.\"\"\"","title":"ToolInputError"},{"location":"reference/#meeseeks_core.notifications","text":"Lightweight notification storage for Meeseeks.","title":"notifications"},{"location":"reference/#meeseeks_core.notifications.NotificationRecord","text":"Typed record for serialized notifications. Source code in packages/meeseeks_core/src/meeseeks_core/notifications.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 @dataclass ( frozen = True ) class NotificationRecord : \"\"\"Typed record for serialized notifications.\"\"\" id : str title : str message : str level : str created_at : str dismissed : bool session_id : str | None = None dismissed_at : str | None = None event_type : str | None = None metadata : dict [ str , object ] | None = None","title":"NotificationRecord"},{"location":"reference/#meeseeks_core.notifications.NotificationStore","text":"JSON-backed notification store for single-user UI. Source code in packages/meeseeks_core/src/meeseeks_core/notifications.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 class NotificationStore : \"\"\"JSON-backed notification store for single-user UI.\"\"\" def __init__ ( self , root_dir : str | None = None , filename : str = \"notifications.json\" ) -> None : \"\"\"Initialize the notification store location.\"\"\" if root_dir is None : root_dir = get_config_value ( \"runtime\" , \"session_dir\" , default = \"./data/sessions\" ) root_dir = os . path . abspath ( root_dir ) os . makedirs ( root_dir , exist_ok = True ) self . _path = os . path . join ( root_dir , filename ) self . _lock = threading . Lock () def _load ( self ) -> list [ dict [ str , object ]]: \"\"\"Load notification records from disk.\"\"\" if not os . path . exists ( self . _path ): return [] with open ( self . _path , encoding = \"utf-8\" ) as handle : try : data = json . load ( handle ) except json . JSONDecodeError : return [] if isinstance ( data , list ): return data return [] def _save ( self , data : list [ dict [ str , object ]]) -> None : \"\"\"Persist notification records to disk.\"\"\" with open ( self . _path , \"w\" , encoding = \"utf-8\" ) as handle : json . dump ( data , handle , indent = 2 ) def list ( self , * , include_dismissed : bool = False ) -> list [ dict [ str , object ]]: \"\"\"Return notifications, optionally including dismissed ones.\"\"\" with self . _lock : data = self . _load () if not include_dismissed : data = [ item for item in data if not item . get ( \"dismissed\" )] return sorted ( data , key = lambda item : str ( item . get ( \"created_at\" , \"\" )), reverse = True , ) def add ( self , * , title : str , message : str , level : str = \"info\" , session_id : str | None = None , event_type : str | None = None , metadata : dict [ str , object ] | None = None , ) -> dict [ str , object ]: \"\"\"Add a new notification record and return it.\"\"\" record = NotificationRecord ( id = uuid . uuid4 () . hex , title = title , message = message , level = level , created_at = _utc_now (), dismissed = False , session_id = session_id , dismissed_at = None , event_type = event_type , metadata = metadata , ) payload = record . __dict__ with self . _lock : data = self . _load () data . append ( payload ) self . _save ( data ) return payload def dismiss ( self , ids : Sequence [ str ]) -> int : \"\"\"Mark notifications as dismissed.\"\"\" if not ids : return 0 dismissed_at = _utc_now () updated = 0 with self . _lock : data = self . _load () for item in data : if item . get ( \"id\" ) in ids and not item . get ( \"dismissed\" ): item [ \"dismissed\" ] = True item [ \"dismissed_at\" ] = dismissed_at updated += 1 self . _save ( data ) return updated def clear ( self , * , dismissed_only : bool = True ) -> int : \"\"\"Clear dismissed notifications (or all when requested).\"\"\" with self . _lock : data = self . _load () if dismissed_only : remaining = [ item for item in data if not item . get ( \"dismissed\" )] else : remaining = [] removed = len ( data ) - len ( remaining ) self . _save ( remaining ) return removed","title":"NotificationStore"},{"location":"reference/#meeseeks_core.notifications.NotificationStore.__init__","text":"Initialize the notification store location. Source code in packages/meeseeks_core/src/meeseeks_core/notifications.py 40 41 42 43 44 45 46 47 def __init__ ( self , root_dir : str | None = None , filename : str = \"notifications.json\" ) -> None : \"\"\"Initialize the notification store location.\"\"\" if root_dir is None : root_dir = get_config_value ( \"runtime\" , \"session_dir\" , default = \"./data/sessions\" ) root_dir = os . path . abspath ( root_dir ) os . makedirs ( root_dir , exist_ok = True ) self . _path = os . path . join ( root_dir , filename ) self . _lock = threading . Lock ()","title":"__init__"},{"location":"reference/#meeseeks_core.notifications.NotificationStore.add","text":"Add a new notification record and return it. Source code in packages/meeseeks_core/src/meeseeks_core/notifications.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def add ( self , * , title : str , message : str , level : str = \"info\" , session_id : str | None = None , event_type : str | None = None , metadata : dict [ str , object ] | None = None , ) -> dict [ str , object ]: \"\"\"Add a new notification record and return it.\"\"\" record = NotificationRecord ( id = uuid . uuid4 () . hex , title = title , message = message , level = level , created_at = _utc_now (), dismissed = False , session_id = session_id , dismissed_at = None , event_type = event_type , metadata = metadata , ) payload = record . __dict__ with self . _lock : data = self . _load () data . append ( payload ) self . _save ( data ) return payload","title":"add"},{"location":"reference/#meeseeks_core.notifications.NotificationStore.clear","text":"Clear dismissed notifications (or all when requested). Source code in packages/meeseeks_core/src/meeseeks_core/notifications.py 125 126 127 128 129 130 131 132 133 134 135 def clear ( self , * , dismissed_only : bool = True ) -> int : \"\"\"Clear dismissed notifications (or all when requested).\"\"\" with self . _lock : data = self . _load () if dismissed_only : remaining = [ item for item in data if not item . get ( \"dismissed\" )] else : remaining = [] removed = len ( data ) - len ( remaining ) self . _save ( remaining ) return removed","title":"clear"},{"location":"reference/#meeseeks_core.notifications.NotificationStore.dismiss","text":"Mark notifications as dismissed. Source code in packages/meeseeks_core/src/meeseeks_core/notifications.py 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 def dismiss ( self , ids : Sequence [ str ]) -> int : \"\"\"Mark notifications as dismissed.\"\"\" if not ids : return 0 dismissed_at = _utc_now () updated = 0 with self . _lock : data = self . _load () for item in data : if item . get ( \"id\" ) in ids and not item . get ( \"dismissed\" ): item [ \"dismissed\" ] = True item [ \"dismissed_at\" ] = dismissed_at updated += 1 self . _save ( data ) return updated","title":"dismiss"},{"location":"reference/#meeseeks_core.notifications.NotificationStore.list","text":"Return notifications, optionally including dismissed ones. Source code in packages/meeseeks_core/src/meeseeks_core/notifications.py 67 68 69 70 71 72 73 74 75 76 77 def list ( self , * , include_dismissed : bool = False ) -> list [ dict [ str , object ]]: \"\"\"Return notifications, optionally including dismissed ones.\"\"\" with self . _lock : data = self . _load () if not include_dismissed : data = [ item for item in data if not item . get ( \"dismissed\" )] return sorted ( data , key = lambda item : str ( item . get ( \"created_at\" , \"\" )), reverse = True , )","title":"list"},{"location":"reference/#meeseeks_core.share_store","text":"Session share token storage.","title":"share_store"},{"location":"reference/#meeseeks_core.share_store.ShareStore","text":"JSON-backed share token store for session exports. Source code in packages/meeseeks_core/src/meeseeks_core/share_store.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 class ShareStore : \"\"\"JSON-backed share token store for session exports.\"\"\" def __init__ ( self , root_dir : str | None = None , filename : str = \"shares.json\" ) -> None : \"\"\"Initialize the share token store location.\"\"\" if root_dir is None : root_dir = get_config_value ( \"runtime\" , \"session_dir\" , default = \"./data/sessions\" ) root_dir = os . path . abspath ( root_dir ) os . makedirs ( root_dir , exist_ok = True ) self . _path = os . path . join ( root_dir , filename ) self . _lock = threading . Lock () def _load ( self ) -> dict [ str , dict [ str , object ]]: \"\"\"Load share token records from disk.\"\"\" if not os . path . exists ( self . _path ): return {} with open ( self . _path , encoding = \"utf-8\" ) as handle : try : data = json . load ( handle ) except json . JSONDecodeError : return {} if isinstance ( data , dict ): return data return {} def _save ( self , data : dict [ str , dict [ str , object ]]) -> None : \"\"\"Persist share token records to disk.\"\"\" with open ( self . _path , \"w\" , encoding = \"utf-8\" ) as handle : json . dump ( data , handle , indent = 2 ) def create ( self , session_id : str ) -> dict [ str , object ]: \"\"\"Create and store a new share token.\"\"\" token = uuid . uuid4 () . hex record : dict [ str , object ] = { \"session_id\" : session_id , \"created_at\" : _utc_now ()} with self . _lock : data = self . _load () data [ token ] = record self . _save ( data ) return { \"token\" : token , ** record } def resolve ( self , token : str ) -> dict [ str , object ] | None : \"\"\"Resolve a share token to its record.\"\"\" if not token : return None with self . _lock : data = self . _load () record = data . get ( token ) if not record : return None return { \"token\" : token , ** record } def revoke ( self , token : str ) -> bool : \"\"\"Revoke a share token.\"\"\" if not token : return False with self . _lock : data = self . _load () if token not in data : return False data . pop ( token , None ) self . _save ( data ) return True","title":"ShareStore"},{"location":"reference/#meeseeks_core.share_store.ShareStore.__init__","text":"Initialize the share token store location. Source code in packages/meeseeks_core/src/meeseeks_core/share_store.py 22 23 24 25 26 27 28 29 def __init__ ( self , root_dir : str | None = None , filename : str = \"shares.json\" ) -> None : \"\"\"Initialize the share token store location.\"\"\" if root_dir is None : root_dir = get_config_value ( \"runtime\" , \"session_dir\" , default = \"./data/sessions\" ) root_dir = os . path . abspath ( root_dir ) os . makedirs ( root_dir , exist_ok = True ) self . _path = os . path . join ( root_dir , filename ) self . _lock = threading . Lock ()","title":"__init__"},{"location":"reference/#meeseeks_core.share_store.ShareStore.create","text":"Create and store a new share token. Source code in packages/meeseeks_core/src/meeseeks_core/share_store.py 49 50 51 52 53 54 55 56 57 def create ( self , session_id : str ) -> dict [ str , object ]: \"\"\"Create and store a new share token.\"\"\" token = uuid . uuid4 () . hex record : dict [ str , object ] = { \"session_id\" : session_id , \"created_at\" : _utc_now ()} with self . _lock : data = self . _load () data [ token ] = record self . _save ( data ) return { \"token\" : token , ** record }","title":"create"},{"location":"reference/#meeseeks_core.share_store.ShareStore.resolve","text":"Resolve a share token to its record. Source code in packages/meeseeks_core/src/meeseeks_core/share_store.py 59 60 61 62 63 64 65 66 67 68 def resolve ( self , token : str ) -> dict [ str , object ] | None : \"\"\"Resolve a share token to its record.\"\"\" if not token : return None with self . _lock : data = self . _load () record = data . get ( token ) if not record : return None return { \"token\" : token , ** record }","title":"resolve"},{"location":"reference/#meeseeks_core.share_store.ShareStore.revoke","text":"Revoke a share token. Source code in packages/meeseeks_core/src/meeseeks_core/share_store.py 70 71 72 73 74 75 76 77 78 79 80 def revoke ( self , token : str ) -> bool : \"\"\"Revoke a share token.\"\"\" if not token : return False with self . _lock : data = self . _load () if token not in data : return False data . pop ( token , None ) self . _save ( data ) return True","title":"revoke"},{"location":"reference/#meeseeks_core.llm","text":"Model configuration helpers for ChatLiteLLM.","title":"llm"},{"location":"reference/#meeseeks_core.llm.ChatModel","text":"Bases: Protocol Protocol for LangChain-compatible chat models. Source code in packages/meeseeks_core/src/meeseeks_core/llm.py 12 13 14 15 16 class ChatModel ( Protocol ): \"\"\"Protocol for LangChain-compatible chat models.\"\"\" def invoke ( self , input_data : object , config : object | None = None , ** kwargs : object ) -> object : \"\"\"Invoke the model with structured input.\"\"\"","title":"ChatModel"},{"location":"reference/#meeseeks_core.llm.ChatModel.invoke","text":"Invoke the model with structured input. Source code in packages/meeseeks_core/src/meeseeks_core/llm.py 15 16 def invoke ( self , input_data : object , config : object | None = None , ** kwargs : object ) -> object : \"\"\"Invoke the model with structured input.\"\"\"","title":"invoke"},{"location":"reference/#meeseeks_core.llm.build_chat_model","text":"Build a ChatLiteLLM model with reasoning-effort compatibility. Source code in packages/meeseeks_core/src/meeseeks_core/llm.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def build_chat_model ( model_name : str , * , openai_api_base : str | None = None , api_key : str | None = None , ) -> ChatModel : \"\"\"Build a ChatLiteLLM model with reasoning-effort compatibility.\"\"\" try : from langchain_litellm import ChatLiteLLM except ImportError as exc : # pragma: no cover - dependency guard raise ImportError ( \"langchain-litellm is required to build ChatLiteLLM\" ) from exc reasoning_effort = resolve_reasoning_effort ( model_name ) model_kwargs : dict [ str , Any ] = {} if reasoning_effort is not None : model_kwargs [ \"reasoning_effort\" ] = reasoning_effort kwargs : dict [ str , Any ] = { \"model\" : _resolve_litellm_model ( model_name , openai_api_base ), } if openai_api_base : kwargs [ \"api_base\" ] = openai_api_base if api_key : kwargs [ \"api_key\" ] = api_key if model_kwargs : kwargs [ \"model_kwargs\" ] = model_kwargs return cast ( ChatModel , ChatLiteLLM ( ** kwargs ))","title":"build_chat_model"},{"location":"reference/#meeseeks_core.llm.model_supports_reasoning_effort","text":"Return True if the model is known to support reasoning_effort. Source code in packages/meeseeks_core/src/meeseeks_core/llm.py 47 48 49 50 51 52 53 54 55 56 57 58 def model_supports_reasoning_effort ( model_name : str | None ) -> bool : \"\"\"Return True if the model is known to support reasoning_effort.\"\"\" if not model_name : return False raw = model_name . lower () normalized = _strip_provider ( model_name ) allowlist = _normalize_model_list ( get_config_value ( \"llm\" , \"reasoning_effort_models\" , default = []) ) if _matches_model_list ( raw , allowlist ) or _matches_model_list ( normalized , allowlist ): return True return normalized . startswith ( \"gpt-5\" )","title":"model_supports_reasoning_effort"},{"location":"reference/#meeseeks_core.llm.resolve_reasoning_effort","text":"Resolve the reasoning effort to use for a model. Source code in packages/meeseeks_core/src/meeseeks_core/llm.py 61 62 63 64 65 66 67 68 69 70 71 def resolve_reasoning_effort ( model_name : str | None ) -> str | None : \"\"\"Resolve the reasoning effort to use for a model.\"\"\" configured = get_config_value ( \"llm\" , \"reasoning_effort\" , default = \"\" ) if isinstance ( configured , str ) and configured . strip (): return configured . strip () . lower () if not model_supports_reasoning_effort ( model_name ): return None normalized = _strip_provider ( model_name ) if \"gpt-5-pro\" in normalized : return \"high\" return \"medium\"","title":"resolve_reasoning_effort"},{"location":"reference/#packagesmeeseeks_tools-tool-integrations","text":"","title":"packages/meeseeks_tools (tool integrations)"},{"location":"reference/#meeseeks_tools.integration.mcp","text":"MCP tool runner for integrating MCP servers into Meeseeks.","title":"mcp"},{"location":"reference/#meeseeks_tools.integration.mcp.MCPToolRunner","text":"Wrapper to invoke MCP tools via langchain-mcp-adapters. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/mcp.py 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 class MCPToolRunner : \"\"\"Wrapper to invoke MCP tools via langchain-mcp-adapters.\"\"\" def __init__ ( self , server_name : str , tool_name : str ) -> None : \"\"\"Initialize the MCP tool runner for a specific server tool. Args: server_name: MCP server name from configuration. tool_name: Tool name to invoke on the server. \"\"\" self . server_name = server_name self . tool_name = tool_name async def _invoke_async ( self , input_payload : str | dict [ str , Any ]) -> str : \"\"\"Invoke an MCP tool asynchronously and return its output. Args: input_payload: Input payload to send to the MCP tool. Returns: Stringified tool response. Raises: RuntimeError: If MCP adapters are not installed. ValueError: If the server or tool is not configured. \"\"\" try : from langchain_mcp_adapters.client import MultiServerMCPClient except Exception as exc : # pragma: no cover - runtime dependency raise RuntimeError ( \"langchain-mcp-adapters is required for MCP tools.\" ) from exc config = _load_mcp_config () servers = config . get ( \"servers\" , {}) if not servers or self . server_name not in servers : raise ValueError ( f \"MCP server ' { self . server_name } ' not found in config.\" ) client = MultiServerMCPClient ({ self . server_name : servers [ self . server_name ]}) tools = await client . get_tools ( server_name = self . server_name ) tool_map = { tool . name : tool for tool in tools } tool = tool_map . get ( self . tool_name ) if tool is None : raise ValueError ( f \"Tool ' { self . tool_name } ' not found on MCP server ' { self . server_name } '.\" ) try : result = await tool . ainvoke ( _prepare_mcp_input ( tool , input_payload )) return str ( result ) except Exception as exc : _log_runtime_failure ( self . server_name , self . tool_name , exc ) raise def run ( self , action_step : ActionStep ) -> MockSpeaker : \"\"\"Execute the MCP tool using the action step argument. Args: action_step: Action step containing the prompt argument. Returns: MockSpeaker with the tool response content. Raises: ValueError: If action_step is None. \"\"\" if action_step is None : raise ValueError ( \"Action step cannot be None.\" ) MockSpeakerType = get_mock_speaker () result = asyncio . run ( self . _invoke_async ( action_step . tool_input )) return MockSpeakerType ( content = result )","title":"MCPToolRunner"},{"location":"reference/#meeseeks_tools.integration.mcp.MCPToolRunner.__init__","text":"Initialize the MCP tool runner for a specific server tool. Parameters: Name Type Description Default server_name str MCP server name from configuration. required tool_name str Tool name to invoke on the server. required Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/mcp.py 265 266 267 268 269 270 271 272 273 def __init__ ( self , server_name : str , tool_name : str ) -> None : \"\"\"Initialize the MCP tool runner for a specific server tool. Args: server_name: MCP server name from configuration. tool_name: Tool name to invoke on the server. \"\"\" self . server_name = server_name self . tool_name = tool_name","title":"__init__"},{"location":"reference/#meeseeks_tools.integration.mcp.MCPToolRunner.run","text":"Execute the MCP tool using the action step argument. Parameters: Name Type Description Default action_step ActionStep Action step containing the prompt argument. required Returns: Type Description MockSpeaker MockSpeaker with the tool response content. Raises: Type Description ValueError If action_step is None. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/mcp.py 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 def run ( self , action_step : ActionStep ) -> MockSpeaker : \"\"\"Execute the MCP tool using the action step argument. Args: action_step: Action step containing the prompt argument. Returns: MockSpeaker with the tool response content. Raises: ValueError: If action_step is None. \"\"\" if action_step is None : raise ValueError ( \"Action step cannot be None.\" ) MockSpeakerType = get_mock_speaker () result = asyncio . run ( self . _invoke_async ( action_step . tool_input )) return MockSpeakerType ( content = result )","title":"run"},{"location":"reference/#meeseeks_tools.integration.mcp.discover_mcp_tool_details","text":"Discover MCP tool names and schemas per server from configuration. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/mcp.py 206 207 208 def discover_mcp_tool_details ( config : dict [ str , Any ]) -> dict [ str , list [ dict [ str , Any ]]]: \"\"\"Discover MCP tool names and schemas per server from configuration.\"\"\" return _run_async ( _discover_mcp_tool_details_async ( _normalize_mcp_config ( config )))","title":"discover_mcp_tool_details"},{"location":"reference/#meeseeks_tools.integration.mcp.discover_mcp_tool_details_with_failures","text":"Discover MCP tool names, schemas, and per-server failures. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/mcp.py 211 212 213 214 215 216 217 218 219 def discover_mcp_tool_details_with_failures ( config : dict [ str , Any ], ) -> tuple [ dict [ str , list [ dict [ str , Any ]]], dict [ str , Exception ]]: \"\"\"Discover MCP tool names, schemas, and per-server failures.\"\"\" discovered , failures = _run_async ( _discover_mcp_tool_details_with_failures_async ( _normalize_mcp_config ( config )) ) _record_discovery_failures ( failures ) return discovered , failures","title":"discover_mcp_tool_details_with_failures"},{"location":"reference/#meeseeks_tools.integration.mcp.discover_mcp_tools","text":"Discover MCP tool names per server from configuration. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/mcp.py 197 198 199 200 201 202 203 def discover_mcp_tools ( config : dict [ str , Any ]) -> dict [ str , list [ str ]]: \"\"\"Discover MCP tool names per server from configuration.\"\"\" details = discover_mcp_tool_details ( config ) return { server_name : [ tool [ \"name\" ] for tool in tools if tool . get ( \"name\" )] for server_name , tools in details . items () }","title":"discover_mcp_tools"},{"location":"reference/#meeseeks_tools.integration.mcp.get_last_discovery_failures","text":"Return last MCP discovery failures per server (if any). Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/mcp.py 229 230 231 def get_last_discovery_failures () -> dict [ str , str ]: \"\"\"Return last MCP discovery failures per server (if any).\"\"\" return dict ( _LAST_DISCOVERY_FAILURES )","title":"get_last_discovery_failures"},{"location":"reference/#meeseeks_tools.integration.mcp.mark_tool_auto_approved","text":"Record a tool as auto-approved in the MCP config. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/mcp.py 247 248 249 250 251 252 253 254 255 256 257 258 259 def mark_tool_auto_approved ( config : dict [ str , Any ], server_name : str , tool_name : str , ) -> dict [ str , Any ]: \"\"\"Record a tool as auto-approved in the MCP config.\"\"\" servers = config . setdefault ( \"servers\" , {}) server_config = servers . setdefault ( server_name , {}) allowlist = server_config . setdefault ( \"auto_approve_tools\" , []) if tool_name not in allowlist : allowlist . append ( tool_name ) server_config [ \"auto_approve_tools\" ] = sorted ( set ( allowlist )) return config","title":"mark_tool_auto_approved"},{"location":"reference/#meeseeks_tools.integration.mcp.save_mcp_config","text":"Persist an MCP configuration payload to disk. Parameters: Name Type Description Default config dict [ str , Any ] MCP configuration payload to write. required path str | None Optional explicit file path (defaults to the configured MCP path). None Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/mcp.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 def save_mcp_config ( config : dict [ str , Any ], path : str | None = None ) -> None : \"\"\"Persist an MCP configuration payload to disk. Args: config: MCP configuration payload to write. path: Optional explicit file path (defaults to the configured MCP path). \"\"\" config_path = path or get_mcp_config_path () if not config_path : raise ValueError ( \"MCP config path is not set.\" ) config_path = os . path . abspath ( config_path ) with open ( config_path , \"w\" , encoding = \"utf-8\" ) as handle : json . dump ( config , handle , indent = 2 ) handle . write ( \" \\n \" )","title":"save_mcp_config"},{"location":"reference/#meeseeks_tools.integration.mcp.tool_auto_approved","text":"Return True when a tool is marked as auto-approved. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/mcp.py 234 235 236 237 238 239 240 241 242 243 244 def tool_auto_approved ( config : dict [ str , Any ], server_name : str , tool_name : str , ) -> bool : \"\"\"Return True when a tool is marked as auto-approved.\"\"\" server_config = config . get ( \"servers\" , {}) . get ( server_name , {}) if server_config . get ( \"auto_approve_all\" ): return True allowlist = server_config . get ( \"auto_approve_tools\" , []) return tool_name in allowlist","title":"tool_auto_approved"},{"location":"reference/#meeseeks_tools.integration.homeassistant","text":"Home Assistant integration tools and data models.","title":"homeassistant"},{"location":"reference/#meeseeks_tools.integration.homeassistant.CacheHolder","text":"Bases: Protocol Protocol describing objects with a Home Assistant cache attribute. Attributes: Name Type Description cache HomeAssistantCache Home Assistant cache payload. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 45 46 47 48 49 50 51 52 53 @runtime_checkable class CacheHolder ( Protocol ): \"\"\"Protocol describing objects with a Home Assistant cache attribute. Attributes: cache: Home Assistant cache payload. \"\"\" cache : HomeAssistantCache","title":"CacheHolder"},{"location":"reference/#meeseeks_tools.integration.homeassistant.HomeAssistant","text":"Bases: AbstractTool A service to manage and interact with Home Assistant. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 class HomeAssistant ( AbstractTool ): \"\"\"A service to manage and interact with Home Assistant.\"\"\" def __init__ ( self ) -> None : \"\"\"Initialize the Home Assistant tool with environment defaults.\"\"\" super () . __init__ ( name = \"Home Assistant\" , description = \"A service to manage and interact with Home Assistant\" , ) self . base_url = get_config_value ( \"home_assistant\" , \"url\" ) self . _api_token = get_config_value ( \"home_assistant\" , \"token\" ) self . cache : HomeAssistantCache = { \"entity_ids\" : [], \"sensor_ids\" : [], \"entities\" : [], \"services\" : [], \"sensors\" : [], \"allowed_domains\" : [ \"scene\" , \"switch\" , \"weather\" , \"kodi\" , \"automation\" ], } if not self . base_url or not self . _api_token : raise ValueError ( \"home_assistant.url and home_assistant.token must be set.\" ) self . api_headers : dict [ str , str ] = { \"Authorization\" : f \"Bearer { self . _api_token } \" , \"Content-Type\" : \"application/json\" , } @cache_monitor def update_services ( self ) -> bool : \"\"\"Update the list of services from Home Assistant. Returns: True when services are fetched successfully. \"\"\" url = f \" { self . base_url } /services\" try : response = requests . get ( url , headers = self . api_headers , timeout = 30 ) status_code = getattr ( response , \"status_code\" , None ) if status_code in { 401 , 403 }: logging . error ( \"Home Assistant authorization failed with status {} .\" , status_code ) raise PermissionError ( \"Home Assistant authorization failed.\" ) response . raise_for_status () self . cache [ \"services\" ] = response . json () self . _save_json ( self . cache [ \"services\" ], \"services.json\" ) return True except requests . exceptions . RequestException as e : logging . error ( \"Error: {} \" , e ) return False @cache_monitor def update_entities ( self ) -> bool : \"\"\"Update the list of entities from Home Assistant. Returns: True when entities are fetched successfully. \"\"\" url = f \" { self . base_url } /states\" try : response = requests . get ( url , headers = self . api_headers , timeout = 30 ) status_code = getattr ( response , \"status_code\" , None ) if status_code in { 401 , 403 }: logging . error ( \"Home Assistant authorization failed with status {} .\" , status_code ) raise PermissionError ( \"Home Assistant authorization failed.\" ) response . raise_for_status () self . cache [ \"entities\" ] = response . json () return True except requests . exceptions . RequestException as e : logging . error ( \"Error: {} \" , e ) return False @cache_monitor def update_entity_ids ( self ) -> bool : \"\"\"Update the list of entity IDs from Home Assistant. Returns: True when entity IDs are populated. Raises: ValueError: If no entities are available for ID extraction. \"\"\" # TODO: Always assumes blacklist by default due to cache_monitor. self . update_entities () entities = self . cache [ \"entities\" ] if not entities : raise ValueError ( \"No entities found while updating entity IDs.\" ) self . cache [ \"entity_ids\" ] = [ entity [ \"entity_id\" ] for entity in entities ] logging . info ( \"Entity IDs updated.\" ) return True @cache_monitor def update_cache ( self ) -> None : \"\"\"Update the entire cache. Raises: ValueError: If entity IDs cannot be derived. \"\"\" self . update_entity_ids () self . update_services () self . _save_json ( self . cache [ \"entities\" ], \"entities.json\" ) self . _save_json ( self . cache [ \"sensors\" ], \"sensors.json\" ) def call_service ( self , domain : str , service : str , entity_id : str , data : dict | None = None , ) -> tuple [ bool , list [ dict [ str , Any ]]]: \"\"\"Call a service in Home Assistant. Args: domain: Home Assistant domain name (e.g., \"light\"). service: Service name within the domain (e.g., \"turn_on\"). entity_id: Entity ID to target. data: Optional extra payload for the service call. Returns: Tuple of success flag and JSON response payload. Raises: ValueError: If the domain is not allowed. \"\"\" if domain not in self . cache [ \"allowed_domains\" ]: raise ValueError ( f \"Domain does not exist or blacklisted: { domain } \" ) url = f \" { self . base_url } /services/ { domain } / { service } \" payload = { \"entity_id\" : entity_id } if data : payload . update ( data ) try : response = requests . post ( url , headers = self . api_headers , json = payload , timeout = 30 ) status_code = getattr ( response , \"status_code\" , None ) if status_code in { 401 , 403 }: logging . error ( \"Home Assistant authorization failed with status {} .\" , status_code ) raise PermissionError ( \"Home Assistant authorization failed.\" ) response . raise_for_status () logging . info ( \"Service < {} . {} > called on entity < {} > returned ` {} `.\" , domain , service , entity_id , response . text , ) return True , response . json () except requests . exceptions . RequestException as e : logging . error ( \"Unable to call service < {} . {} > on entity < {} >: {} \" , domain , service , entity_id , e ) return False , [] @staticmethod def _create_set_prompt ( system_prompt : str , parser : PydanticOutputParser , ) -> ChatPromptTemplate : \"\"\"Create the prompt template for a set-state operation. Args: system_prompt: System prompt content. parser: Pydantic output parser for HomeAssistantCall. Returns: ChatPromptTemplate configured for set-state tasks. \"\"\" example = HomeAssistantCall ( domain = \"scene\" , service = \"turn_on\" , entity_id = \"scene.lamp_power_on\" ) prompt = ChatPromptTemplate ( messages = [ SystemMessage ( content = system_prompt ), HumanMessage ( content = \"Turn on the lamp lights.\" ), AIMessage ( content = example . json ()), HumanMessagePromptTemplate . from_template ( \"The user asked you to ` {action_step} `. You must use the information \" \"provided to pick the right Home Assistant service call values only \" \"considering the current user query. \\n\\n \" \"## Format Instructions \\n {format_instructions} \\n\\n \" \"## Home Assistant Entities and Domain-Services \\n ``` \\n {context} ``` \\n \" ), ], partial_variables = { \"format_instructions\" : parser . get_format_instructions ()}, input_variables = [ \"action_step\" ], ) return prompt @staticmethod def _create_get_prompt ( system_prompt : str ) -> ChatPromptTemplate : \"\"\"Create the prompt template for a get-state operation. Args: system_prompt: System prompt content. Returns: ChatPromptTemplate configured for get-state tasks. \"\"\" prompt = ChatPromptTemplate ( messages = [ SystemMessage ( content = system_prompt ), HumanMessage ( content = \"How is the air quality today?\" ), AIMessage ( content = ( \"AccuWeather reported today's air quality in your home as good. \" \"This level of air quality ensures that the environment is healthy, \" \"supporting your daily activities and wellbeing without any air \" \"quality-related risks.\" ) ), HumanMessagePromptTemplate . from_template ( \"The user asked you to ` {action_step} `. You must use the sensor \" \"information to answer the user's query. Keep your answer \" \"analytical, brief and useful. \\n\\n \" \"## Home Assistant Sensors \\n ``` \\n {context} ``` \\n \" ), ], input_variables = [ \"action_step\" ], ) return prompt @staticmethod def _clean_answer ( answer : str ) -> str : \"\"\"Clean the answer by removing/replacing characters. Args: answer: Raw answer string to normalize. Returns: Cleaned answer string. \"\"\" replacements = { # Common entities \"RealFeel\" : \"Real Feel\" , # Confident Abbreviations \"km/h\" : \" kilometer per hour\" , \"\u00b0C\" : \" degrees celsius\" , \"%\" : \" percent\" , \"mm/h\" : \" millimeter per hour\" , \"Gb/s\" : \" gigabits per second\" , \"Mb/s\" : \" megabits per second\" , \"Kb/s\" : \" kilobits per second\" , \"GHz\" : \"Gigahertz\" , # Formatting '\"' : \"\" , } # Replace using the dictionary for old , new in replacements . items (): answer = answer . replace ( old , new ) # Remove extra spaces and new lines, condense all multiple spaces # to a single space answer = re . sub ( r \"\\s+\" , \" \" , answer ) . strip () return answer def _invoke_service_and_set_state ( self , chain : SupportsInvoke , rag_documents : list [ Document ], action_step : ActionStep , ) -> MockSpeaker : \"\"\"Invoke the service and set the state. Args: chain: Runnable chain that yields HomeAssistantCall. rag_documents: Context documents for the chain. action_step: Action step describing the request. Returns: MockSpeaker with a status message. \"\"\" MockSpeaker = get_mock_speaker () try : action_step_curr = str ( action_step . tool_input ) . strip () call_service_values = chain . invoke ( { \"action_step\" : action_step_curr , \"context\" : rag_documents , \"cache\" : self . cache }, ) logging . debug ( \"Call Service Values for ` {} `: ` {} `\" , action_step_curr , call_service_values ) status_bool , response_json = self . call_service ( domain = call_service_values . domain , service = call_service_values . service , entity_id = call_service_values . entity_id , ) if status_bool : tmp_return_message = f \"Successfully called service: ` { response_json } `\" else : tmp_return_message = f \"Failed to call service: ` { response_json } `\" except Exception as err_mesaage : logging . error ( \"Error: {} \" , err_mesaage ) tmp_return_message = f \"I received an error - ` { err_mesaage } `\" return MockSpeaker ( content = tmp_return_message ) def set_state ( self , action_step : ActionStep | None = None ) -> MockSpeaker : \"\"\"Predict and call a service for a given action step. Args: action_step: Action step describing the desired change. Returns: MockSpeaker with a status message. Raises: ValueError: If action_step is None. \"\"\" if action_step is None : raise ValueError ( \"Action step cannot be None.\" ) self . update_cache () rag_documents = self . _load_rag_documents ([ \"entities.json\" , \"services.json\" ]) system_prompt = ha_render_system_prompt ( name = \"homeassistant-set-state\" , all_entities = self . cache [ \"entity_ids\" ] ) parser = PydanticOutputParser ( pydantic_object = HomeAssistantCall ) # type: ignore[type-var] prompt = self . _create_set_prompt ( system_prompt , parser ) if self . model is None : raise RuntimeError ( \"LLM client not initialized for Home Assistant.\" ) model = self . model chain : Any = prompt | model | parser logging . info ( \"Invoking `set` action chain using ` {} ` for ` {} `.\" , self . model_name , action_step ) # TODO: Interpret the response from call service. return self . _invoke_service_and_set_state ( chain , rag_documents , action_step ) def get_state ( self , action_step : ActionStep | None = None ) -> MockSpeaker : \"\"\"Generate response for a given action step based on sensors. Args: action_step: Action step describing the desired query. Returns: MockSpeaker with the generated response. Raises: ValueError: If action_step is None. \"\"\" if action_step is None : raise ValueError ( \"Action step cannot be None.\" ) self . update_cache () rag_documents = self . _load_rag_documents ([ \"sensors.json\" ]) system_prompt = ha_render_system_prompt ( name = \"homeassistant-get-state\" ) prompt = self . _create_get_prompt ( system_prompt ) if self . model is None : raise RuntimeError ( \"LLM client not initialized for Home Assistant.\" ) model = self . model chain : Any = prompt | model logging . info ( \"Invoking `get` action chain using ` {} `.\" , self . model_name ) message = chain . invoke ( { \"action_step\" : str ( action_step . tool_input ) . strip (), \"context\" : rag_documents , }, ) cleaned_message = self . _clean_answer ( str ( message . content )) MockSpeaker = get_mock_speaker () return MockSpeaker ( content = cleaned_message )","title":"HomeAssistant"},{"location":"reference/#meeseeks_tools.integration.homeassistant.HomeAssistant.__init__","text":"Initialize the Home Assistant tool with environment defaults. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 def __init__ ( self ) -> None : \"\"\"Initialize the Home Assistant tool with environment defaults.\"\"\" super () . __init__ ( name = \"Home Assistant\" , description = \"A service to manage and interact with Home Assistant\" , ) self . base_url = get_config_value ( \"home_assistant\" , \"url\" ) self . _api_token = get_config_value ( \"home_assistant\" , \"token\" ) self . cache : HomeAssistantCache = { \"entity_ids\" : [], \"sensor_ids\" : [], \"entities\" : [], \"services\" : [], \"sensors\" : [], \"allowed_domains\" : [ \"scene\" , \"switch\" , \"weather\" , \"kodi\" , \"automation\" ], } if not self . base_url or not self . _api_token : raise ValueError ( \"home_assistant.url and home_assistant.token must be set.\" ) self . api_headers : dict [ str , str ] = { \"Authorization\" : f \"Bearer { self . _api_token } \" , \"Content-Type\" : \"application/json\" , }","title":"__init__"},{"location":"reference/#meeseeks_tools.integration.homeassistant.HomeAssistant.call_service","text":"Call a service in Home Assistant. Parameters: Name Type Description Default domain str Home Assistant domain name (e.g., \"light\"). required service str Service name within the domain (e.g., \"turn_on\"). required entity_id str Entity ID to target. required data dict | None Optional extra payload for the service call. None Returns: Type Description tuple [ bool , list [ dict [ str , Any ]]] Tuple of success flag and JSON response payload. Raises: Type Description ValueError If the domain is not allowed. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 def call_service ( self , domain : str , service : str , entity_id : str , data : dict | None = None , ) -> tuple [ bool , list [ dict [ str , Any ]]]: \"\"\"Call a service in Home Assistant. Args: domain: Home Assistant domain name (e.g., \"light\"). service: Service name within the domain (e.g., \"turn_on\"). entity_id: Entity ID to target. data: Optional extra payload for the service call. Returns: Tuple of success flag and JSON response payload. Raises: ValueError: If the domain is not allowed. \"\"\" if domain not in self . cache [ \"allowed_domains\" ]: raise ValueError ( f \"Domain does not exist or blacklisted: { domain } \" ) url = f \" { self . base_url } /services/ { domain } / { service } \" payload = { \"entity_id\" : entity_id } if data : payload . update ( data ) try : response = requests . post ( url , headers = self . api_headers , json = payload , timeout = 30 ) status_code = getattr ( response , \"status_code\" , None ) if status_code in { 401 , 403 }: logging . error ( \"Home Assistant authorization failed with status {} .\" , status_code ) raise PermissionError ( \"Home Assistant authorization failed.\" ) response . raise_for_status () logging . info ( \"Service < {} . {} > called on entity < {} > returned ` {} `.\" , domain , service , entity_id , response . text , ) return True , response . json () except requests . exceptions . RequestException as e : logging . error ( \"Unable to call service < {} . {} > on entity < {} >: {} \" , domain , service , entity_id , e ) return False , []","title":"call_service"},{"location":"reference/#meeseeks_tools.integration.homeassistant.HomeAssistant.get_state","text":"Generate response for a given action step based on sensors. Parameters: Name Type Description Default action_step ActionStep | None Action step describing the desired query. None Returns: Type Description MockSpeaker MockSpeaker with the generated response. Raises: Type Description ValueError If action_step is None. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 def get_state ( self , action_step : ActionStep | None = None ) -> MockSpeaker : \"\"\"Generate response for a given action step based on sensors. Args: action_step: Action step describing the desired query. Returns: MockSpeaker with the generated response. Raises: ValueError: If action_step is None. \"\"\" if action_step is None : raise ValueError ( \"Action step cannot be None.\" ) self . update_cache () rag_documents = self . _load_rag_documents ([ \"sensors.json\" ]) system_prompt = ha_render_system_prompt ( name = \"homeassistant-get-state\" ) prompt = self . _create_get_prompt ( system_prompt ) if self . model is None : raise RuntimeError ( \"LLM client not initialized for Home Assistant.\" ) model = self . model chain : Any = prompt | model logging . info ( \"Invoking `get` action chain using ` {} `.\" , self . model_name ) message = chain . invoke ( { \"action_step\" : str ( action_step . tool_input ) . strip (), \"context\" : rag_documents , }, ) cleaned_message = self . _clean_answer ( str ( message . content )) MockSpeaker = get_mock_speaker () return MockSpeaker ( content = cleaned_message )","title":"get_state"},{"location":"reference/#meeseeks_tools.integration.homeassistant.HomeAssistant.set_state","text":"Predict and call a service for a given action step. Parameters: Name Type Description Default action_step ActionStep | None Action step describing the desired change. None Returns: Type Description MockSpeaker MockSpeaker with a status message. Raises: Type Description ValueError If action_step is None. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 def set_state ( self , action_step : ActionStep | None = None ) -> MockSpeaker : \"\"\"Predict and call a service for a given action step. Args: action_step: Action step describing the desired change. Returns: MockSpeaker with a status message. Raises: ValueError: If action_step is None. \"\"\" if action_step is None : raise ValueError ( \"Action step cannot be None.\" ) self . update_cache () rag_documents = self . _load_rag_documents ([ \"entities.json\" , \"services.json\" ]) system_prompt = ha_render_system_prompt ( name = \"homeassistant-set-state\" , all_entities = self . cache [ \"entity_ids\" ] ) parser = PydanticOutputParser ( pydantic_object = HomeAssistantCall ) # type: ignore[type-var] prompt = self . _create_set_prompt ( system_prompt , parser ) if self . model is None : raise RuntimeError ( \"LLM client not initialized for Home Assistant.\" ) model = self . model chain : Any = prompt | model | parser logging . info ( \"Invoking `set` action chain using ` {} ` for ` {} `.\" , self . model_name , action_step ) # TODO: Interpret the response from call service. return self . _invoke_service_and_set_state ( chain , rag_documents , action_step )","title":"set_state"},{"location":"reference/#meeseeks_tools.integration.homeassistant.HomeAssistant.update_cache","text":"Update the entire cache. Raises: Type Description ValueError If entity IDs cannot be derived. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 380 381 382 383 384 385 386 387 388 389 390 @cache_monitor def update_cache ( self ) -> None : \"\"\"Update the entire cache. Raises: ValueError: If entity IDs cannot be derived. \"\"\" self . update_entity_ids () self . update_services () self . _save_json ( self . cache [ \"entities\" ], \"entities.json\" ) self . _save_json ( self . cache [ \"sensors\" ], \"sensors.json\" )","title":"update_cache"},{"location":"reference/#meeseeks_tools.integration.homeassistant.HomeAssistant.update_entities","text":"Update the list of entities from Home Assistant. Returns: Type Description bool True when entities are fetched successfully. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 @cache_monitor def update_entities ( self ) -> bool : \"\"\"Update the list of entities from Home Assistant. Returns: True when entities are fetched successfully. \"\"\" url = f \" { self . base_url } /states\" try : response = requests . get ( url , headers = self . api_headers , timeout = 30 ) status_code = getattr ( response , \"status_code\" , None ) if status_code in { 401 , 403 }: logging . error ( \"Home Assistant authorization failed with status {} .\" , status_code ) raise PermissionError ( \"Home Assistant authorization failed.\" ) response . raise_for_status () self . cache [ \"entities\" ] = response . json () return True except requests . exceptions . RequestException as e : logging . error ( \"Error: {} \" , e ) return False","title":"update_entities"},{"location":"reference/#meeseeks_tools.integration.homeassistant.HomeAssistant.update_entity_ids","text":"Update the list of entity IDs from Home Assistant. Returns: Type Description bool True when entity IDs are populated. Raises: Type Description ValueError If no entities are available for ID extraction. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 @cache_monitor def update_entity_ids ( self ) -> bool : \"\"\"Update the list of entity IDs from Home Assistant. Returns: True when entity IDs are populated. Raises: ValueError: If no entities are available for ID extraction. \"\"\" # TODO: Always assumes blacklist by default due to cache_monitor. self . update_entities () entities = self . cache [ \"entities\" ] if not entities : raise ValueError ( \"No entities found while updating entity IDs.\" ) self . cache [ \"entity_ids\" ] = [ entity [ \"entity_id\" ] for entity in entities ] logging . info ( \"Entity IDs updated.\" ) return True","title":"update_entity_ids"},{"location":"reference/#meeseeks_tools.integration.homeassistant.HomeAssistant.update_services","text":"Update the list of services from Home Assistant. Returns: Type Description bool True when services are fetched successfully. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 @cache_monitor def update_services ( self ) -> bool : \"\"\"Update the list of services from Home Assistant. Returns: True when services are fetched successfully. \"\"\" url = f \" { self . base_url } /services\" try : response = requests . get ( url , headers = self . api_headers , timeout = 30 ) status_code = getattr ( response , \"status_code\" , None ) if status_code in { 401 , 403 }: logging . error ( \"Home Assistant authorization failed with status {} .\" , status_code ) raise PermissionError ( \"Home Assistant authorization failed.\" ) response . raise_for_status () self . cache [ \"services\" ] = response . json () self . _save_json ( self . cache [ \"services\" ], \"services.json\" ) return True except requests . exceptions . RequestException as e : logging . error ( \"Error: {} \" , e ) return False","title":"update_services"},{"location":"reference/#meeseeks_tools.integration.homeassistant.HomeAssistantCache","text":"Bases: TypedDict Cached Home Assistant entity and service metadata. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 33 34 35 36 37 38 39 40 41 42 class HomeAssistantCache ( TypedDict ): \"\"\"Cached Home Assistant entity and service metadata.\"\"\" entity_ids : list [ str ] sensor_ids : list [ str ] entities : list [ dict [ str , Any ]] services : list [ dict [ str , Any ]] sensors : list [ dict [ str , Any ]] allowed_domains : list [ str ] sensor : NotRequired [ list [ dict [ str , Any ]]]","title":"HomeAssistantCache"},{"location":"reference/#meeseeks_tools.integration.homeassistant.HomeAssistantCall","text":"Bases: BaseModel Structured Home Assistant service call extracted from the model output. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 class HomeAssistantCall ( BaseModel ): \"\"\"Structured Home Assistant service call extracted from the model output.\"\"\" cache : CacheHolder | None = Field ( alias = \"_ha_cache\" , default = None ) domain : str = Field ( description = ( \"The category of the service to call, such as 'light', 'switch', or 'scene'.\" ) ) service : str = Field ( description = ( \"The specific action to perform within the domain, such as 'turn_on', \" \"'turn_off', or 'set_temperature'.\" ) ) entity_id : str = Field ( description = ( \"The ID of the specific device or entity within the domain to apply the \" \"service to, such as 'scene.heater'.\" ) ) @validator ( \"entity_id\" , allow_reuse = True ) # pylint: disable=E0213,W0613 def validate_entity_id ( cls , entity_id : str , values : dict [ str , Any ], ** kwargs : Any ) -> str : \"\"\"Validate the entity_id against the cache when available. Args: cls: Pydantic model class. entity_id: Candidate entity identifier. values: Parsed model values. **kwargs: Additional validator arguments. Returns: Validated entity identifier. Raises: ValueError: If the entity ID is not found in the cache. \"\"\" # ! BUG: The entity_id may not be validated correctly as the cache # ! is not passed to the validator. ha_cache = values . get ( \"ha_cache\" ) if ha_cache and entity_id not in ha_cache . cache [ \"entity_ids\" ]: raise ValueError ( f \"Entity ID ' { entity_id } ' is not in the Home Assistant cache.\" ) return entity_id @validator ( \"domain\" , allow_reuse = True ) # pylint: disable=E0213,W0613 def validate_domain ( cls , domain : str , values : dict [ str , Any ], ** kwargs : Any ) -> str : \"\"\"Validate the domain against the cache when available. Args: cls: Pydantic model class. domain: Domain string to validate. values: Parsed model values. **kwargs: Additional validator arguments. Returns: Validated domain string. Raises: ValueError: If the domain is not found in the cache. \"\"\" # ! BUG: The entity_id may not be validated correctly as the cache # ! is not passed to the validator. ha_cache = values . get ( \"ha_cache\" ) if ha_cache and domain not in ha_cache . cache [ \"allowed_domains\" ]: raise ValueError ( f \"Domain ' { domain } ' is not in the Home Assistant cache.\" ) return domain class Config : \"\"\"Pydantic configuration for HomeAssistantCall.\"\"\" arbitrary_types_allowed = True","title":"HomeAssistantCall"},{"location":"reference/#meeseeks_tools.integration.homeassistant.HomeAssistantCall.Config","text":"Pydantic configuration for HomeAssistantCall. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 284 285 286 287 class Config : \"\"\"Pydantic configuration for HomeAssistantCall.\"\"\" arbitrary_types_allowed = True","title":"Config"},{"location":"reference/#meeseeks_tools.integration.homeassistant.HomeAssistantCall.validate_domain","text":"Validate the domain against the cache when available. Parameters: Name Type Description Default cls Pydantic model class. required domain str Domain string to validate. required values dict [ str , Any ] Parsed model values. required **kwargs Any Additional validator arguments. {} Returns: Type Description str Validated domain string. Raises: Type Description ValueError If the domain is not found in the cache. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 @validator ( \"domain\" , allow_reuse = True ) # pylint: disable=E0213,W0613 def validate_domain ( cls , domain : str , values : dict [ str , Any ], ** kwargs : Any ) -> str : \"\"\"Validate the domain against the cache when available. Args: cls: Pydantic model class. domain: Domain string to validate. values: Parsed model values. **kwargs: Additional validator arguments. Returns: Validated domain string. Raises: ValueError: If the domain is not found in the cache. \"\"\" # ! BUG: The entity_id may not be validated correctly as the cache # ! is not passed to the validator. ha_cache = values . get ( \"ha_cache\" ) if ha_cache and domain not in ha_cache . cache [ \"allowed_domains\" ]: raise ValueError ( f \"Domain ' { domain } ' is not in the Home Assistant cache.\" ) return domain","title":"validate_domain"},{"location":"reference/#meeseeks_tools.integration.homeassistant.HomeAssistantCall.validate_entity_id","text":"Validate the entity_id against the cache when available. Parameters: Name Type Description Default cls Pydantic model class. required entity_id str Candidate entity identifier. required values dict [ str , Any ] Parsed model values. required **kwargs Any Additional validator arguments. {} Returns: Type Description str Validated entity identifier. Raises: Type Description ValueError If the entity ID is not found in the cache. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 @validator ( \"entity_id\" , allow_reuse = True ) # pylint: disable=E0213,W0613 def validate_entity_id ( cls , entity_id : str , values : dict [ str , Any ], ** kwargs : Any ) -> str : \"\"\"Validate the entity_id against the cache when available. Args: cls: Pydantic model class. entity_id: Candidate entity identifier. values: Parsed model values. **kwargs: Additional validator arguments. Returns: Validated entity identifier. Raises: ValueError: If the entity ID is not found in the cache. \"\"\" # ! BUG: The entity_id may not be validated correctly as the cache # ! is not passed to the validator. ha_cache = values . get ( \"ha_cache\" ) if ha_cache and entity_id not in ha_cache . cache [ \"entity_ids\" ]: raise ValueError ( f \"Entity ID ' { entity_id } ' is not in the Home Assistant cache.\" ) return entity_id","title":"validate_entity_id"},{"location":"reference/#meeseeks_tools.integration.homeassistant.SupportsInvoke","text":"Bases: Protocol Protocol for runnable chains that return HomeAssistantCall. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 56 57 58 59 60 61 62 63 64 65 66 67 68 class SupportsInvoke ( Protocol ): \"\"\"Protocol for runnable chains that return HomeAssistantCall.\"\"\" def invoke ( self , input_data : dict [ str , Any ]) -> HomeAssistantCall : \"\"\"Invoke the chain with structured input. Args: input_data: Input payload for the chain. Returns: Parsed HomeAssistantCall. \"\"\" ...","title":"SupportsInvoke"},{"location":"reference/#meeseeks_tools.integration.homeassistant.SupportsInvoke.invoke","text":"Invoke the chain with structured input. Parameters: Name Type Description Default input_data dict [ str , Any ] Input payload for the chain. required Returns: Type Description HomeAssistantCall Parsed HomeAssistantCall. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 59 60 61 62 63 64 65 66 67 68 def invoke ( self , input_data : dict [ str , Any ]) -> HomeAssistantCall : \"\"\"Invoke the chain with structured input. Args: input_data: Input payload for the chain. Returns: Parsed HomeAssistantCall. \"\"\" ...","title":"invoke"},{"location":"reference/#meeseeks_tools.integration.homeassistant.cache_monitor","text":"Decorator to monitor and update the cache. Parameters: Name Type Description Default func Callable [ Concatenate [ SelfT , P ], R ] Method that updates a portion of the cache. required Returns: Type Description Callable [ Concatenate [ SelfT , P ], R ] Wrapped function that normalizes cache contents after execution. Source code in packages/meeseeks_tools/src/meeseeks_tools/integration/homeassistant.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 def cache_monitor ( func : Callable [ Concatenate [ SelfT , P ], R ]) -> Callable [ Concatenate [ SelfT , P ], R ]: \"\"\"Decorator to monitor and update the cache. Args: func: Method that updates a portion of the cache. Returns: Wrapped function that normalizes cache contents after execution. \"\"\" def sort_by_entity_id ( dict_list : list [ dict [ str , Any ]]) -> list [ dict [ str , Any ]]: \"\"\"Sort a list of entities by the entity_id field. Args: dict_list: List of entity dictionaries. Returns: Sorted list of entities. \"\"\" return sorted ( dict_list , key = lambda x : x [ \"entity_id\" ]) def clean_entities ( self : CacheHolder , forbidden_prefixes : list [ str ], forbidden_substrings : list [ str ], ) -> HomeAssistantCache : \"\"\"Filter and normalize entities while populating sensors. Args: self: Cache holder to mutate. forbidden_prefixes: Entity ID prefixes to exclude. forbidden_substrings: Entity ID substrings to exclude. Returns: Updated HomeAssistantCache payload. \"\"\" for idx , entity in enumerate ( self . cache [ \"entities\" ]): if \"context\" in entity : self . cache [ \"entities\" ][ idx ] . pop ( \"context\" ) self . cache [ \"entities\" ][ idx ] . pop ( \"last_changed\" ) self . cache [ \"entities\" ][ idx ] . pop ( \"last_reported\" ) self . cache [ \"entities\" ][ idx ] . pop ( \"last_updated\" ) if \"attributes\" in entity : self . cache [ \"entities\" ][ idx ][ \"attributes\" ] . pop ( \"icon\" , None ) self . cache [ \"entities\" ][ idx ][ \"attributes\" ] . pop ( \"monitor_cert_days_remaining\" , None ) self . cache [ \"entities\" ][ idx ][ \"attributes\" ] . pop ( \"monitor_cert_is_valid\" , None ) self . cache [ \"entities\" ][ idx ][ \"attributes\" ] . pop ( \"monitor_hostname\" , None ) self . cache [ \"entities\" ][ idx ][ \"attributes\" ] . pop ( \"monitor_port\" , None ) if any ( entity [ \"entity_id\" ] . startswith ( prefix ) for prefix in forbidden_prefixes ): self . cache [ \"entities\" ] . remove ( entity ) if any ( substring in entity [ \"entity_id\" ] for substring in forbidden_substrings ): self . cache [ \"entities\" ] . remove ( entity ) if entity [ \"entity_id\" ] . startswith ( \"scene.\" ): self . cache [ \"entities\" ][ idx ] . pop ( \"state\" , None ) if entity [ \"entity_id\" ] . startswith ( \"sensor.\" ) or entity [ \"entity_id\" ] . startswith ( \"binary_sensor.\" ): self . cache [ \"sensors\" ] . append ( entity ) self . cache [ \"entities\" ] . pop ( idx ) self . cache [ \"entities\" ] = sort_by_entity_id ( self . cache [ \"entities\" ]) self . cache [ \"sensors\" ] = sort_by_entity_id ( self . cache [ \"sensors\" ]) return self . cache def wrapper ( self : SelfT , * args : P . args , ** kwargs : P . kwargs ) -> R : \"\"\"Invoke the wrapped function and normalize cache content. Args: self: Cache holder instance. *args: Positional arguments forwarded to the wrapped function. **kwargs: Keyword arguments forwarded to the wrapped function. Returns: Result of the wrapped function. \"\"\" result = func ( self , * args , ** kwargs ) forbidden_prefixes = [ \"alarm_control_panel.\" , \"automation.\" , \"binary_sensor.remote_ui\" , \"camera.\" , \"climate\" , \"conversation\" , \"device_tracker.kraken_raspberry_pi_5\" , \"media_player.axios\" , \"media_player.axios_2\" , \"media_player.chrome\" , \"media_player.fire_tv_192_168_1_12\" , \"person.\" , \"remote.\" , \"script.higher\" , \"sensor.hacs\" , \"sensor.hacs\" , \"sensor.kraken_raspberry_pi_5_\" , \"sensor.sonarr_commands\" , \"sensor.sun\" , \"sensor.uptimekuma_\" , \"stt.\" , \"sun.\" , \"switch.\" , \"switch.adam\" , \"switch.bedroom_camera_camera_motion_detection\" , \"tts.\" , \"update.\" , \"zone.home\" , ] forbidden_substrings = [ \"blink_kk_bedroom\" ] self . cache [ \"sensor\" ] = [] # Clean entities self . cache = clean_entities ( self , forbidden_prefixes , forbidden_substrings ) # Clean services self . cache [ \"services\" ] = [ service for service in self . cache [ \"services\" ] if service [ \"domain\" ] in self . cache [ \"allowed_domains\" ] ] # Retrieve entity and sensor IDs self . cache [ \"entity_ids\" ] = sorted ( self . cache [ \"entity_ids\" ]) self . cache [ \"sensor_ids\" ] = sorted ( self . cache [ \"sensor_ids\" ]) logging . info ( ( \"` {} ` modified cache to <(len) Entity IDs: {} ; (len) Entities: {} ; \" \"(len) Sensors: {} ; (len) Services: {} ;>\" ), func . __name__ , len ( self . cache [ \"entity_ids\" ]), len ( self . cache [ \"entities\" ]), len ( self . cache [ \"sensors\" ]), len ( self . cache [ \"services\" ]), ) return result return wrapper","title":"cache_monitor"},{"location":"reference/#clients-apps","text":"API entry point: apps/meeseeks_api/src/meeseeks_api/backend.py Chat entry point: apps/meeseeks_chat/src/meeseeks_chat/chat_master.py CLI entry point: apps/meeseeks_cli/src/meeseeks_cli/cli_master.py","title":"Clients (apps/)"},{"location":"reference/#home-assistant-integration-meeseeks_ha_conversation","text":"","title":"Home Assistant integration (meeseeks_ha_conversation)"},{"location":"reference/#meeseeks_ha_conversation.api","text":"Meeseeks API client.","title":"api"},{"location":"reference/#meeseeks_ha_conversation.api.MeeseeksApiClient","text":"Meeseeks API Client. Source code in meeseeks_ha_conversation/api.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 class MeeseeksApiClient : \"\"\"Meeseeks API Client.\"\"\" def __init__ ( self , base_url : str , timeout : int , session : aiohttp . ClientSession , ) -> None : \"\"\"Initialize the API client. Args: base_url: Base URL for the Meeseeks API. timeout: Request timeout in seconds. session: Shared aiohttp client session. \"\"\" self . _base_url = base_url . rstrip ( \"/\" ) self . _api_key = \"msk-strong-password\" self . timeout = timeout self . _session = session async def async_get_heartbeat ( self ) -> bool : \"\"\"Get heartbeat from the API. Returns: True when the service is considered healthy. \"\"\" # TODO: Implement a heartbeat check return True async def async_get_models ( self ) -> str : \"\"\"Get models from the API. Returns: JSON-serialized model list. \"\"\" # TODO: This is monkey-patched for now response_data : ModelsResponse = { \"models\" : [ { \"name\" : \"meeseeks\" , \"modified_at\" : \"2023-11-01T00:00:00.000000000-04:00\" , \"size\" : 0 , \"digest\" : None , } ] } return json . dumps ( response_data ) async def async_generate ( self , data : dict [ str , Any ] | None = None ) -> MeeseeksQueryResponse : \"\"\"Generate a completion from the API. Args: data: Request payload including prompt and optional session ID. Returns: Parsed query response payload. Raises: ValueError: If prompt data is missing. ApiJsonError: If the API returns unexpected data. \"\"\" if not data or \"prompt\" not in data : raise ValueError ( \"Missing prompt in request data.\" ) url_query = f \" { self . _base_url } /api/query\" data_custom = { \"query\" : str ( data [ \"prompt\" ]) . strip (), } session_id = data . get ( \"session_id\" ) if isinstance ( data , dict ) else None if session_id : data_custom [ \"session_id\" ] = session_id # Pass headers as None to use the default headers result = await self . _meeseeks_api_wrapper ( method = \"post\" , url = url_query , data = data_custom , headers = None , ) if isinstance ( result , str ): raise ApiJsonError ( \"Unexpected text response from Meeseeks API.\" ) return result async def _meeseeks_api_wrapper ( self , method : str , url : str , data : dict [ str , Any ] | None = None , headers : dict [ str , str ] | None = None , decode_json : bool = True , ) -> MeeseeksQueryResponse | str : \"\"\"Perform an HTTP request to the Meeseeks API. Args: method: HTTP method to use. url: Fully qualified request URL. data: Optional JSON payload to send. headers: Optional HTTP headers override. decode_json: Whether to parse JSON responses. Returns: Parsed response payload or raw text depending on decode_json. Raises: ApiJsonError: If the API returns an error payload. aiohttp.ClientResponseError: For non-2xx responses. \"\"\" if headers is None : headers = { \"accept\" : \"application/json\" , \"X-API-KEY\" : self . _api_key , \"Content-Type\" : \"application/json\" , } async with async_timeout . timeout ( self . timeout ): response = await self . _session . request ( method = method , url = url , headers = headers , json = data , ) response . raise_for_status () if decode_json : raw_data : dict [ str , Any ] = await response . json () if response . status == 404 : raise ApiJsonError ( raw_data . get ( \"error\" , \"Unknown error\" )) task_result = str ( raw_data . get ( \"task_result\" , \"\" )) response_data : MeeseeksQueryResponse = { \"task_result\" : task_result , \"response\" : str ( raw_data . get ( \"response\" , task_result )), \"context\" : str ( raw_data . get ( \"context\" , task_result )), \"session_id\" : raw_data . get ( \"session_id\" ), } LOGGER . debug ( \"Response data: %s \" , response_data ) return response_data else : LOGGER . debug ( \"Fallback to text response\" ) return await response . text ()","title":"MeeseeksApiClient"},{"location":"reference/#meeseeks_ha_conversation.api.MeeseeksApiClient.__init__","text":"Initialize the API client. Parameters: Name Type Description Default base_url str Base URL for the Meeseeks API. required timeout int Request timeout in seconds. required session ClientSession Shared aiohttp client session. required Source code in meeseeks_ha_conversation/api.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def __init__ ( self , base_url : str , timeout : int , session : aiohttp . ClientSession , ) -> None : \"\"\"Initialize the API client. Args: base_url: Base URL for the Meeseeks API. timeout: Request timeout in seconds. session: Shared aiohttp client session. \"\"\" self . _base_url = base_url . rstrip ( \"/\" ) self . _api_key = \"msk-strong-password\" self . timeout = timeout self . _session = session","title":"__init__"},{"location":"reference/#meeseeks_ha_conversation.api.MeeseeksApiClient.async_generate","text":"Generate a completion from the API. Parameters: Name Type Description Default data dict [ str , Any ] | None Request payload including prompt and optional session ID. None Returns: Type Description MeeseeksQueryResponse Parsed query response payload. Raises: Type Description ValueError If prompt data is missing. ApiJsonError If the API returns unexpected data. Source code in meeseeks_ha_conversation/api.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 async def async_generate ( self , data : dict [ str , Any ] | None = None ) -> MeeseeksQueryResponse : \"\"\"Generate a completion from the API. Args: data: Request payload including prompt and optional session ID. Returns: Parsed query response payload. Raises: ValueError: If prompt data is missing. ApiJsonError: If the API returns unexpected data. \"\"\" if not data or \"prompt\" not in data : raise ValueError ( \"Missing prompt in request data.\" ) url_query = f \" { self . _base_url } /api/query\" data_custom = { \"query\" : str ( data [ \"prompt\" ]) . strip (), } session_id = data . get ( \"session_id\" ) if isinstance ( data , dict ) else None if session_id : data_custom [ \"session_id\" ] = session_id # Pass headers as None to use the default headers result = await self . _meeseeks_api_wrapper ( method = \"post\" , url = url_query , data = data_custom , headers = None , ) if isinstance ( result , str ): raise ApiJsonError ( \"Unexpected text response from Meeseeks API.\" ) return result","title":"async_generate"},{"location":"reference/#meeseeks_ha_conversation.api.MeeseeksApiClient.async_get_heartbeat","text":"Get heartbeat from the API. Returns: Type Description bool True when the service is considered healthy. Source code in meeseeks_ha_conversation/api.py 53 54 55 56 57 58 59 60 async def async_get_heartbeat ( self ) -> bool : \"\"\"Get heartbeat from the API. Returns: True when the service is considered healthy. \"\"\" # TODO: Implement a heartbeat check return True","title":"async_get_heartbeat"},{"location":"reference/#meeseeks_ha_conversation.api.MeeseeksApiClient.async_get_models","text":"Get models from the API. Returns: Type Description str JSON-serialized model list. Source code in meeseeks_ha_conversation/api.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 async def async_get_models ( self ) -> str : \"\"\"Get models from the API. Returns: JSON-serialized model list. \"\"\" # TODO: This is monkey-patched for now response_data : ModelsResponse = { \"models\" : [ { \"name\" : \"meeseeks\" , \"modified_at\" : \"2023-11-01T00:00:00.000000000-04:00\" , \"size\" : 0 , \"digest\" : None , } ] } return json . dumps ( response_data )","title":"async_get_models"},{"location":"reference/#meeseeks_ha_conversation.api.MeeseeksQueryResponse","text":"Bases: TypedDict Schema for the main query response. Source code in meeseeks_ha_conversation/api.py 23 24 25 26 27 28 29 class MeeseeksQueryResponse ( TypedDict ): \"\"\"Schema for the main query response.\"\"\" task_result : str response : str context : str session_id : str | None","title":"MeeseeksQueryResponse"},{"location":"reference/#meeseeks_ha_conversation.api.ModelsResponse","text":"Bases: TypedDict Schema for the models list endpoint response. Source code in meeseeks_ha_conversation/api.py 17 18 19 20 class ModelsResponse ( TypedDict ): \"\"\"Schema for the models list endpoint response.\"\"\" models : list [ dict [ str , Any ]]","title":"ModelsResponse"},{"location":"reference/#meeseeks_ha_conversation.config_flow","text":"Adds config flow for Meeseeks.","title":"config_flow"},{"location":"reference/#meeseeks_ha_conversation.config_flow.MeeseeksConfigFlow","text":"Bases: ConfigFlow Handle a config flow for Meeseeks Conversation. Handles UI wizard. Source code in meeseeks_ha_conversation/config_flow.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 class MeeseeksConfigFlow ( config_entries . ConfigFlow , domain = DOMAIN ): # type: ignore[call-arg] \"\"\"Handle a config flow for Meeseeks Conversation. Handles UI wizard.\"\"\" VERSION = 1 client : MeeseeksApiClient async def async_step_user ( self , user_input : dict [ str , Any ] | None = None ) -> FlowResult : \"\"\"Handle the initial config flow step. Args: user_input: Submitted form data, if available. Returns: FlowResult for the configuration step. \"\"\" if user_input is None : return self . async_show_form ( step_id = \"user\" , data_schema = STEP_USER_DATA_SCHEMA ) # Search for duplicates with the same CONF_BASE_URL value. for existing_entry in self . _async_current_entries ( include_ignore = False ): if existing_entry . data . get ( CONF_BASE_URL ) == user_input [ CONF_BASE_URL ]: return self . async_abort ( reason = \"already_configured\" ) errors : dict [ str , str ] = {} try : self . client = MeeseeksApiClient ( base_url = cv . url_no_path ( user_input [ CONF_BASE_URL ]), timeout = user_input [ CONF_TIMEOUT ], session = async_create_clientsession ( self . hass ), ) response = await self . client . async_get_heartbeat () if not response : raise vol . Invalid ( \"Invalid Meeseeks server\" ) # except vol.Invalid: # errors[\"base\"] = \"invalid_url\" # except ApiTimeoutError: # errors[\"base\"] = \"timeout_connect\" # except ApiCommError: # errors[\"base\"] = \"cannot_connect\" # except ApiClientError as exception: # LOGGER.exception(\"Unexpected exception: %s\", exception) # errors[\"base\"] = \"unknown\" except Exception as exception : LOGGER . exception ( \"Unexpected exception: %s \" , exception ) errors [ \"base\" ] = \"unknown\" else : return self . async_create_entry ( title = f \"Meeseeks - { user_input [ CONF_BASE_URL ] } \" , data = { CONF_BASE_URL : user_input [ CONF_BASE_URL ]}, options = { CONF_TIMEOUT : user_input [ CONF_TIMEOUT ]}, ) return self . async_show_form ( step_id = \"user\" , data_schema = STEP_USER_DATA_SCHEMA , errors = errors ) @staticmethod def async_get_options_flow ( config_entry : config_entries . ConfigEntry , ) -> config_entries . OptionsFlow : \"\"\"Create the options flow. Args: config_entry: Existing config entry to edit. Returns: Options flow handler. \"\"\" return MeeseeksOptionsFlow ( config_entry )","title":"MeeseeksConfigFlow"},{"location":"reference/#meeseeks_ha_conversation.config_flow.MeeseeksConfigFlow.async_get_options_flow","text":"Create the options flow. Parameters: Name Type Description Default config_entry ConfigEntry Existing config entry to edit. required Returns: Type Description OptionsFlow Options flow handler. Source code in meeseeks_ha_conversation/config_flow.py 108 109 110 111 112 113 114 115 116 117 118 119 120 @staticmethod def async_get_options_flow ( config_entry : config_entries . ConfigEntry , ) -> config_entries . OptionsFlow : \"\"\"Create the options flow. Args: config_entry: Existing config entry to edit. Returns: Options flow handler. \"\"\" return MeeseeksOptionsFlow ( config_entry )","title":"async_get_options_flow"},{"location":"reference/#meeseeks_ha_conversation.config_flow.MeeseeksConfigFlow.async_step_user","text":"Handle the initial config flow step. Parameters: Name Type Description Default user_input dict [ str , Any ] | None Submitted form data, if available. None Returns: Type Description FlowResult FlowResult for the configuration step. Source code in meeseeks_ha_conversation/config_flow.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 async def async_step_user ( self , user_input : dict [ str , Any ] | None = None ) -> FlowResult : \"\"\"Handle the initial config flow step. Args: user_input: Submitted form data, if available. Returns: FlowResult for the configuration step. \"\"\" if user_input is None : return self . async_show_form ( step_id = \"user\" , data_schema = STEP_USER_DATA_SCHEMA ) # Search for duplicates with the same CONF_BASE_URL value. for existing_entry in self . _async_current_entries ( include_ignore = False ): if existing_entry . data . get ( CONF_BASE_URL ) == user_input [ CONF_BASE_URL ]: return self . async_abort ( reason = \"already_configured\" ) errors : dict [ str , str ] = {} try : self . client = MeeseeksApiClient ( base_url = cv . url_no_path ( user_input [ CONF_BASE_URL ]), timeout = user_input [ CONF_TIMEOUT ], session = async_create_clientsession ( self . hass ), ) response = await self . client . async_get_heartbeat () if not response : raise vol . Invalid ( \"Invalid Meeseeks server\" ) # except vol.Invalid: # errors[\"base\"] = \"invalid_url\" # except ApiTimeoutError: # errors[\"base\"] = \"timeout_connect\" # except ApiCommError: # errors[\"base\"] = \"cannot_connect\" # except ApiClientError as exception: # LOGGER.exception(\"Unexpected exception: %s\", exception) # errors[\"base\"] = \"unknown\" except Exception as exception : LOGGER . exception ( \"Unexpected exception: %s \" , exception ) errors [ \"base\" ] = \"unknown\" else : return self . async_create_entry ( title = f \"Meeseeks - { user_input [ CONF_BASE_URL ] } \" , data = { CONF_BASE_URL : user_input [ CONF_BASE_URL ]}, options = { CONF_TIMEOUT : user_input [ CONF_TIMEOUT ]}, ) return self . async_show_form ( step_id = \"user\" , data_schema = STEP_USER_DATA_SCHEMA , errors = errors )","title":"async_step_user"},{"location":"reference/#meeseeks_ha_conversation.config_flow.MeeseeksOptionsFlow","text":"Bases: OptionsFlow Meeseeks config flow options handler. Source code in meeseeks_ha_conversation/config_flow.py 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 class MeeseeksOptionsFlow ( config_entries . OptionsFlow ): \"\"\"Meeseeks config flow options handler.\"\"\" def __init__ ( self , config_entry : config_entries . ConfigEntry ) -> None : \"\"\"Initialize options flow. Args: config_entry: Config entry to manage. \"\"\" self . config_entry = config_entry self . options = dict ( config_entry . options ) async def async_step_init ( self , user_input : dict [ str , Any ] | None = None ) -> FlowResult : \"\"\"Show the options menu. Args: user_input: Submitted form data, if available. Returns: FlowResult for the options menu. \"\"\" return self . async_show_menu ( step_id = \"init\" , menu_options = MENU_OPTIONS ) async def async_step_all_set ( self , user_input : dict [ str , Any ] | None = None ) -> FlowResult : \"\"\"Handle the \"all_set\" options step. Args: user_input: Submitted form data, if available. Returns: FlowResult for the options menu. \"\"\" return self . async_show_menu ( step_id = \"init\" , menu_options = MENU_OPTIONS ) async def async_step_general_config ( self , user_input : dict [ str , Any ] | None = None ) -> FlowResult : \"\"\"Handle the general configuration step. Args: user_input: Submitted form data, if available. Returns: FlowResult for the options menu. \"\"\" return self . async_show_menu ( step_id = \"init\" , menu_options = MENU_OPTIONS ) async def async_step_prompt_system ( self , user_input : dict [ str , Any ] | None = None ) -> FlowResult : \"\"\"Handle the prompt system configuration step. Args: user_input: Submitted form data, if available. Returns: FlowResult for the options menu. \"\"\" return self . async_show_menu ( step_id = \"init\" , menu_options = MENU_OPTIONS ) async def async_step_model_config ( self , user_input : dict [ str , Any ] | None = None ) -> FlowResult : \"\"\"Handle the model configuration step. Args: user_input: Submitted form data, if available. Returns: FlowResult for the options menu. \"\"\" return self . async_show_menu ( step_id = \"init\" , menu_options = MENU_OPTIONS )","title":"MeeseeksOptionsFlow"},{"location":"reference/#meeseeks_ha_conversation.config_flow.MeeseeksOptionsFlow.__init__","text":"Initialize options flow. Parameters: Name Type Description Default config_entry ConfigEntry Config entry to manage. required Source code in meeseeks_ha_conversation/config_flow.py 126 127 128 129 130 131 132 133 def __init__ ( self , config_entry : config_entries . ConfigEntry ) -> None : \"\"\"Initialize options flow. Args: config_entry: Config entry to manage. \"\"\" self . config_entry = config_entry self . options = dict ( config_entry . options )","title":"__init__"},{"location":"reference/#meeseeks_ha_conversation.config_flow.MeeseeksOptionsFlow.async_step_all_set","text":"Handle the \"all_set\" options step. Parameters: Name Type Description Default user_input dict [ str , Any ] | None Submitted form data, if available. None Returns: Type Description FlowResult FlowResult for the options menu. Source code in meeseeks_ha_conversation/config_flow.py 146 147 148 149 150 151 152 153 154 155 async def async_step_all_set ( self , user_input : dict [ str , Any ] | None = None ) -> FlowResult : \"\"\"Handle the \"all_set\" options step. Args: user_input: Submitted form data, if available. Returns: FlowResult for the options menu. \"\"\" return self . async_show_menu ( step_id = \"init\" , menu_options = MENU_OPTIONS )","title":"async_step_all_set"},{"location":"reference/#meeseeks_ha_conversation.config_flow.MeeseeksOptionsFlow.async_step_general_config","text":"Handle the general configuration step. Parameters: Name Type Description Default user_input dict [ str , Any ] | None Submitted form data, if available. None Returns: Type Description FlowResult FlowResult for the options menu. Source code in meeseeks_ha_conversation/config_flow.py 157 158 159 160 161 162 163 164 165 166 167 168 async def async_step_general_config ( self , user_input : dict [ str , Any ] | None = None ) -> FlowResult : \"\"\"Handle the general configuration step. Args: user_input: Submitted form data, if available. Returns: FlowResult for the options menu. \"\"\" return self . async_show_menu ( step_id = \"init\" , menu_options = MENU_OPTIONS )","title":"async_step_general_config"},{"location":"reference/#meeseeks_ha_conversation.config_flow.MeeseeksOptionsFlow.async_step_init","text":"Show the options menu. Parameters: Name Type Description Default user_input dict [ str , Any ] | None Submitted form data, if available. None Returns: Type Description FlowResult FlowResult for the options menu. Source code in meeseeks_ha_conversation/config_flow.py 135 136 137 138 139 140 141 142 143 144 async def async_step_init ( self , user_input : dict [ str , Any ] | None = None ) -> FlowResult : \"\"\"Show the options menu. Args: user_input: Submitted form data, if available. Returns: FlowResult for the options menu. \"\"\" return self . async_show_menu ( step_id = \"init\" , menu_options = MENU_OPTIONS )","title":"async_step_init"},{"location":"reference/#meeseeks_ha_conversation.config_flow.MeeseeksOptionsFlow.async_step_model_config","text":"Handle the model configuration step. Parameters: Name Type Description Default user_input dict [ str , Any ] | None Submitted form data, if available. None Returns: Type Description FlowResult FlowResult for the options menu. Source code in meeseeks_ha_conversation/config_flow.py 183 184 185 186 187 188 189 190 191 192 async def async_step_model_config ( self , user_input : dict [ str , Any ] | None = None ) -> FlowResult : \"\"\"Handle the model configuration step. Args: user_input: Submitted form data, if available. Returns: FlowResult for the options menu. \"\"\" return self . async_show_menu ( step_id = \"init\" , menu_options = MENU_OPTIONS )","title":"async_step_model_config"},{"location":"reference/#meeseeks_ha_conversation.config_flow.MeeseeksOptionsFlow.async_step_prompt_system","text":"Handle the prompt system configuration step. Parameters: Name Type Description Default user_input dict [ str , Any ] | None Submitted form data, if available. None Returns: Type Description FlowResult FlowResult for the options menu. Source code in meeseeks_ha_conversation/config_flow.py 170 171 172 173 174 175 176 177 178 179 180 181 async def async_step_prompt_system ( self , user_input : dict [ str , Any ] | None = None ) -> FlowResult : \"\"\"Handle the prompt system configuration step. Args: user_input: Submitted form data, if available. Returns: FlowResult for the options menu. \"\"\" return self . async_show_menu ( step_id = \"init\" , menu_options = MENU_OPTIONS )","title":"async_step_prompt_system"},{"location":"reference/#meeseeks_ha_conversation.const","text":"Constants for meeseeks_conversation.","title":"const"},{"location":"reference/#meeseeks_ha_conversation.coordinator","text":"DataUpdateCoordinator for meeseeks_conversation.","title":"coordinator"},{"location":"reference/#meeseeks_ha_conversation.coordinator.MeeseeksDataUpdateCoordinator","text":"Bases: DataUpdateCoordinator Class to manage fetching data from the API. Source code in meeseeks_ha_conversation/coordinator.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 class MeeseeksDataUpdateCoordinator ( DataUpdateCoordinator ): \"\"\"Class to manage fetching data from the API.\"\"\" config_entry : ConfigEntry def __init__ ( self , hass : HomeAssistant , client : MeeseeksApiClient , ) -> None : \"\"\"Initialize the coordinator. Args: hass: Home Assistant core instance. client: API client for Meeseeks. \"\"\" self . client = client super () . __init__ ( hass = hass , logger = LOGGER , name = DOMAIN , update_interval = timedelta ( minutes = 5 ), ) async def _async_update_data ( self ) -> bool : \"\"\"Update data via library. Returns: True when the heartbeat check succeeds. Raises: UpdateFailed: If the API heartbeat fails. \"\"\" try : return await self . client . async_get_heartbeat () except ApiClientError as exception : raise UpdateFailed ( exception ) from exception","title":"MeeseeksDataUpdateCoordinator"},{"location":"reference/#meeseeks_ha_conversation.coordinator.MeeseeksDataUpdateCoordinator.__init__","text":"Initialize the coordinator. Parameters: Name Type Description Default hass HomeAssistant Home Assistant core instance. required client MeeseeksApiClient API client for Meeseeks. required Source code in meeseeks_ha_conversation/coordinator.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def __init__ ( self , hass : HomeAssistant , client : MeeseeksApiClient , ) -> None : \"\"\"Initialize the coordinator. Args: hass: Home Assistant core instance. client: API client for Meeseeks. \"\"\" self . client = client super () . __init__ ( hass = hass , logger = LOGGER , name = DOMAIN , update_interval = timedelta ( minutes = 5 ), )","title":"__init__"},{"location":"reference/#meeseeks_ha_conversation.exceptions","text":"The exceptions used by Extended OpenAI Conversation.","title":"exceptions"},{"location":"reference/#meeseeks_ha_conversation.exceptions.ApiClientError","text":"Bases: HomeAssistantError Exception to indicate a general API error. Source code in meeseeks_ha_conversation/exceptions.py 6 7 class ApiClientError ( HomeAssistantError ): \"\"\"Exception to indicate a general API error.\"\"\"","title":"ApiClientError"},{"location":"reference/#meeseeks_ha_conversation.exceptions.ApiCommError","text":"Bases: ApiClientError Exception to indicate a communication error. Source code in meeseeks_ha_conversation/exceptions.py 10 11 class ApiCommError ( ApiClientError ): \"\"\"Exception to indicate a communication error.\"\"\"","title":"ApiCommError"},{"location":"reference/#meeseeks_ha_conversation.exceptions.ApiJsonError","text":"Bases: ApiClientError Exception to indicate an error with json response. Source code in meeseeks_ha_conversation/exceptions.py 14 15 class ApiJsonError ( ApiClientError ): \"\"\"Exception to indicate an error with json response.\"\"\"","title":"ApiJsonError"},{"location":"reference/#meeseeks_ha_conversation.exceptions.ApiTimeoutError","text":"Bases: ApiClientError Exception to indicate a timeout error. Source code in meeseeks_ha_conversation/exceptions.py 18 19 class ApiTimeoutError ( ApiClientError ): \"\"\"Exception to indicate a timeout error.\"\"\"","title":"ApiTimeoutError"},{"location":"reference/#meeseeks_ha_conversation.helpers","text":"Helper functions for Meeseeks.","title":"helpers"},{"location":"reference/#meeseeks_ha_conversation.helpers.ExposedEntity","text":"Bases: TypedDict Typed representation of a Home Assistant entity exposed to conversation. Source code in meeseeks_ha_conversation/helpers.py 13 14 15 16 17 18 19 class ExposedEntity ( TypedDict ): \"\"\"Typed representation of a Home Assistant entity exposed to conversation.\"\"\" entity_id : str name : str state : str aliases : list [ str ]","title":"ExposedEntity"},{"location":"reference/#meeseeks_ha_conversation.helpers.get_exposed_entities","text":"Return exposed entities. Parameters: Name Type Description Default hass HomeAssistant Home Assistant core instance. required Returns: Type Description list [ ExposedEntity ] List of exposed entities and their metadata. Source code in meeseeks_ha_conversation/helpers.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 def get_exposed_entities ( hass : HomeAssistant ) -> list [ ExposedEntity ]: \"\"\"Return exposed entities. Args: hass: Home Assistant core instance. Returns: List of exposed entities and their metadata. \"\"\" hass_entity = entity_registry . async_get ( hass ) exposed_entities : list [ ExposedEntity ] = [] for state in hass . states . async_all (): if async_should_expose ( hass , CONVERSATION_DOMAIN , state . entity_id ): entity = hass_entity . async_get ( state . entity_id ) exposed_entities . append ( { \"entity_id\" : state . entity_id , \"name\" : state . name , \"state\" : state . state , \"aliases\" : entity . aliases if entity else [], } ) return exposed_entities","title":"get_exposed_entities"},{"location":"session-runtime/","text":"The session runtime is a small shared facade that powers both the CLI and the REST API. It centralizes session lifecycle, async run tracking, and cancellation. Event polling is exposed via the API; the CLI reads events directly in-process when needed. What it does Resolves sessions by id, tag, or fork. Runs orchestration synchronously or in a background thread. Tracks active runs per session and supports cancellation. Filters session events for polling ( after timestamp). Summarizes a session (title, status, done reason, context, archived flag). Filters empty sessions from listings; archived sessions are hidden unless requested. Core commands These commands are supported across interfaces: - /compact : compact the session transcript and write a summary. - /terminate : request cancellation for the active run. - /status : return the current session summary. The runtime only recognizes these core commands. Interface-specific commands remain in each UI layer. Event polling model (API) Events are stored as JSONL records by SessionStore . The runtime exposes load_events(session_id, after) which filters by the ISO-8601 timestamp ( ts ) on each event. Typical polling flow: 1. Create a session. 2. Start an async run. 3. Poll /events with after to receive only new records. Event payload notes: - action_plan payloads include steps: [{title, description}] . - Tool activity uses tool_id , operation , and tool_input in tool_result and permission events. Minimal usage (Python) from meeseeks_core.session_runtime import SessionRuntime from meeseeks_core.session_store import SessionStore runtime = SessionRuntime ( session_store = SessionStore ()) session_id = runtime . resolve_session ( session_tag = \"primary\" ) # synchronous run result = runtime . run_sync ( user_query = \"Hello\" , session_id = session_id ) # async run + polling runtime . start_async ( session_id = session_id , user_query = \"Do the task\" ) events = runtime . load_events ( session_id , after = None ) Archiving behavior SessionStore.archive_session(session_id) marks a session archived. SessionStore.unarchive_session(session_id) removes the archive flag. SessionRuntime.list_sessions() hides archived sessions by default. Use list_sessions(include_archived=True) to include them. Design goals Keep the core orchestration engine centralized. Make interface layers thin and easy to extend. Avoid duplicate session lifecycle logic.","title":"Session Runtime"},{"location":"session-runtime/#what-it-does","text":"Resolves sessions by id, tag, or fork. Runs orchestration synchronously or in a background thread. Tracks active runs per session and supports cancellation. Filters session events for polling ( after timestamp). Summarizes a session (title, status, done reason, context, archived flag). Filters empty sessions from listings; archived sessions are hidden unless requested.","title":"What it does"},{"location":"session-runtime/#core-commands","text":"These commands are supported across interfaces: - /compact : compact the session transcript and write a summary. - /terminate : request cancellation for the active run. - /status : return the current session summary. The runtime only recognizes these core commands. Interface-specific commands remain in each UI layer.","title":"Core commands"},{"location":"session-runtime/#event-polling-model-api","text":"Events are stored as JSONL records by SessionStore . The runtime exposes load_events(session_id, after) which filters by the ISO-8601 timestamp ( ts ) on each event. Typical polling flow: 1. Create a session. 2. Start an async run. 3. Poll /events with after to receive only new records. Event payload notes: - action_plan payloads include steps: [{title, description}] . - Tool activity uses tool_id , operation , and tool_input in tool_result and permission events.","title":"Event polling model (API)"},{"location":"session-runtime/#minimal-usage-python","text":"from meeseeks_core.session_runtime import SessionRuntime from meeseeks_core.session_store import SessionStore runtime = SessionRuntime ( session_store = SessionStore ()) session_id = runtime . resolve_session ( session_tag = \"primary\" ) # synchronous run result = runtime . run_sync ( user_query = \"Hello\" , session_id = session_id ) # async run + polling runtime . start_async ( session_id = session_id , user_query = \"Do the task\" ) events = runtime . load_events ( session_id , after = None )","title":"Minimal usage (Python)"},{"location":"session-runtime/#archiving-behavior","text":"SessionStore.archive_session(session_id) marks a session archived. SessionStore.unarchive_session(session_id) removes the archive flag. SessionRuntime.list_sessions() hides archived sessions by default. Use list_sessions(include_archived=True) to include them.","title":"Archiving behavior"},{"location":"session-runtime/#design-goals","text":"Keep the core orchestration engine centralized. Make interface layers thin and easy to extend. Avoid duplicate session lifecycle logic.","title":"Design goals"}]}